

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="万宇">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、排序算法概述1. 排序的时间复杂度排序方法比较时间复杂度时，如果可能，应该比较三种情况下的两种属性，但一般不分开讨论这两种属性 情况：  最好情况（通常数据已排序） 最坏情况（数据按相反顺序排列） 平均情况（数据顺序是随机的）  属性：  比较次数 数据移动次数  有些排序方法无视数据的原始顺序，都执行相同的操作。这类算法的性能测量很简单，但其效果通常不是很好。有很多其他方法更灵活，它们在上述">
<meta property="og:type" content="article">
<meta property="og:title" content="Wynn&#39;s blog">
<meta property="og:url" content="http://jswanyu.github.io/2023/05/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9A07.%E6%8E%92%E5%BA%8F/index.html">
<meta property="og:site_name" content="Wynn&#39;s blog">
<meta property="og:description" content="一、排序算法概述1. 排序的时间复杂度排序方法比较时间复杂度时，如果可能，应该比较三种情况下的两种属性，但一般不分开讨论这两种属性 情况：  最好情况（通常数据已排序） 最坏情况（数据按相反顺序排列） 平均情况（数据顺序是随机的）  属性：  比较次数 数据移动次数  有些排序方法无视数据的原始顺序，都执行相同的操作。这类算法的性能测量很简单，但其效果通常不是很好。有很多其他方法更灵活，它们在上述">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/selectionSort%E7%A4%BA%E6%84%8F%E5%9B%BE.gif">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/bubbleSort%E7%A4%BA%E6%84%8F%E5%9B%BE.gif">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/DataStructure%20and%20Algorithm/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-%E5%9B%BE%E7%A4%BA.gif">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/DataStructure%20and%20Algorithm/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-%E5%9B%BE%E7%A4%BA1.gif">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/insertionSort%E7%A4%BA%E6%84%8F%E5%9B%BE.gif">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/DataStructure%20and%20Algorithm/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%AF%B9%E6%AF%94%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%9B%BE.png">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/mergeSort%E7%A4%BA%E6%84%8F%E5%9B%BE.gif">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E5%BF%AB%E6%8E%92%E6%9C%80%E5%88%9D%E7%89%88%E6%9C%AC%E5%8A%A9%E8%AE%B0%E5%9B%BE.png">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E5%8F%8C%E8%B7%AF%E5%BF%AB%E6%8E%92%E5%8A%A9%E8%AE%B0%E5%9B%BE2.png">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E4%B8%89%E8%B7%AF%E5%BF%AB%E6%8E%92%E5%8A%A9%E8%AE%B0%E5%9B%BE.png">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/QuickSort.png">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/QuickSort2Ways.png">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/QuickSort3Ways.png">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97.png">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E6%9C%80%E5%A4%A7%E5%A0%86.png">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E6%9C%80%E5%A4%A7%E5%A0%861.png">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E5%A0%86-%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%85%83%E7%B4%A0.gif">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E5%A0%86-%E5%8F%96%E5%87%BA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0.gif">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F-%E5%A0%86%E6%8E%92%E5%BA%8F.gif">
<meta property="article:published_time" content="2023-05-15T13:15:15.862Z">
<meta property="article:modified_time" content="2023-05-15T16:13:30.991Z">
<meta property="article:author" content="万宇">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png">
  
  
  
  <title>Wynn&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"jswanyu.github.io","root":"/","version":"1.9.1","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":false},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wynn&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                时间线
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text=""></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-05-15 21:15" pubdate>
          2023年5月15日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          22k 字
        
      </span>
    

    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none"></h1>
            
            <div class="markdown-body">
              
              <h1 id="一、排序算法概述"><a href="#一、排序算法概述" class="headerlink" title="一、排序算法概述"></a>一、排序算法概述</h1><h2 id="1-排序的时间复杂度"><a href="#1-排序的时间复杂度" class="headerlink" title="1. 排序的时间复杂度"></a>1. 排序的时间复杂度</h2><p>排序方法比较时间复杂度时，如果可能，应该比较三种情况下的两种属性，但一般不分开讨论这两种属性</p>
<p>情况：</p>
<ul>
<li>最好情况（通常数据已排序）</li>
<li>最坏情况（数据按相反顺序排列）</li>
<li>平均情况（数据顺序是随机的）</li>
</ul>
<p>属性：</p>
<ul>
<li>比较次数</li>
<li>数据移动次数</li>
</ul>
<p>有些排序方法无视数据的原始顺序，都执行相同的操作。这类算法的性能测量很简单，但其效果通常不是很好。有很多其他方法更灵活，它们在上述3种情况下的执行效果也不同。</p>
<p>数据的比较次数和移动次数并不是一定相同的。算法可能在数据比较上的效率比较高，而在数据移动上的效率很差，反之亦然。因此，在选择何种算法时一定要考虑实际情况。例如：</p>
<p>如果只比较简单的关键字，比如整数或字符，那么比较起来就相对快一些，比较的代价也不大。如果比较的是字符串或者数字数组，那么比较的代价就会显著提高，这时对比较效率的考量就很重要。另一方面，如果移动的数据项很大，例如结构，那么在考虑效率时，移动次数这一因素就会非常突出。所有理论上建立的度量方法都应当谨慎使用，而所有理论上的考虑都应根据实际应用再三权衡。毕竟,实际应用是理论决策的样板。</p>
<p>各种排序算法的复杂度是不同的。有时，简单的方法比复杂的方法只有20%的效率损失。如果在程序中只是偶尔用到排序，并且只是对很小的数据集进行排序，那么就没有太多必要使用复杂且效率较高的算法，同样的操作可以利用更简单的方法和代码来执行。但是如果有成千上万的数据项需要进行排序，那么20%的效率是不能忽视的。对于一些数量较少的数据来说，简单的算法通常比复杂的算法执行得更好，只有在数据集合很大时，复杂算法的效率优势才能明显体现出来。</p>
<h2 id="2-排序的稳定性"><a href="#2-排序的稳定性" class="headerlink" title="2. 排序的稳定性"></a>2. 排序的稳定性</h2><p>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r<sub>i</sub> &#x3D;r<sub>j</sub>，且r<sub>i</sub>在r<sub>j</sub>之前，而在排序后的序列中，r<sub>i</sub> 仍在r<sub>j</sub>之前，则称这种排序算法是稳定的；否则称为不稳定的</p>
<p> 举个应用的例子： ABCDE排队办事，然后每个人办事所用时长对应上面表里面的数字，也就是：A5,B8,C5,D2,E9； 这时候为了减少办事整体时间，就优先从用时最短的开始办起，于是乎排个序； 如果是稳定排序，则应该是：D2,A5,C5,B8,E9，合情合理、相安无事； 如果是不稳定的，就如上面提到的选择排序，那排序结果就变成：D2,C5,A5,B8,E9，很显然排序之后本应该在A后面的C跑到前面去了，如果这是现实排队的话，说不定两人就排队的先来后到原则发生争执，开始真人PK了。</p>
<p>如果只是针对数值类型，谈论稳定性没有意义。稳定性针对有多个属性的对象类型而言</p>
<p>一个感性的认知（非严谨的证明）：一点一点挪动的排序算法是稳定的</p>
<p>比如冒泡排序是一个一个交换的，他就是稳定的。再比如希尔排序，由于分组的原因，不能保证稳定性</p>
<p>一个算法的稳定与否是由具体的实现方式决定的，代码实现过程中有一些细节，有时候忽略了细节，原则上稳定的算法也会写出不稳定的代码</p>
<h2 id="3-常见排序算法"><a href="#3-常见排序算法" class="headerlink" title="3. 常见排序算法"></a>3. 常见排序算法</h2><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png" srcset="/img/loading.gif" lazyload alt="sort"></p>
<p>时间复杂度为O(n^2)的算法一般也是基本的排序算法，例如插入排序、选择排序、冒泡排序。他们具有有以下特点：</p>
<ul>
<li><p>编码简单，易于实现，是一些简单情景的首选</p>
</li>
<li><p>在一些特殊情况下，简单的排序算法更有效</p>
</li>
<li><p>简单的排序算法思想衍生出复杂的排序算法</p>
</li>
<li><p>作为子过程，改进更复杂的算法</p>
</li>
</ul>
<p>一般来说，插入排序&gt;选择排序&gt;冒泡排序</p>
<h1 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h1><h2 id="1-概念及其介绍"><a href="#1-概念及其介绍" class="headerlink" title="1. 概念及其介绍"></a>1. 概念及其介绍</h2><p>选择排序是一种简单直观的排序算法</p>
<p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。重复第二步，直到所有元素均排序完毕。</p>
<h2 id="2-算法性能"><a href="#2-算法性能" class="headerlink" title="2. 算法性能"></a>2. 算法性能</h2><table>
<thead>
<tr>
<th align="center">算法</th>
<th align="center">最好时间</th>
<th align="center">最坏时间</th>
<th align="center">平均时间</th>
<th align="center">额外空间</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">选择排序</td>
<td align="center">O(n^2）</td>
<td align="center">O(n^2)</td>
<td align="center">O(n^2)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
</tbody></table>
<p>关于稳定性：选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n - 1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等 的元素后面，那么交换后稳定性就被破坏了。</p>
<p>比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p>
<h2 id="3-过程图示"><a href="#3-过程图示" class="headerlink" title="3. 过程图示"></a>3. 过程图示</h2><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/selectionSort%E7%A4%BA%E6%84%8F%E5%9B%BE.gif" srcset="/img/loading.gif" lazyload alt="selectionSort"></p>
<h2 id="4-实例代码"><a href="#4-实例代码" class="headerlink" title="4. 实例代码"></a>4. 实例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectionSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(E[] arr)</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-comment">//寻找[i,n)区间里的最小值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i;    <span class="hljs-comment">//最小值的索引为i</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>; j &lt; arr.length; j++)&#123;   <span class="hljs-comment">//从i的下一个数开始</span><br>                <span class="hljs-comment">//如果找到一个比第i个数小的数，就把他所在的索引记为当前轮次的最小值</span><br>                <span class="hljs-keyword">if</span> (arr[j].compareTo(arr[minIndex])&lt;<span class="hljs-number">0</span>) <br>                    minIndex = j;<br>            &#125;<br>            swap(arr,i,minIndex);  <span class="hljs-comment">//将最小值交换到第i个数处</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(E[] arr,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>







<h2 id="5-改进"><a href="#5-改进" class="headerlink" title="5. 改进"></a>5. 改进</h2><h3 id="改进一：减少不必要的交换次数"><a href="#改进一：减少不必要的交换次数" class="headerlink" title="改进一：减少不必要的交换次数"></a>改进一：减少不必要的交换次数</h3><p>这里有一个问题就最后一步交换过程总会发生，如果元素的位置本身就是合理的，其实没必要交换，会带来3次冗余移动，可以加一个条件语句，再判定是否要交换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectionSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(E[] arr)</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i;   <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>; j &lt; arr.length; j++)   <br>                <span class="hljs-keyword">if</span> (arr[j].compareTo(arr[minIndex])&lt;<span class="hljs-number">0</span>) <br>                    minIndex = j;<br>            <span class="hljs-keyword">if</span>(i != minIndex)<span class="hljs-comment">//比较索引即可，无需比较具体数据</span><br>            	swap(arr,i,minIndex);  <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(E[] arr,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述改进将在程序中引入新的条件以增加n-1次比较，这样的改善是否有必要呢?这取决于排序元素的类型，如果元素是<strong>数字或字符</strong>，那么引入新的条件来避免冗余交换，其实效率并没有提高多少；如果data中的元素是大的<strong>复合实体，如数组或结构</strong>，那么一次交换(需要3次赋值)可能需要花费相当于100次索引比较的时间，因此建议使用有条件的swap操作。</p>
<h3 id="改进二：双指针法–每一轮中可以同时找到当前未处理元素的最大值和最小值"><a href="#改进二：双指针法–每一轮中可以同时找到当前未处理元素的最大值和最小值" class="headerlink" title="改进二：双指针法–每一轮中可以同时找到当前未处理元素的最大值和最小值"></a>改进二：双指针法–每一轮中可以同时找到当前未处理元素的最大值和最小值</h3><p>了解即可</p>
<p>来源：<a target="_blank" rel="noopener" href="https://github.com/liuyubobobo/Play-with-Algorithms/blob/master/02-Sorting-Basic/Course%20Code%20(Java)/Optional-01-Optimized-Selection-Sort/src/bobo/algo/SelectionSort2.java">https://github.com/liuyubobobo/Play-with-Algorithms/blob/master/02-Sorting-Basic/Course%20Code%20(Java)/Optional-01-Optimized-Selection-Sort/src/bobo/algo/SelectionSort2.java</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在每一轮中, 可以同时找到当前未处理元素的最大值和最小值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectionSort2</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SelectionSort2</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] arr)</span></span>&#123;<br>        <span class="hljs-comment">//左右指针</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = arr.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> minIndex = left;<br>            <span class="hljs-type">int</span> maxIndex = right;<br><br>            <span class="hljs-comment">// 在每一轮查找时, 要保证arr[minIndex] &lt;= arr[maxIndex]</span><br>            <span class="hljs-keyword">if</span>(arr[minIndex].<span class="hljs-built_in">compareTo</span>(arr[maxIndex]) &gt; <span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">swap</span>(arr, minIndex, maxIndex);<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = left + <span class="hljs-number">1</span> ; i &lt; right; i ++)<br>                <span class="hljs-keyword">if</span>(arr[i].<span class="hljs-built_in">compareTo</span>(arr[minIndex]) &lt; <span class="hljs-number">0</span>)<br>                    minIndex = i;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[i].<span class="hljs-built_in">compareTo</span>(arr[maxIndex]) &gt; <span class="hljs-number">0</span>)<br>                    maxIndex = i;<br><br>            <span class="hljs-built_in">swap</span>(arr, left, minIndex);<br>            <span class="hljs-built_in">swap</span>(arr, right, maxIndex);<br><br>            left ++;<br>            right --;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Object[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>        Object t = arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="三、冒泡排序"><a href="#三、冒泡排序" class="headerlink" title="三、冒泡排序"></a>三、冒泡排序</h1><h2 id="1-概念及其介绍-1"><a href="#1-概念及其介绍-1" class="headerlink" title="1. 概念及其介绍"></a>1. 概念及其介绍</h2><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。</p>
<p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<h2 id="2-算法性能-1"><a href="#2-算法性能-1" class="headerlink" title="2. 算法性能"></a>2. 算法性能</h2><table>
<thead>
<tr>
<th align="center">算法</th>
<th align="center">最好时间</th>
<th align="center">最坏时间</th>
<th align="center">平均时间</th>
<th align="center">额外空间</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡排序</td>
<td align="center">O(n）</td>
<td align="center">O(n^2)</td>
<td align="center">O(n^2)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<p>关于稳定性：因为在比较的过程中，当两个相同大小的元素相邻，只比较大或者小，所以相等的时候是不会交换位置的。而当两个相等元素离着比较远的时候，也只是会把他们交换到相邻的位置。他们的位置前后关系不会发生任何变化，所以算法是稳定的。</p>
<h2 id="3-过程图示-1"><a href="#3-过程图示-1" class="headerlink" title="3. 过程图示"></a>3. 过程图示</h2><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/bubbleSort%E7%A4%BA%E6%84%8F%E5%9B%BE.gif" srcset="/img/loading.gif" lazyload alt="bubbleSort"></p>
<h2 id="4-实例代码-1"><a href="#4-实例代码-1" class="headerlink" title="4. 实例代码"></a>4. 实例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BubbleSort</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(E[] arr)</span>&#123;<br>        <span class="hljs-comment">//对于n个数，要进行n-1轮循环，每一轮将最大的数冒到最后面去</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length-<span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-comment">//n个数中，相邻的元素就有n-1组，第0轮要比较n-1次，第i轮要比较n-1-i</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length-<span class="hljs-number">1</span>-i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (arr[j].compareTo(arr[j+<span class="hljs-number">1</span>])&gt;<span class="hljs-number">0</span>)<br>                    swap(arr,j,j+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="5-改进-1"><a href="#5-改进-1" class="headerlink" title="5. 改进"></a>5. 改进</h2><h3 id="改进一：添加标志位，如果某次没有发生交换，则停止排序"><a href="#改进一：添加标志位，如果某次没有发生交换，则停止排序" class="headerlink" title="改进一：添加标志位，如果某次没有发生交换，则停止排序"></a>改进一：添加标志位，如果某次没有发生交换，则停止排序</h3><p>适合本身就有序的序列，比如 2  3   5   7   8，扫描一次剩下的元素发现没有元素需要交换，说明此时数组已经有序了，程序提前终止</p>
<p>对于完全有序的数组，它就成了O(n)复杂度（如果是原始的写法对于完全有序的数组还是O(n^2)）</p>
<p>对于完全随机的这种改进并不很显著，因为在较坏情况下，改进过的冒泡排序过程跟未改进过的差不多。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BubbleSort</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(E[] arr)</span></span>&#123;<br>        <span class="hljs-comment">//设置一个标志，如果这一趟发生了交换，则为true，否则为false。如果有一趟没有发生交换，说明排序已经完成</span><br>        boolean sorted = <span class="hljs-literal">true</span>;  <span class="hljs-comment">//第一次判断时标志位为true</span><br>        <span class="hljs-comment">//外层循环需要flag为true</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length<span class="hljs-number">-1</span> &amp;&amp; sorted; i++) &#123;<br>            <span class="hljs-comment">//每次的内层循环将标志位设为假，否则没意义</span><br>            sorted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">//内层循环会执行到底</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length<span class="hljs-number">-1</span>-i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (arr[j].<span class="hljs-built_in">compareTo</span>(arr[j+<span class="hljs-number">1</span>])&gt;<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-built_in">swap</span>(arr,j,j+<span class="hljs-number">1</span>);<br>                    sorted = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="改进二：减少内层循环比较的元素"><a href="#改进二：减少内层循环比较的元素" class="headerlink" title="改进二：减少内层循环比较的元素"></a>改进二：减少内层循环比较的元素</h3><p>对于每次循环已经冒出去的值，可以不用去考虑它，在内层循环中记录最后一次的交换位置,在此之后的元素在下一轮扫描中均不考虑。比如  3  7  1  2  8  9，第一轮的冒泡会变为  3  1   2   7   8   9 ，最后一次交换位置就是在交换完7之后，那么此后的元素均不用考虑了，都已经放到了合适的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BubbleSort</span> &#123;<br>    <br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Comparable[] arr)</span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i + <span class="hljs-number">1</span> &lt; arr.length; ) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lastSwappedIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length-<span class="hljs-number">1</span>-i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j].compareTo(arr[j+<span class="hljs-number">1</span>])&gt;<span class="hljs-number">0</span>)&#123;<br>                swap(arr,j,j+<span class="hljs-number">1</span>);<br>                lastSwappedIndex = j+<span class="hljs-number">1</span>;  <span class="hljs-comment">//最后一次交换位置</span><br>            &#125;<br>        &#125;<br>        i = arr.length - lastSwappedIndex;   <span class="hljs-comment">// 还要交换的元素数量</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h1 id="四、插入排序"><a href="#四、插入排序" class="headerlink" title="四、插入排序"></a>四、插入排序</h1><h2 id="1-概念及其介绍-2"><a href="#1-概念及其介绍-2" class="headerlink" title="1. 概念及其介绍"></a>1. 概念及其介绍</h2><p>插入排序(InsertionSort)，一般也被称为直接插入排序。基本思想是每一次将一个元素 <strong>插入</strong> 到它前面的有序数组中</p>
<h2 id="2-适用说明"><a href="#2-适用说明" class="headerlink" title="2. 适用说明"></a>2. 适用说明</h2><table>
<thead>
<tr>
<th align="center">算法</th>
<th align="center">最好时间</th>
<th align="center">最坏时间</th>
<th align="center">平均时间</th>
<th align="center">额外空间</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入排序</td>
<td align="center">O(n）</td>
<td align="center">O(n^2)</td>
<td align="center">O(n^2)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<p><strong>优点</strong>就是数据有序的情况下，可以提前终止部分内层循环，只在有需要时才对数组进行排序</p>
<p><strong>缺点</strong>就是所有比插入元素大的元素都必须移动</p>
<p>最优的情况是当待排序数组是有序时，只需当前数跟前一个数比较一下就可以了，这时一共需要比较 <strong>N-1</strong> 次，时间复杂度为 <strong>O(N)<strong>。这具有非常重要的意义，因为</strong>日常有时候的数据就是近乎有序的</strong></p>
<p>最坏的情况是待排序数组是逆序的，此时需要比较次数最多，最坏的情况是 **O(n^2)**。</p>
<p>对于随机顺序的数组来说，移动和比较的次数与最坏情况接近，也就是说 当数组大小加倍时，一般都需要付出4倍的努力来排序。</p>
<h2 id="3-过程图示-2"><a href="#3-过程图示-2" class="headerlink" title="3. 过程图示"></a>3. 过程图示</h2><p>插入排序是每一次将一个元素 <strong>插入</strong> 到它前面的有序数组中。实际上有两种插入的方式：</p>
<ul>
<li><p>逐个交换：待插入元素逐个交换到前面</p>
  <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/DataStructure%20and%20Algorithm/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-%E5%9B%BE%E7%A4%BA.gif" srcset="/img/loading.gif" lazyload alt="img" style="zoom:150%;" />
</li>
<li><p>先暂存再后移：先暂存待插入元素，然后前面比暂存元素严格大的后移（放到优化一部分讲）</p>
  <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/DataStructure%20and%20Algorithm/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-%E5%9B%BE%E7%A4%BA1.gif" srcset="/img/loading.gif" lazyload alt="img" style="zoom:150%;" /></li>
</ul>
<h2 id="4-实例代码-2"><a href="#4-实例代码-2" class="headerlink" title="4. 实例代码"></a>4. 实例代码</h2><p>第0个数不动，从第1个数开始把 nums[i] 插入有序数组 nums[0..i - 1]</p>
<p>每次判定元素逆序成功就swap()，相当于插了多次。在动图中即表现为红色的临时值一直在插入，再取出来，再插入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InsertionSort</span> &#123;    <br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort2</span><span class="hljs-params">(E[] arr)</span>&#123;<br>        <span class="hljs-comment">// 把 nums[i] 插入有序数组 nums[0..i - 1]，从nums[1]开始，nums[0]不用动</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-comment">// 有索引j-1，j不能为0</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &gt; <span class="hljs-number">0</span> &amp;&amp; arr[j].compareTo(arr[j-<span class="hljs-number">1</span>])&lt;<span class="hljs-number">0</span>; j--)<br>                swap(arr,j,j-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>   <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(E[] arr,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="5-优化"><a href="#5-优化" class="headerlink" title="5. 优化"></a>5. 优化</h2><p>优化一：减少插入次数，先暂存待插入元素，然后前面比暂存元素严格大的后移</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/insertionSort%E7%A4%BA%E6%84%8F%E5%9B%BE.gif" srcset="/img/loading.gif" lazyload alt="insertionSort"></p>
<p>判定当前元素比前一个元素大，那就让前一个元素后移，不用让arr[j]与arr[j-1]一直交换，等到找到合适的插入位置，只插一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(E[] arr)</span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> arr[i];  <span class="hljs-comment">//复制一份外层循环当前轮次的元素</span><br>        <span class="hljs-type">int</span> j;         <span class="hljs-comment">//变量j保存元素e应该所在的位置，单独初始化是因为for循环后面还要用到</span><br>        <span class="hljs-comment">// 注意是当前轮次的值arr[i]即e与arr[j-1]比较，而不是arr[j]，当前轮次的arr[j]就是e，自然要跟前一个数字相比</span><br>        <span class="hljs-comment">// 这轮for循环的功能：1、找到当前轮次的元素应该放的位置 2、将大的元素后移</span><br>        <span class="hljs-keyword">for</span> (j = i; j&gt;<span class="hljs-number">0</span> &amp;&amp; e.compareTo(arr[j-<span class="hljs-number">1</span>])&lt;<span class="hljs-number">0</span>; j--)<br>            arr[j] = arr[j-<span class="hljs-number">1</span>]; <span class="hljs-comment">//比前一个元素大，那就让前一个元素后移，不用让arr[j]与arr[j-1]一直交换</span><br>        arr[j] = e;    <span class="hljs-comment">//此时j就是合适的位置，将当前轮次的e赋给它</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(E[] arr,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="二分查找法改进"><a href="#二分查找法改进" class="headerlink" title="二分查找法改进"></a>二分查找法改进</h3><p>查找插入的位置可以使用二分查找法，但仍然需要后移比插入元素大的元素，所以时间复杂度不变</p>
<p>不要求掌握</p>
<h2 id="6-插入排序的重要意义"><a href="#6-插入排序的重要意义" class="headerlink" title="6. 插入排序的重要意义"></a>6. 插入排序的重要意义</h2><p>插入排序有个特点非常重要：插入排序的内存循环有一定机会可以提前终止，这样就能让：<strong>数据接近有序的时候，插入排序可以很快完成。</strong>「接近有序」的意思是：每个元素和它排序以后最终所在的位置不远。这一点需要和「选择排序」进行比较。</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/DataStructure%20and%20Algorithm/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%AF%B9%E6%AF%94%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png" srcset="/img/loading.gif" lazyload alt="image-20220506230904374"></p>
<p>**在数组「几乎有序」的前提下，插入排序的时间复杂度可以达到 O(N)**，因此「插入排序」可以作为高级排序算法的一个子过程（后面在归并排序和快速排序算法里我们会看到）。</p>
<blockquote>
<p>这里注意冒泡排序在有序数组的情况下，也能做到时间复杂度为O(N)，如果有一轮循环没有交换，可以提前结束，但这种情况比较少出现，很可能只能减少最后几轮循环，优化效果不明显</p>
</blockquote>
<p>由于「插入排序」在「几乎有序」的数组上表现良好，特别地，在「短数组」上的表现也很好。因为「短数组」的特点是：每个元素离它最终排定的位置都不会太远。因此<strong>在小区间内执行排序任务的时候，可以转向使用「插入排序」。</strong></p>
<p>综合来看，一般同样一个排序任务，插入排序会比选择排序和冒泡排序时间花费的更少</p>
<h1 id="五、希尔排序"><a href="#五、希尔排序" class="headerlink" title="五、希尔排序"></a>五、希尔排序</h1><p>希尔排序的理论有一定难度，不感兴趣的朋友不需要深入研究；</p>
<p>希尔排序是插入排序的优化，利用的是插入排序的重要意义：在小数组（几乎有序的数组）上表现良好；通过<strong>分组插入排序</strong>使得数组变得逐步有序；最后一轮执行标准的插入排序</p>
<h2 id="1-希尔排序的基本思想"><a href="#1-希尔排序的基本思想" class="headerlink" title="1. 希尔排序的基本思想"></a>1. 希尔排序的基本思想</h2><p>希尔排序的基本思想：开始的时候逐渐让数组变得基本有序，最后使用一次使用「插入排序」就变得高效了。</p>
<ul>
<li>「逐渐让数组变得基本有序」的方法是让移动的「步幅」增大，不是一步一步挪过去，而是「大步流星」、「连蹦带跳」走过去；</li>
<li>「逐渐缩小增量」「分组实施插入排序让数组变得逐渐接近有序」「最后执行一次标准的插入排序」（ 最后一轮就是「原汁原味」的插入排序。</li>
</ul>
<p>「希尔排序」的实现比较多，我们这里只选取希尔排序的一种比较容易理解的实现。「希尔排序」也可以理解为「分组插入排序」。</p>
<p>希尔是计算机科学家的名字，所以希尔排序就得换一个名字来记。</p>
<p>希尔排序是 「<strong>分组插入排序</strong>」 或者 「<strong>带间隔的插入排序</strong>」。好处是：<strong>让较小的元素一下子来到数组的前面</strong>。</p>
<p>每一轮完成一次分组插入排序以后，数组就朝着接近有序的方向前进了一步。最后一轮一定是一次标准的插入排序</p>
<h2 id="2-图示希尔排序"><a href="#2-图示希尔排序" class="headerlink" title="2. 图示希尔排序"></a>2. 图示希尔排序</h2><p>之前的图挂了，如果有机会用到再搜吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortArray(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">detal</span> <span class="hljs-operator">=</span> len / <span class="hljs-number">2</span>; detal &gt; <span class="hljs-number">0</span>; detal /= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-comment">// 以detal为间隔，就有detal组</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; start &lt; detal; start++) &#123;<br>                insertionSortForDetal(nums, len, detal, start);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertionSortForDetal</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> detal, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-comment">// start为第几组的首元素，detal是步长</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start + detal; i &lt; len; i += detal) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">for</span> (; j - detal &gt;= <span class="hljs-number">0</span>; j -= detal) &#123;<br>                <span class="hljs-keyword">if</span> (nums[j - detal] &gt; temp) &#123;<br>                    nums[j] = nums[j - detal];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 此时 nums[j - 1] &lt;= temp</span><br>            <span class="hljs-comment">// nums[j] 的值被赋值到了 nums[j + 1]</span><br>            nums[j] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="3-希尔排序的时间复杂度"><a href="#3-希尔排序的时间复杂度" class="headerlink" title="3. 希尔排序的时间复杂度"></a>3. 希尔排序的时间复杂度</h2><p>希尔排序的时间复杂度与选择的步长序列有关，最初的步长选择是2的次幂，时间复杂度是O(N^2)，后续算法改进过程中，步长选择的好能够有效提升时间复杂度，目前最好的效果在小数组中甚至比快排还快。</p>
<p><strong>总体来说，希尔排序比插入、冒泡、选择等基础排序算法要快，在小数组中甚至比快排还快，但是在大数组中，还是没有O(NlogN)级别的算法快。</strong></p>
<p>以前的空间是昂贵的，所以尽管归并提出的比希尔早，但人们还是在不断优化希尔排序，归并和快排等利用递归实现的排序算法，本质上是以空间换时间的思想。至于具体谁好谁坏，在算法的时间里，得看情况分析。</p>
<h1 id="六、归并排序"><a href="#六、归并排序" class="headerlink" title="六、归并排序"></a>六、归并排序</h1><h2 id="1-概念及其介绍-3"><a href="#1-概念及其介绍-3" class="headerlink" title="1. 概念及其介绍"></a>1. 概念及其介绍</h2><p>归并排序（Merge sort）是建立在归并操作上的一种有效、稳定的排序算法，该算法是采用分治法(Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>
<p>作为一种典型的分而治之思想的算法应用，归并排序的实现有下面这些方法：</p>
<ul>
<li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li>
<li>自下而上的迭代；</li>
<li>原地归并排序；</li>
</ul>
<p>主要学习第一种，用递归理解分治的思想，这是最好理解、最通用的归并。后面二三种学有余力可以学习</p>
<p>算法步骤：</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<h2 id="2-算法性能-2"><a href="#2-算法性能-2" class="headerlink" title="2. 算法性能"></a>2. 算法性能</h2><table>
<thead>
<tr>
<th align="center">算法</th>
<th align="center">最好时间</th>
<th align="center">最坏时间</th>
<th align="center">平均时间</th>
<th align="center">额外空间</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">归并排序</td>
<td align="center">O(n）</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(n)</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<p>归并排序的性能不受输入数据的影响，始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p>
<p>归并排序适用于数据量大，并且对稳定性有要求的场景</p>
<h2 id="3-过程图示-3"><a href="#3-过程图示-3" class="headerlink" title="3. 过程图示"></a>3. 过程图示</h2><p>归并过程：不断比较temp[i]和temp[j]的大小，找到合适的位置放到原数组中</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="image-20220213153723211"></p>
<p>动图演示：</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/mergeSort%E7%A4%BA%E6%84%8F%E5%9B%BE.gif" srcset="/img/loading.gif" lazyload alt="mergeSort"></p>
<h2 id="4-实例代码-3"><a href="#4-实例代码-3" class="headerlink" title="4. 实例代码"></a>4. 实例代码</h2><p>利用递归进行自顶向下的归并排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MergeSort</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MergeSort</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(E[] arr)</span>&#123;<br>        sort(arr,<span class="hljs-number">0</span>,arr.length-<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 递归使用归并排序，对arr[l...r]的范围进行排序，l是第一个元素的位置，r是最后一个元素的位置，两边都是闭区间</span><br>    <span class="hljs-comment">// 所以这种情况下，在递归调用长度为n的数组时，l就是数组的下标位置0，r就是数组的下标位置n-1</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(E[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>&#123;<br>        <span class="hljs-keyword">if</span> (l&gt;=r) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 只有1个元素或者没有元素</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l+(r-l)/<span class="hljs-number">2</span>; <span class="hljs-comment">// 防止整型计算溢出，亿级数据量才用到</span><br>        sort(arr,l,mid);<br>        sort(arr,mid+<span class="hljs-number">1</span>,r);<br>        merge(arr,l,mid,r);<br>    &#125;<br><br>    <span class="hljs-comment">// 合并两个有序的区间，arr[l,mid] 和arr[mid+1,r]</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(E[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> r)</span>&#123;<br>        <span class="hljs-comment">// copyOfRange方法是不包括右端点的，所以要r+1。</span><br>        <span class="hljs-comment">// 即写copyOfRange(arr,0,5)它是不复制arr[5]这个数的，要写成copyOfRange(arr,0,6)</span><br>        <span class="hljs-comment">// 这里注意arr是从l开始索引的，但temp是从0开始索引的，所以相比于arr，temp有一个l的偏移量</span><br>        E[] temp = Arrays.copyOfRange(arr,l,r+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//定义两个指针分别指向左右半区的首位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l, j = mid+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> l; k &lt;= r; k++) &#123;<br>            <span class="hljs-comment">//先判断越界问题：</span><br>            <span class="hljs-comment">//如果左边的指针已经大于mid，说明左半区已经都排序完，把右半区剩下的数字放入arr，temp数组偏移量为l。</span><br>            <span class="hljs-keyword">if</span> (i&gt;mid)&#123;<br>                arr[k] = temp[j-l]; j++;<br>            &#125;<br>            <span class="hljs-comment">//如果右边的指针已经大于r，说明右半区已经都排序完，把左半区剩下的数字放入arr，temp数组偏移量为l。</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j&gt;r)&#123;<br>                arr[k] = temp[i-l]; i++;<br>            &#125;<br>            <span class="hljs-comment">// 再判断两个半区的大小：</span><br>            <span class="hljs-comment">// 注意是temp[i-l]和temp[j-l]比较，容易忘记偏移量l</span><br>            <span class="hljs-comment">// 记住这里是小于等于，在有些问题中等号很重要，比如剑指51：逆序对</span><br>            <span class="hljs-comment">// 并且写成 &lt; 就丢失了稳定性（相同元素原来靠前的排序以后依然靠前）</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp[i-l].compareTo(temp[j-l])&lt;=<span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// 左半部分所指元素 &lt;= 右半部分所指元素</span><br>                arr[k] = temp[i-l]; i++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// 左半部分所指元素 &gt; 右半部分所指元素</span><br>                arr[k] = temp[j-l]; j++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="5-优化-1"><a href="#5-优化-1" class="headerlink" title="5. 优化"></a>5. 优化</h2><h3 id="优化一：对于小规模数组-使用插入排序，避免递归到底"><a href="#优化一：对于小规模数组-使用插入排序，避免递归到底" class="headerlink" title="优化一：对于小规模数组, 使用插入排序，避免递归到底"></a>优化一：对于小规模数组, 使用插入排序，避免递归到底</h3><p>数组元素较少且是有序的情况，插入排序复杂度可能到O(n)级别</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MergeSort</span> &#123;    <br>	<span class="hljs-keyword">public</span> <span class="hljs-type">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(E[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>        <span class="hljs-comment">//if (l&gt;=r) return; // 只有1个元素或者没有元素</span><br>        <br>        <span class="hljs-comment">// 优化1: 对于小规模数组, 使用插入排序，避免递归到底</span><br>        <span class="hljs-keyword">if</span> (r-l&lt;=<span class="hljs-number">15</span>)&#123;<br>            InsertionSort.<span class="hljs-built_in">sort</span>(arr, l, r);  <span class="hljs-comment">//需要将之前[0,n]数组的插入排序改写为[l,r]的</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>            <br>        <span class="hljs-type">int</span> mid = l+(r-l)/<span class="hljs-number">2</span>; <span class="hljs-comment">// 防止整型计算溢出，亿级数据量才用到</span><br>        <span class="hljs-built_in">sort</span>(arr,l,mid);<br>        <span class="hljs-built_in">sort</span>(arr,mid+<span class="hljs-number">1</span>,r);<br>        <span class="hljs-built_in">merge</span>(arr,l,mid,r);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="优化二：对于左半区和右半区整体大小已经确定的情况可以不用再进行递归"><a href="#优化二：对于左半区和右半区整体大小已经确定的情况可以不用再进行递归" class="headerlink" title="优化二：对于左半区和右半区整体大小已经确定的情况可以不用再进行递归"></a>优化二：对于左半区和右半区整体大小已经确定的情况可以不用再进行递归</h3><p>对于arr[mid] &lt;&#x3D; arr[mid+1]的情况,不进行merge ，因为归并过程保证了l<del>mid是有序的，mid+1</del>r也是有序的，arr[mid] &lt;&#x3D; arr[mid+1]，则不用排序，这对于近乎有序的数组非常有效，会变成O(n)级别的算法。但是对于一般情况，有一定的性能损失</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MergeSort</span> &#123;    <br>	<span class="hljs-keyword">public</span> <span class="hljs-type">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(E[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>        <span class="hljs-comment">//if (l&gt;=r) return; // 只有1个元素或者没有元素</span><br>        <br>        <span class="hljs-comment">// 优化1: 对于小规模数组, 使用插入排序，避免递归到底</span><br>        <span class="hljs-keyword">if</span> (r-l&lt;=<span class="hljs-number">15</span>)&#123;<br>            InsertionSort.<span class="hljs-built_in">sort</span>(arr, l, r);  <span class="hljs-comment">//需要将之前[0,n]数组的插入排序改写为[l,r]的</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>            <br>        <span class="hljs-type">int</span> mid = l+(r-l)/<span class="hljs-number">2</span>; <span class="hljs-comment">// 防止整型计算溢出，亿级数据量才用到</span><br>        <span class="hljs-built_in">sort</span>(arr,l,mid);<br>        <span class="hljs-built_in">sort</span>(arr,mid+<span class="hljs-number">1</span>,r);<br><br>        <span class="hljs-comment">// 优化2: 对于arr[mid] &lt;= arr[mid+1]的情况，这种情况左半区恒小于右半区，不需要进行merge</span><br>        <span class="hljs-comment">// 对于近乎有序的数组非常有效,但是对于一般情况,有一定的性能损失</span><br>        <span class="hljs-keyword">if</span> (arr[mid].<span class="hljs-built_in">compareTo</span>(arr[mid+<span class="hljs-number">1</span>])&gt;<span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">merge</span>(arr,l,mid,r);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="优化三：一开始开辟数组内存，而不是在每次merge操作中开辟"><a href="#优化三：一开始开辟数组内存，而不是在每次merge操作中开辟" class="headerlink" title="优化三：一开始开辟数组内存，而不是在每次merge操作中开辟"></a>优化三：一开始开辟数组内存，而不是在每次merge操作中开辟</h3><p>上面的代码中我们可以观察到合并操作merge()方法每次都开辟了一个数组用于复制，然后不用了再释放掉内存，然而merge的次数是比较多的，这无疑是一种浪费。因此可以在一开始sort时就开辟一个全局数组，每次递归时将这个数组传下去，用于复制数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MergeSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort2</span><span class="hljs-params">(E[] arr)</span>&#123;<br>        <span class="hljs-comment">//在一开始开辟数组空间，而不是在每次的merge中开辟空间。递归时将数组传下去，在合并过程中也可以不用考虑偏移量</span><br>        E[] temp = Arrays.copyOf(arr,arr.length);<br>        sort2(arr,<span class="hljs-number">0</span>,arr.length-<span class="hljs-number">1</span>, temp);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort2</span><span class="hljs-params">(E[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, E[] temp)</span>&#123;<br>        <span class="hljs-keyword">if</span> (r-l&lt;=<span class="hljs-number">15</span>)&#123;<br>            InsertionSort.sort(arr, l, r);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l+(r-l)/<span class="hljs-number">2</span>;<br>        sort2(arr,l,mid,temp);<br>        sort2(arr,mid+<span class="hljs-number">1</span>,r,temp);<br><br>        <span class="hljs-keyword">if</span> (arr[mid].compareTo(arr[mid+<span class="hljs-number">1</span>])&gt;<span class="hljs-number">0</span>)<br>            merge2(arr,l,mid,r,temp);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge2</span><span class="hljs-params">(E[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> r, E[] temp)</span>&#123;<br>        <span class="hljs-comment">// 将arr中l开始的元素依次复制到temp中l开始的位置上，复制的长度为r-l+1，这样下面就没有l的偏移量了</span><br>        System.arraycopy(arr,l,temp,l,r-l+<span class="hljs-number">1</span>);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l, j = mid+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> l; k &lt;= r; k++) &#123;<br>            <span class="hljs-comment">//先判断越界问题：</span><br>            <span class="hljs-keyword">if</span> (i&gt;mid)&#123;<br>                arr[k] = temp[j]; j++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j&gt;r)&#123;<br>                arr[k] = temp[i]; i++;<br>            &#125;<br>            <span class="hljs-comment">// 再判断两个半区的大小：</span><br>            <span class="hljs-comment">// 注意写成 &lt; 就丢失了稳定性（相同元素原来靠前的排序以后依然靠前）</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp[i].compareTo(temp[j])&lt;=<span class="hljs-number">0</span>)&#123;  <br>                arr[k] = temp[i]; i++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                arr[k] = temp[j]; j++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h1 id="七、快速排序"><a href="#七、快速排序" class="headerlink" title="七、快速排序"></a>七、快速排序</h1><h2 id="1-概念及其介绍-4"><a href="#1-概念及其介绍-4" class="headerlink" title="1. 概念及其介绍"></a>1. 概念及其介绍</h2><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p>
<p> 归并排序</p>
<ul>
<li>拆分：不管数组的形态，总是将数组一分为二；</li>
<li>组合：合并两个有序的数组。</li>
</ul>
<p>快速排序</p>
<ul>
<li>拆分：根据某个元素 <code>pivot</code>，将数组整理成两个部分；<ul>
<li>前半部分小于 <code>pivot</code>， 后半部分大于等于 <code>pivot</code>；</li>
<li>把 <code>pivot</code> 交换到前半部分的最后一个元素。</li>
</ul>
</li>
<li>组合：什么都不用做。</li>
</ul>
<p>算法步骤：</p>
<ol>
<li>从数列中挑出一个元素，称为 “基准”（pivot）;</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li>
</ol>
<h2 id="2-算法性能-3"><a href="#2-算法性能-3" class="headerlink" title="2. 算法性能"></a>2. 算法性能</h2><table>
<thead>
<tr>
<th align="center">算法</th>
<th align="center">最好时间</th>
<th align="center">最坏时间</th>
<th align="center">平均时间</th>
<th align="center">额外空间</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">快速排序</td>
<td align="center">O(n）</td>
<td align="center">O(n^2)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(logn)</td>
<td align="center">不稳定</td>
</tr>
</tbody></table>
<p><strong>快排的不稳定分析：</strong></p>
<p>假设待排序数组: <code>a = [ 1, 2, 2, 3, 4, 5, 6 ];</code></p>
<p>在快速排序的随机选择比较子(即pivot)阶段：</p>
<p>若选择a[2]（即数组中的第二个2）为比较子，而把大于等于比较子的数均放置在大数数组中，则a[1]（即数组中的第一个2）会到pivot的右边， 那么数组中的两个2非原序（这就是“不稳定”）。</p>
<p>若选择 a[1] （即数组中的第一个2）为比较子，而把小于等于比较子的数均放置在小数数组中，则数组中的两个 2 顺序也非原序 。</p>
<p>这就说明，quick sort是不稳定的。</p>
<p><strong>快排的总结与复杂度分析：</strong></p>
<p>在学完随机化快排、双路快排和三路快排后，对快排的改进思路及其复杂度应该有一定的分析。</p>
<p>最初始的快排版本助记如下图，将小于和大于部分都放在左边，使用双指针i和j，i放在for循环中，不单独体现</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E5%BF%AB%E6%8E%92%E6%9C%80%E5%88%9D%E7%89%88%E6%9C%AC%E5%8A%A9%E8%AE%B0%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="image-20220215231243252"></p>
<p>最初始的版本，没有随机化基准值，存在“能找到一组数据，让算法100%恶化”，即对于近乎有序的数组，其时间复杂度变为O(n^2) ，这里的O(n^2) 显然是最坏的情况，因为对于“能找到一组数据，让算法100%恶化”，就应该去看它的最坏情况，因为这样的数据很容易能找到，即<strong>近乎有序的数组</strong>，而一旦用到这些数据，算法的复杂度我们是不能忍受的。</p>
<p>后面使用了随机化快排，这个随机化快排从某种角度上说是一种随机算法，因为其每次选定的基准值是不同的，那么分析复杂度时，是应该用最坏情况，还是期望情况。答案仍然是看最坏情况，因为仍然存在“能找到一组数据，让算法100%恶化”，即对于<strong>大量重复数据的数组</strong>，随机化快排退化成了O(n^2)。这样的数据依然很好找。</p>
<p>为了解决这个问题使用了双路快排，把&#x3D;v的元素放在数组的两端，解决分布不平衡问题，使用双指针 i 和 j ，相向推进直至 i &gt;&#x3D; j</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E5%8F%8C%E8%B7%AF%E5%BF%AB%E6%8E%92%E5%8A%A9%E8%AE%B0%E5%9B%BE2.png" srcset="/img/loading.gif" lazyload alt="image-20220215232733122"></p>
<p>这时计算复杂度是应该用最坏情况，还是期望情况。答案是应该用期望情况，因为“没有一组数组，能让算法100%恶化”，理论上来讲可能会存在这样数组，但概率非常非常低，因此考虑最坏情况是没有意义的，所以此时复杂度为O(nlogn)，为期望复杂度。</p>
<p>三路快速排序是双路快速排序的进一步改进版本，对处理<strong>大量重复元素</strong>的数组非常有效，等于 v 的数据在下次递归中不再需要排序。用三个指针辅助标记。时间复杂度分析同双路快排，如果都是重复元素，时间复杂度为O(n)级别</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E4%B8%89%E8%B7%AF%E5%BF%AB%E6%8E%92%E5%8A%A9%E8%AE%B0%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="image-20220215232900381"></p>
<p>综上所述，考虑复杂度是最坏情况还是期望情况，因该去想考虑最坏情况有没有意义，如果有数据让最坏情况很容易出现，那么就必须用最坏情况计算，否则最坏情况就没意义，而使用期望情况</p>
<h2 id="3-过程图示-4"><a href="#3-过程图示-4" class="headerlink" title="3. 过程图示"></a>3. 过程图示</h2><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/QuickSort.png" srcset="/img/loading.gif" lazyload alt="QuickSort"></p>
<h2 id="4-实例代码-4"><a href="#4-实例代码-4" class="headerlink" title="4. 实例代码"></a>4. 实例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 对arr[l...r]部分进行partition操作</span><br><span class="hljs-comment">// 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSort</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(E[] arr)</span>&#123;<br>        sort(arr,<span class="hljs-number">0</span>,arr.length-<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(E[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>            <span class="hljs-keyword">if</span> (l&gt;=r) <span class="hljs-keyword">return</span>;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> partition(arr,l,r);  <span class="hljs-comment">// 返回索引值</span><br>            sort(arr,l,p-<span class="hljs-number">1</span>);  <span class="hljs-comment">// 注意分界点</span><br>            sort(arr,p+<span class="hljs-number">1</span>,r);<br>    &#125;<br><br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;&gt; <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(E[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span>  r)</span>&#123;<br>        <span class="hljs-comment">// 指定最左端元素为基准值</span><br>        <span class="hljs-type">int</span> j=l;<br>        <span class="hljs-comment">// i指向当前索引元素，j指向小于arr[l]区域的最后一个元素，脑子里要有图</span><br>        <span class="hljs-comment">// 从l的下一个开始for循环，arr[i] &gt; arr[l] 时，让 i++ 就可以了，相当于不用管</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l+<span class="hljs-number">1</span>; i &lt;= r; i++) &#123;<br>            <span class="hljs-comment">// 如果当前元素小于基准值，应该交换arr[i]和arr[j+1]，随后j++，这样arr[i]就放到了&lt;v的部分</span><br>            <span class="hljs-keyword">if</span> (arr[i].compareTo(arr[l])&lt;<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">//先让j+1，指向小于arr[l]的区域后面一个元素，再交换</span><br><span class="hljs-comment">//                swap(arr,i,j+1);</span><br><span class="hljs-comment">//                j++;</span><br><br>                <span class="hljs-comment">//或者先+1，再交换</span><br><span class="hljs-comment">//                j++;</span><br><span class="hljs-comment">//                swap(arr,i,j);</span><br><br>                <span class="hljs-comment">// 以上两种都可以合写为:</span><br>                 swap(arr,i,++j);<br>            &#125;<br>        &#125;<br>        swap(arr,l,j);<br>        <span class="hljs-keyword">return</span> j;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(E[] arr,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="5-优化-2"><a href="#5-优化-2" class="headerlink" title="5. 优化"></a>5. 优化</h2><h3 id="优化一：避免递归到底"><a href="#优化一：避免递归到底" class="headerlink" title="优化一：避免递归到底"></a>优化一：避免递归到底</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(E[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-comment">// if (l&gt;=r) return;</span><br>    <span class="hljs-comment">// 优化一：避免递归到底</span><br>    <span class="hljs-keyword">if</span> (r - l &lt;= <span class="hljs-number">15</span>)&#123;<br>        InsertionSort.sort(arr,l,r);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> partition(arr,l,r);  <span class="hljs-comment">// 返回索引值</span><br>    sort(arr,l,p-<span class="hljs-number">1</span>);  <span class="hljs-comment">// 注意分界点</span><br>    sort(arr,p+<span class="hljs-number">1</span>,r);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="优化二：随机化快排–解决近乎有序的数组"><a href="#优化二：随机化快排–解决近乎有序的数组" class="headerlink" title="优化二：随机化快排–解决近乎有序的数组"></a>优化二：随机化快排–解决近乎有序的数组</h3><p>在<strong>近乎有序的数组</strong>中，初始的快排非常慢，因为前面partition操作的基数选择了最左侧的数，其在近乎有序的数组中递归时分界点大概率都是最左侧，递归树的高度就成了n（上一节的归并排序递归深度为logn），导致其变成近乎O(n^2)的复杂度。优化方法为使用<strong>随机化快排</strong>，即随机挑选基准值</p>
<p>虽然最坏情况的时间复杂度仍然为O(n^2)，但是这种概率非常小（因为每次都能随机到最小的数字的概率很小），随机化快排的期望时间复杂度则是O(nlogn)</p>
<p>优化后虽然还是没有归并快（归并使用了优化，近乎有序的数组不用归并过程），但在可以接受的范围内。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;&gt; <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(E[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span>  r)</span>&#123;<br>    <span class="hljs-comment">// 优化二：随机指定基准值</span><br>    <span class="hljs-comment">// nextInt函数是[0，n)随机值，所以这里应该传入r-l+1。其实传入r-l也不太影响结果，但r-l+1更符合随机抽取数组值的逻辑。</span><br>    <span class="hljs-comment">// 这里还有个随机操作上的小优化，即不让每次partition都创建一个Random对象，而是在最上面的sort函数中创建，然后通过函数参数依次传进partition中。限于篇幅此处略过。</span><br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> l + (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>()).nextInt(r-l+<span class="hljs-number">1</span>);<br>    swap(arr,l,p);<br><br>    <span class="hljs-type">int</span> j=l;<br>    <span class="hljs-comment">// i指向当前索引元素，j指向小于arr[l]区域的最后一个元素，脑子里要有图</span><br>    <span class="hljs-comment">// 从l的下一个开始for循环，arr[i] &gt; arr[l] 时，让 i++ 就可以了，相当于不用管</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l+<span class="hljs-number">1</span>; i &lt;= r; i++) &#123;<br>        <span class="hljs-comment">// 如果当前元素小于基准值，应该交换arr[i]和arr[j+1]，随后j++，这样arr[i]就放到了&lt;v的部分</span><br>        <span class="hljs-keyword">if</span> (arr[i].compareTo(arr[l])&lt;<span class="hljs-number">0</span>)&#123;<br>            swap(arr,i,j+<span class="hljs-number">1</span>);<br>            j++;<br>        &#125;<br>    &#125;<br>    swap(arr,l,j);<br>    <span class="hljs-keyword">return</span> j;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="优化三：双路快排–解决大量重复元素的数组"><a href="#优化三：双路快排–解决大量重复元素的数组" class="headerlink" title="优化三：双路快排–解决大量重复元素的数组"></a>优化三：双路快排–解决大量重复元素的数组</h3><p>当测试数组包含<strong>大量相同元素</strong>，快速排序算法再次退化成了O(n^2) 级别的算法，因为&#x3D;v的数据太多，不管是放在&gt;v的区域还是&lt;v的区域，都会造成数组分布极度不平衡，递归树长度变为n，所以时间复杂度退化成了O(n^2)，解决的方法是使用<strong>双路快排</strong></p>
<p>即将**&lt;v<strong>和**&gt;v</strong>由之前的放在数组的左端，改为放到数组的两端，需要使用两个索引值（i、j）用来遍历我们的序列，将 <strong>&lt;&#x3D;v** 的元素放在索引 i 所指向位置的左边，而将 **&gt;&#x3D;v</strong> 的元素放在索引 j 所指向位置的右边，平衡左右两边子数组（说白了就是把&#x3D;v的元素分散开来放）</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/QuickSort2Ways.png" srcset="/img/loading.gif" lazyload alt="QuickSort2Ways"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;&gt; <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(E[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span>  r)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> l + (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>()).nextInt(r-l+<span class="hljs-number">1</span>);<br>    swap(arr,l,p);<br><br>    <span class="hljs-comment">// 优化三：双路快速排序</span><br>    <span class="hljs-comment">// 使得arr[l+1...i) &lt;= v; arr(j...r] &gt;= v，把等于基准值的数尽量均匀分布在两个部分，不会造成不平衡的情况</span><br>    <span class="hljs-comment">// 定义两个索引分别指向：&lt;v区域的下一位 和 &gt;v区域的前一位</span><br>  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span>l+<span class="hljs-number">1</span>, j=r;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-comment">// 下面两个while判定中arr[i]不能包含 = arr[l]，因为其中任意一个判定=成功，都会把大量相同数据放置到一个半区，仍然会造成不平衡的问题</span><br>        <span class="hljs-comment">// 即只要不碰到&gt;=arr[l],i就+1，不碰到&lt;=arr[l]，j就-1</span><br>        <span class="hljs-comment">// 当i指向这个&gt;=arr[l]的数，j指向这个&lt;=arr[l]的数，然后交换他们，如果是与arr[l]相等的数交换到了另一边，这样才能尽量均匀分布在两侧</span><br>        <span class="hljs-keyword">while</span> (i&lt;=j &amp;&amp; arr[i].compareTo(arr[l])&lt;<span class="hljs-number">0</span>) i++;<br>        <span class="hljs-keyword">while</span> (i&lt;=j &amp;&amp; arr[j].compareTo(arr[l])&gt;<span class="hljs-number">0</span>) j--;<br>        <span class="hljs-comment">// 如果i&gt;=j，则是越界，停止循环</span><br>        <span class="hljs-keyword">if</span> (i&gt;=j) <span class="hljs-keyword">break</span>;<br>        swap(arr,i,j);<br>        <span class="hljs-comment">// 交换完还是要继续移动双指针</span><br>        i++;<br>        j--;<br>    &#125;<br>    <span class="hljs-comment">// 务必注意！遍历结束后，i指向从前往后看第一个&gt;=arr[l]的位置，j指向从后往前看，最后一个&lt;=arr[l]的位置，</span><br>    <span class="hljs-comment">// 现在标定点是在&lt;=arr[l]这一端，所以交换arr[l]和arr[j]，它们都是&lt;=v区域的值，而不是交换l和i，否则会排序失败</span><br>    swap(arr,l,j);<br>    <span class="hljs-keyword">return</span> j;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="优化四：三路快排–进一步解决大量重复元素的数组"><a href="#优化四：三路快排–进一步解决大量重复元素的数组" class="headerlink" title="优化四：三路快排–进一步解决大量重复元素的数组"></a>优化四：三路快排–进一步解决大量重复元素的数组</h3><p>三路快速排序是双路快速排序的进一步改进版本，对处理<strong>大量重复元素</strong>的数组非常有效。三路排序算法把排序的数据分为三部分，分别为小于 v，等于 v，大于 v，v 为标定值，这样三部分的数据中，<strong>等于 v <strong>的数据在下次递归中</strong>不再需要排序</strong>，小于 v 和大于 v 的数据也不会出现某一个特别多的情况，通过此方式三路快速排序算法的性能更优。</p>
<p>对于包含有大量重复数据的数组, 三路快排有巨大的优势,对于一般性的随机数组和近乎有序的数组, 三路快排的效率虽然不是最优的, 但是是在非常可以接受的范围里。因此, 在一些语言中, 三路快排是默认的语言库函数中使用的排序算法。比如Java</p>
<p>为了方便记忆，记住下图最上面的横条结构。</p>
<p>lt指向&lt;v的最后一个值（初始 lt&#x3D;l ），i指向当前值（初始 i &#x3D; l +1 ），gt指向&gt;v的第一个值 (初始 gt &#x3D; r +1)</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/QuickSort3Ways.png" srcset="/img/loading.gif" lazyload alt="QuickSort3Ways"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(E[] arr)</span>&#123;<br>    sort(arr,<span class="hljs-number">0</span>,arr.length-<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(E[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-keyword">if</span> (r - l &lt;= <span class="hljs-number">15</span>)&#123;<br>        InsertionSort.sort(arr,l,r);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 随机化基准值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> l + (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>()).nextInt(r-l+<span class="hljs-number">1</span>);<br>    swap(arr,l,p);<br><br>    <span class="hljs-comment">// 希望将数组分成三部分：arr[l+1,lt]&lt;v,arr[lt+1,i-1]=v,arr[gt,r]&gt;v,脑子里要有图，或者拿纸笔写</span><br>    <span class="hljs-comment">// 确定初始值要让每个区间最开始都为空区间，所以lt为l,gt为r+1。lt(less than),gt(greater than)</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">lt</span> <span class="hljs-operator">=</span> l, i = l+<span class="hljs-number">1</span>, gt = r+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; gt)&#123;<br>        <span class="hljs-keyword">if</span> (arr[i].compareTo(arr[l])&lt;<span class="hljs-number">0</span>)&#123;<br>            swap(arr,i,lt+<span class="hljs-number">1</span>);<br>            lt++;<br>            <span class="hljs-comment">// 上面两句可以合并为swap(arr,i,++lt);</span><br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i].compareTo(arr[l])&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 注意此时不用i++，因为gt先-1，换过来的值也是未处理过的</span><br>            swap(arr,i,gt-<span class="hljs-number">1</span>);<br>            gt--;<br>            <span class="hljs-comment">// 上面两句可以合并为swap(arr,i,--gt);</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// arr[i] = arr[l]</span><br>            i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 因为目前lt位置是小于arr[l]的，所以交换之后，最左边还是小于arr[l]，arr[lt]=arr[l]</span><br>    swap(arr,l,lt);<br><br>    <span class="hljs-comment">// 交换完之后，arr[l,lt-1]&lt;v,arr[lt,gt-1]=v,arr[gt,r]&gt;v，再递归</span><br>    sort(arr,l,lt-<span class="hljs-number">1</span>);<br>    sort(arr,gt,r);<br>&#125;<br></code></pre></td></tr></table></figure>





<h1 id="八、堆排序"><a href="#八、堆排序" class="headerlink" title="八、堆排序"></a>八、堆排序</h1><h2 id="1-概念及其介绍-5"><a href="#1-概念及其介绍-5" class="headerlink" title="1. 概念及其介绍"></a>1. 概念及其介绍</h2><p>二叉堆是一个完全二叉树，并且堆中某个节点的值总是不大于其父节点的值，这是最大堆（相应的也可以定义最小堆）</p>
<p>例如下图就是一个最大堆，每个节点总是小于等于其父节点值。这样堆中的最大值显然就是其根节点</p>
<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97.png" srcset="/img/loading.gif" lazyload alt="image-20220322161718734" style="zoom: 50%;" />

<p>如果用数组存储最大堆，可以得出以下关系 ，不过此时数组第0位是空的</p>
<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E6%9C%80%E5%A4%A7%E5%A0%86.png" srcset="/img/loading.gif" lazyload alt="image-20220322162016360" style="zoom: 50%;" />

<p>如果从第0位开始记录，左右子节点和父节点的公式要做出相应修改</p>
<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E6%9C%80%E5%A4%A7%E5%A0%861.png" srcset="/img/loading.gif" lazyload alt="image-20220322162236689" style="zoom: 50%;" />

<p>每次添加新元素时，一开始放到数组最后，即树中的右下节点，此时需要一个向上浮动的过程，将其按照最大堆的原则放置到合适的位置。这个动作称之为<code>siftUp</code></p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E5%A0%86-%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%85%83%E7%B4%A0.gif" srcset="/img/loading.gif" lazyload alt="6239d10f78a8e"></p>
<p>每次取最大元素只需要把根节点取出，随后将最后一个元素放到根节点处，再将该元素不断与子节点比较，直至放置到合适的位置，这个动作称之为<code>siftDown</code></p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E5%A0%86-%E5%8F%96%E5%87%BA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0.gif" srcset="/img/loading.gif" lazyload alt="6239d512d647f"></p>
<p>根据二叉堆的性质以及添加元素、取出最大元素，我们不难根据其进行堆排序，将数组data中的元素一个个放到二叉堆中，随后每次再取出最大元素，即可进行堆排序。</p>
<p>repalce操作：取出堆中的最大元素，并且替换成元素e。</p>
<p>方法：把e放在根节点，而不是像之前siftDown将最后一个元素放在根节点，再将e下沉到合适的位置即可</p>
<p>Heapify操作：将任意数组整理成二叉堆的形状</p>
<p>方法：一种是将数组一个个的添加到二叉堆中，时间复杂度为O(nlogn)</p>
<p>另一种是先将数组按照初始顺序看成一棵二叉树，再从下往上，将一个个<strong>非叶子节点</strong>下沉，因为叶子节点并不用下沉，非叶子节点不断下沉的时候，会将叶子节点放到合适的位置。一棵完全二叉树的叶子节点为n&#x2F;2，所以这种方法可以省去一定时间，此方法的时间复杂度为O(n)。推导需要严谨的数学公式，暂时不做要求。</p>
<p>如何找到第一个非叶子节点？是最后一个叶子节点的父亲节点</p>
<h2 id="2-算法性能-4"><a href="#2-算法性能-4" class="headerlink" title="2. 算法性能"></a>2. 算法性能</h2><table>
<thead>
<tr>
<th align="center">算法</th>
<th align="center">最好时间</th>
<th align="center">最坏时间</th>
<th align="center">平均时间</th>
<th align="center">额外空间</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">堆排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
</tbody></table>
<h2 id="3-过程图示-5"><a href="#3-过程图示-5" class="headerlink" title="3. 过程图示"></a>3. 过程图示</h2><p>对于一个无序数组，先把这个数组进行Heapify操作，即将其整理成最大堆，怎么整理呢，从最后一个非叶子节点向上，一个个下沉。</p>
<p>整理完之后，原地进行堆排序，不断地将数组第一个数，即最大值，交换到数组最后一位，然后对剩下的数组再进行整理，将交换过去的数下沉，找到它合适的位置。</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F-%E5%A0%86%E6%8E%92%E5%BA%8F.gif" srcset="/img/loading.gif" lazyload alt="20200202011542498"></p>
<h2 id="4-实例代码-5"><a href="#4-实例代码-5" class="headerlink" title="4. 实例代码"></a>4. 实例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapSort</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">HeapSort</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(E[] data)</span> &#123;<br>        <span class="hljs-comment">// 首先将整个数组整理成最大堆：从最后一个非叶子节点向前，每个节点执行下沉操作</span><br>        <span class="hljs-comment">// 最后一个非叶子节点：最后一个叶子节点的父亲节点，即parent(data.length-1),套进父节点的公式得到(data.length-2)/2</span><br>        <span class="hljs-keyword">if</span> (data.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (data.length-<span class="hljs-number">2</span>)/<span class="hljs-number">2</span>; i &gt;=<span class="hljs-number">0</span> ; i--) &#123;<br>            siftDown(data,i, data.length);<br>        &#125;<br>        <span class="hljs-comment">// 随后交换，从最后一个数开始，不断的与最大堆第一个数交换</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> data.length-<span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span> ; i--) &#123;<br>            swap(data,<span class="hljs-number">0</span>,i); <span class="hljs-comment">// 将数组第0位，即最大值，和每轮数组最后一个数字交换</span><br>            siftDown(data,<span class="hljs-number">0</span>,i); <span class="hljs-comment">// 交换后，就不满足最大堆了，继续执行下沉操作</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 对 data[0,n) 所形成的最大堆中，索引K的元素，执行siftDown</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;&gt;<span class="hljs-keyword">void</span> <span class="hljs-title function_">siftDown</span><span class="hljs-params">(E[] data, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span>&#123; <span class="hljs-comment">// 下沉的动作顺序是将数组最后的元素和头节点互换，然后把最后的元素放到合适的位置上</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span> &lt; n)&#123;  <span class="hljs-comment">// 停止循环的条件是，k所在的位置是叶子节点，此时左孩子节点肯定大于数组总长度</span><br>            <span class="hljs-comment">// 对于每轮判定的元素，需要找出左右子节点中哪个节点更大，即保证data[j]是左右子节点中的最大值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>; <span class="hljs-comment">// 假设j现在是左子节点</span><br>            <span class="hljs-keyword">if</span> (j+<span class="hljs-number">1</span> &lt; n &amp;&amp; data[j+<span class="hljs-number">1</span>].compareTo(data[j])&gt;<span class="hljs-number">0</span>) <span class="hljs-comment">// 如果右子节点比左子节点大</span><br>                j = <span class="hljs-number">2</span>*k+<span class="hljs-number">2</span>; <span class="hljs-comment">// 或者是 j = j+1;</span><br><br>            <span class="hljs-keyword">if</span> (data[k].compareTo(data[j])&gt;<span class="hljs-number">0</span>) <span class="hljs-comment">// k比子节点大，说明不用换</span><br>                <span class="hljs-keyword">break</span>;<br>            swap(data,k,j); <span class="hljs-comment">// 否则就交换数组中的数</span><br>            k = j; <span class="hljs-comment">// 更新k值</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(E[] arr,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
















              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div></div>
      <div>http://jswanyu.github.io/2023/05/15/数据结构与算法/数据结构与算法：07.排序/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>万宇</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年5月15日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>






<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
