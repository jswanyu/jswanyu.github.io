<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis：01.初识Redis</title>
    <link href="/2022/06/16/Redis/01.%E5%88%9D%E8%AF%86Redis/"/>
    <url>/2022/06/16/Redis/01.%E5%88%9D%E8%AF%86Redis/</url>
    
    <content type="html"><![CDATA[<p>参考资料：黑马Redis教程 </p><p><a href="https://www.bilibili.com/video/BV1cr4y1671t?spm_id_from=333.999.0.0">黑马程序员Redis入门到实战教程，全面透析redis底层原理+redis分布式锁+企业解决方案+redis实战</a></p><h1 id="一、认识NoSQL"><a href="#一、认识NoSQL" class="headerlink" title="一、认识NoSQL"></a>一、认识NoSQL</h1><p>略</p><h1 id="二、认识Redis"><a href="#二、认识Redis" class="headerlink" title="二、认识Redis"></a>二、认识Redis</h1><p>略</p><h1 id="三、安装Redis"><a href="#三、安装Redis" class="headerlink" title="三、安装Redis"></a>三、安装Redis</h1><p>大多数企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此课程中我们会基于Linux系统来安装Redis.</p><p>此处选择的Linux版本为CentOS 7.</p><p>Redis的官方网站地址：<a href="https://redis.io/">https://redis.io/</a></p><h2 id="1-单机安装Redis"><a href="#1-单机安装Redis" class="headerlink" title="1. 单机安装Redis"></a>1. 单机安装Redis</h2><h3 id="1-1-安装Redis依赖"><a href="#1-1-安装Redis依赖" class="headerlink" title="1.1 安装Redis依赖"></a>1.1 安装Redis依赖</h3><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum install -y gcc tcl<br></code></pre></td></tr></table></figure><h3 id="1-2-上传安装包并解压"><a href="#1-2-上传安装包并解压" class="headerlink" title="1.2 上传安装包并解压"></a>1.2 上传安装包并解压</h3><p>然后将课前资料提供的Redis安装包上传到虚拟机的任意目录：</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/Redis%E5%AE%89%E8%A3%85/%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B1.png"></p><p>例如，我放到了&#x2F;usr&#x2F;local&#x2F;src 目录：</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/Redis%E5%AE%89%E8%A3%85/%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B2.png"></p><p>解压缩：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -zxvf redis-6.2.6.tar.gz<br></code></pre></td></tr></table></figure><p>解压后：</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/Redis%E5%AE%89%E8%A3%85/%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B3.png"></p><p>进入redis目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> redis-6.2.6<br></code></pre></td></tr></table></figure><p>运行编译命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">make &amp;&amp; make install<br></code></pre></td></tr></table></figure><p>如果没有出错，应该就安装成功了。</p><p>默认的安装路径是在 <code>/usr/local/bin</code>目录下：</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/Redis%E5%AE%89%E8%A3%85/%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B4.png"></p><p>该目录以及默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p><ul><li>redis-cli：是redis提供的命令行客户端</li><li>redis-server：是redis的服务端启动脚本</li><li>redis-sentinel：是redis的哨兵启动脚本</li></ul><p>cd</p><h3 id="1-3-启动"><a href="#1-3-启动" class="headerlink" title="1.3 启动"></a>1.3 启动</h3><p>redis的启动方式有很多种，例如：</p><ul><li>默认启动</li><li>指定配置启动</li><li>开机自启</li></ul><h4 id="1-3-1-默认启动"><a href="#1-3-1-默认启动" class="headerlink" title="1.3.1 默认启动"></a>1.3.1 默认启动</h4><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">redis-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>如图：</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/Redis%E5%AE%89%E8%A3%85/%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B5.png"></p><p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p><h4 id="1-3-2-指定配置启动"><a href="#1-3-2-指定配置启动" class="headerlink" title="1.3.2 指定配置启动"></a>1.3.2 指定配置启动</h4><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/Redis%E5%AE%89%E8%A3%85/%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B6.png"></p><p>我们先将这个配置文件备份一份：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cp</span> redis.<span class="hljs-keyword">conf</span> redis.<span class="hljs-keyword">conf</span>.bck<br></code></pre></td></tr></table></figure><p>然后修改redis.conf文件中的一些配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span><br><span class="hljs-attr">bind</span> <span class="hljs-string">0.0.0.0</span><br><span class="hljs-comment"># 守护进程，修改为yes后即可后台运行</span><br><span class="hljs-attr">daemonize</span> <span class="hljs-string">yes </span><br><span class="hljs-comment"># 密码，设置后访问Redis必须输入密码</span><br><span class="hljs-attr">requirepass</span> <span class="hljs-string">123321</span><br></code></pre></td></tr></table></figure><p>Redis的其它常见配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 监听的端口</span><br><span class="hljs-attr">port</span> <span class="hljs-string">6379</span><br><span class="hljs-comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span><br><span class="hljs-attr">dir</span> <span class="hljs-string">.</span><br><span class="hljs-comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span><br><span class="hljs-attr">databases</span> <span class="hljs-string">1</span><br><span class="hljs-comment"># 设置redis能够使用的最大内存</span><br><span class="hljs-attr">maxmemory</span> <span class="hljs-string">512mb</span><br><span class="hljs-comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span><br><span class="hljs-attr">logfile</span> <span class="hljs-string">&quot;redis.log&quot;</span><br></code></pre></td></tr></table></figure><p>启动Redis：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入redis安装目录 </span><br><span class="hljs-built_in">cd</span> /usr/local/src/redis-6.2.6<br><span class="hljs-comment"># 启动</span><br>redis-server redis.conf<br></code></pre></td></tr></table></figure><p>停止服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span><br><span class="hljs-comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span><br>redis-cli -u 123321 shutdown<br></code></pre></td></tr></table></figure><h4 id="1-3-3-开机自启"><a href="#1-3-3-开机自启" class="headerlink" title="1.3.3 开机自启"></a>1.3.3 开机自启</h4><p>我们也可以通过配置来实现开机自启。</p><p>首先，新建一个系统服务文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vi /etc/systemd/system/redis.service<br></code></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs conf">[Unit]<br>Description=redis-server<br>After=network.target<br><br>[Service]<br>Type=forking<br>ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf<br>PrivateTmp=true<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p>然后重载系统服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">systemctl daemon-reload<br></code></pre></td></tr></table></figure><p>现在，我们可以用下面这组命令来操作redis了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 启动</span><br>systemctl start redis<br><span class="hljs-comment"># 停止</span><br>systemctl stop redis<br><span class="hljs-comment"># 重启</span><br>systemctl restart redis<br><span class="hljs-comment"># 查看状态</span><br>systemctl status redis<br></code></pre></td></tr></table></figure><p>执行下面的命令，可以让redis开机自启：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">systemctl <span class="hljs-built_in">enable</span> redis<br></code></pre></td></tr></table></figure><h2 id="2-Redis客户端"><a href="#2-Redis客户端" class="headerlink" title="2. Redis客户端"></a>2. Redis客户端</h2><p>安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：</p><ul><li>命令行客户端</li><li>图形化桌面客户端</li><li>编程客户端</li></ul><h3 id="2-1-Redis命令行客户端"><a href="#2-1-Redis命令行客户端" class="headerlink" title="2.1 Redis命令行客户端"></a>2.1 Redis命令行客户端</h3><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli [options] [commonds]<br></code></pre></td></tr></table></figure><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123321</code>：指定redis的访问密码</li></ul><p>其中的commonds就是Redis的操作命令，例如：</p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li></ul><p>不指定commond时，会进入<code>redis-cli</code>的交互控制台：</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/Redis%E5%AE%89%E8%A3%85/%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B7.png"></p><h3 id="2-2-图形化桌面客户端"><a href="#2-2-图形化桌面客户端" class="headerlink" title="2.2 图形化桌面客户端"></a>2.2 图形化桌面客户端</h3><p>GitHub上的大神编写了Redis的图形化桌面客户端，地址：<a href="https://github.com/uglide/RedisDesktopManager">https://github.com/uglide/RedisDesktopManager</a></p><p>不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。</p><p>在下面这个仓库可以找到安装包：<a href="https://github.com/lework/RedisDesktopManager-Windows/releases">https://github.com/lework/RedisDesktopManager-Windows/releases</a></p><h4 id="2-2-1-安装"><a href="#2-2-1-安装" class="headerlink" title="2.2.1 安装"></a>2.2.1 安装</h4><p>在课前资料中可以找到Redis的图形化桌面客户端：</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/Redis%E5%AE%89%E8%A3%85/%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B8.png"></p><p>解压缩后，运行安装程序即可安装，此处略。</p><p>安装完成后，在安装目录下找到rdm.exe文件：</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/Redis%E5%AE%89%E8%A3%85/%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B9.png"></p><p>双击即可运行：</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/Redis%E5%AE%89%E8%A3%85/%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B10.png"></p><h4 id="2-2-2-建立连接"><a href="#2-2-2-建立连接" class="headerlink" title="2.2.2 建立连接"></a>2.2.2 建立连接</h4><p>首先要开放linux里redis的端口，参考：<a href="https://blog.csdn.net/zhangtxsir/article/details/89607964">redis开启远程访问，centos7开放端口</a></p><p>开放完端口后重启redis</p><p>点击左上角的<code>连接到Redis服务器</code>按钮</p><p>在弹出的窗口中填写Redis服务信息：</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/Redis%E5%AE%89%E8%A3%85/%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B11.png"></p><p>点击确定后，在左侧菜单会出现链接，点击即可建立连接了：</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/Redis%E5%AE%89%E8%A3%85/%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B12.png"></p><p>Redis默认有16个仓库，编号从0至15.  通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。</p><p>如果是基于redis-cli连接Redis服务，可以通过select命令来选择数据库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 选择 0号库</span><br>select 0<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis：03.Redis的Java客户端</title>
    <link href="/2022/06/16/Redis/03.Redis%E7%9A%84Java%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <url>/2022/06/16/Redis/03.Redis%E7%9A%84Java%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<p>在Redis官网中提供了各种语言的客户端，地址：<a href="https://redis.io/clients">https://redis.io/clients</a></p><h1 id="1-客户端：Jedis与Letture"><a href="#1-客户端：Jedis与Letture" class="headerlink" title="1. 客户端：Jedis与Letture"></a>1. 客户端：Jedis与Letture</h1><p>后续我们主要还是使用SpringBoot来整合Redis，所以只学习和SpringBoot有关的操作，SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，它提供了对不同Redis客户端的整合，这其中主要有这两个客户端：</p><ul><li>Jedis：以Redis命令作为方法名称，学习成本低，简单实用。但是Jedis实例是线程不安全的，多线程环境下需要基于连接池来使用</li><li>Lettuce：Lettuce是基于Netty实现的，支持同步、异步和响应式编程方式，并且是线程安全的。支持Redis的哨兵模式、集群模式和管道模式。<strong>SpringBoot默认使用此客户端</strong></li></ul><h1 id="2-springboot整合redis"><a href="#2-springboot整合redis" class="headerlink" title="2. springboot整合redis"></a>2. springboot整合redis</h1><h2 id="2-1-整合步骤"><a href="#2-1-整合步骤" class="headerlink" title="2.1 整合步骤"></a>2.1 整合步骤</h2><p>springboot整合redis，操作步骤如下：</p><p><strong>步骤①</strong>：导入springboot整合redis的starter坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Redis依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--连接池依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​        上述坐标可以在创建模块的时候通过勾选的形式进行选择，归属NoSQL分类中</p><p><strong>步骤②</strong>：进行基础配置</p><p>​        操作redis，最基本的信息就是操作哪一台redis服务器，所以服务器地址属于基础配置信息，不可缺少。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123321</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-string">100ms</span><br></code></pre></td></tr></table></figure><p><strong>步骤③</strong>：使用springboot整合redis的专用客户端接口操作，此处使用的是RedisTemplate，后续再讲</p><p>springboot整合redis技术提供了多种客户端兼容模式，默认提供的是lettucs客户端技术，也可以根据需要切换成指定客户端技术，例如jedis客户端技术，切换成jedis客户端技术操作步骤如下：</p><p><strong>步骤①</strong>：导入jedis坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​        jedis坐标受springboot管理，无需提供版本号</p><p><strong>步骤②</strong>：配置客户端技术类型，设置为jedis</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">client-type:</span> <span class="hljs-string">jedis</span><br></code></pre></td></tr></table></figure><p><strong>步骤③</strong>：根据需要设置对应的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">client-type:</span> <span class="hljs-string">jedis</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">16</span><br>    <span class="hljs-attr">jedis:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><p><strong>lettcus与jedis区别</strong></p><ul><li>jedis连接Redis服务器是直连模式，当多线程模式下使用jedis会存在线程安全问题，解决方案可以通过配置连接池使每个连接专用，这样整体性能就大受影响</li><li>lettcus基于Netty框架进行与Redis服务器连接，底层设计中采用StatefulRedisConnection。 StatefulRedisConnection自身是线程安全的，可以保障并发访问安全问题，所以一个连接可以被多线程复用。当然lettcus也支持多连接实例一起工作</li></ul><h2 id="2-2-RedisTemplate"><a href="#2-2-RedisTemplate" class="headerlink" title="2.2 RedisTemplate"></a>2.2 RedisTemplate</h2><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><table><thead><tr><th><strong>API</strong></th><th><strong>返回值类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>redisTemplate</strong>.opsForValue()</td><td>ValueOperations</td><td>操作String类型数据</td></tr><tr><td><strong>redisTemplate</strong>.opsForHash()</td><td>HashOperations</td><td>操作Hash类型数据</td></tr><tr><td><strong>redisTemplate</strong>.opsForList()</td><td>ListOperations</td><td>操作List类型数据</td></tr><tr><td><strong>redisTemplate</strong>.opsForSet()</td><td>SetOperations</td><td>操作Set类型数据</td></tr><tr><td><strong>redisTemplate</strong>.opsForZSet()</td><td>ZSetOperations</td><td>操作SortedSet类型数据</td></tr><tr><td><strong>redisTemplate</strong></td><td></td><td>通用的命令</td></tr></tbody></table><p>在上一步完成导入redis坐标、配好设置参数后，我们可以注入RedisTemplate工具类，并对Redis进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisDemoApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate&lt;String,Object&gt; redisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 插入一条string类型数据</span><br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;tom&quot;</span>);<br>        <span class="hljs-comment">// 读取一条string类型数据</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">tom</span><br></code></pre></td></tr></table></figure><h2 id="2-3-SpringDataRedis的序列化方式"><a href="#2-3-SpringDataRedis的序列化方式" class="headerlink" title="2.3 SpringDataRedis的序列化方式"></a>2.3 SpringDataRedis的序列化方式</h2><p>RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，默认是采用<strong>JDK序列化</strong>，如上文例子中得到的结果是这样的：</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/RedisTemplate%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E7%BB%93%E6%9E%9C.png"></p><p>它并不会改变原有的name键，而是新建一个序列化的键，值也不是tom，而是序列化后的结果，这就造成了可读性差、内存占用大的问题。因此我们不希望使用<strong>JDK序列化</strong></p><p>我们可以自定义RedisTemplate的序列化方式，在com.itheima.redis.config包下创建RedisConfig文件，自定义RedisTemplate，代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span>&#123;<br>        <span class="hljs-comment">// 创建RedisTemplate对象</span><br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        <span class="hljs-comment">// 设置连接工厂</span><br>        template.setConnectionFactory(connectionFactory);<br>        <span class="hljs-comment">// 创建JSON序列化工具</span><br>        <span class="hljs-type">GenericJackson2JsonRedisSerializer</span> <span class="hljs-variable">jsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericJackson2JsonRedisSerializer</span>();<br>        <span class="hljs-comment">// 设置Key的序列化：采用String序列化</span><br>        template.setKeySerializer(RedisSerializer.string());<br>        template.setHashKeySerializer(RedisSerializer.string());<br>        <span class="hljs-comment">// 设置Value的序列化：采用JSON序列化</span><br>        template.setValueSerializer(jsonRedisSerializer);<br>        template.setHashValueSerializer(jsonRedisSerializer);<br>        <span class="hljs-comment">// 返回</span><br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用了这个自定义的RedisTemplate，不使用JDK的序列化，可以提高可读性，但带来的问题是，为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销（即类的信息太长了）。</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/%E8%87%AA%E5%AE%9A%E4%B9%89RedisTemplate%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E7%BB%93%E6%9E%9C.png"></p><p>这就要用到StringRedisTemplate，下文继续介绍</p><h2 id="2-4-StringRedisTemplate"><a href="#2-4-StringRedisTemplate" class="headerlink" title="2.4 StringRedisTemplate"></a>2.4 StringRedisTemplate</h2><p>​        为了节省内存空间，我们并不会使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，程序员手动完成对象的序列化和反序列化。</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/StringRedisTemplate%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%87%E7%A8%8B.png"></p><p>我们仍然可以像上文一样自己定义这个RedisTemplate，但Spring默认提供了一个<strong>StringRedisTemplate</strong>类，它的key和value的序列化方式默认就是String方式。省去了我们自定义RedisTemplate的过程。</p><p>在使用时，序列化和反序列化的工具我们可以选择springmvc自带的jackson序列化工具，或者fastJSON等。</p><p>测试代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisStringTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 写入一条String数据</span><br>        stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;tom&quot;</span>);<br>        <span class="hljs-comment">// 获取string数据</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);<br>    &#125;<br><br>    <span class="hljs-comment">// jackson序列化工具</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSaveUser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException &#123;<br>        <span class="hljs-comment">// 创建对象</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-number">21</span>);<br>        <span class="hljs-comment">// 手动序列化</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> mapper.writeValueAsString(user);<br>        <span class="hljs-comment">// 写入数据</span><br>        stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;heima:user:4&quot;</span>, json);<br><br>        <span class="hljs-comment">// 获取数据</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">jsonUser</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;heima:user:4&quot;</span>);<br>        <span class="hljs-comment">// 手动反序列化</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> mapper.readValue(jsonUser, User.class);<br>        System.out.println(<span class="hljs-string">&quot;heima:user:4 = &quot;</span> + user1);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testHash</span><span class="hljs-params">()</span> &#123;<br>        stringRedisTemplate.opsForHash().put(<span class="hljs-string">&quot;heima:user:5&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;wynn&quot;</span>);<br>        stringRedisTemplate.opsForHash().put(<span class="hljs-string">&quot;heima:user:5&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;24&quot;</span>);<br><br>        Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(<span class="hljs-string">&quot;heima:user:5&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;entries = &quot;</span> + entries);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis：02.Redis基本数据结构</title>
    <link href="/2022/06/16/Redis/02.Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2022/06/16/Redis/02.Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Redis数据结构介绍"><a href="#1-Redis数据结构介绍" class="headerlink" title="1. Redis数据结构介绍"></a>1. Redis数据结构介绍</h1><p>Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样：</p><p>基本类型：String， Hash，List， Set， SortedSet</p><p>特殊类型：GEO，BitMap， HuperLog</p><h1 id="2-Redis通用命令"><a href="#2-Redis通用命令" class="headerlink" title="2. Redis通用命令"></a>2. Redis通用命令</h1><p>Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ <a href="https://redis.io/commands">https://redis.io/commands </a>）可以查看到不同的命令</p><p>也可以在Redis里使用help命令查询某类命令的具体用法</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">help</span> @generic<br></code></pre></td></tr></table></figure><p>上述命令就可以查询通用的Redis命令</p><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p><ul><li>KEYS：查看符合模板的所有key，不建议在生产环境设备上使用</li><li>DEL：删除一个指定的key</li><li>EXISTS：判断key是否存在</li><li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除，建议设置有效期</li><li>TTL：查看一个KEY的剩余有效期，-1代表永久有效，-2代表已经被删除</li></ul><p>通过help [command] 可以查看一个命令的具体用法，例如输入如下命令</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">help</span> <span class="hljs-built_in">keys</span><br></code></pre></td></tr></table></figure><p>会输出</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">KEYS</span> pattern<br><span class="hljs-attribute">summary</span>: Find <span class="hljs-literal">all</span> keys matching the given pattern<br><span class="hljs-attribute">since</span>: <span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">group</span>: generic<br></code></pre></td></tr></table></figure><h1 id="3-String类型"><a href="#3-String类型" class="headerlink" title="3. String类型"></a>3. String类型</h1><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增、自减操作</li><li>float：浮点类型，可以做自增、自减操作</li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m</p><p><strong>String的常见命令有：</strong></p><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的键值对</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li><li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并且指定有效期</li></ul><p><strong>key的层级结构</strong></p><p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式为：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">项目名:业务名:类型:<span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。</p><p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p><p>uuser相关的key：heima:user:1</p><p>uproduct相关的key：heima:product:1</p><p>可以层级的定义key，如下图所示：</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/Key%E7%9A%84%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84.png"></p><p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储</p><table><thead><tr><th><strong>KEY</strong></th><th><strong>VALUE</strong></th></tr></thead><tbody><tr><td>heima:user:1</td><td>{“id”:1,  “name”: “Jack”, “age”: 21}</td></tr><tr><td>heima:product:1</td><td>{“id”:1,  “name”: “小米11”, “price”: 4999}</td></tr></tbody></table><h1 id="4-Hash类型"><a href="#4-Hash类型" class="headerlink" title="4. Hash类型"></a>4. Hash类型</h1><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p><p> {“id”:1,  “name”: “Jack”, “age”: 21}  </p><p>上面的JSON字符串修改一个属性就得修改整个JSON，很不方便，Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/Hash%E7%BB%93%E6%9E%84.png"></p><p><strong>Hash的常见命令有：</strong></p><ul><li>HSET key field value：添加或者修改hash类型key的field的值</li><li>HGET key field：获取一个hash类型key的field的值</li><li>HMSET：批量添加多个hash类型key的field的值</li><li>HMGET：批量获取多个hash类型key的field的值</li><li>HGETALL：获取一个hash类型的key中的所有的field和value</li><li>HKEYS：获取一个hash类型的key中的所有的field</li><li>HVALS：获取一个hash类型的key中的所有的value</li><li>HINCRBY：让一个hash类型key的字段值自增并指定步长</li><li>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</li></ul><h1 id="5-List类型"><a href="#5-List类型" class="headerlink" title="5. List类型"></a>5. List类型</h1><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><p><strong>List的常见命令有：</strong></p><ul><li>LPUSH key element … ：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element … ：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素</li><li>BLPOP&#x2F;BRPOP key time(s)：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/List%E7%9A%84%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E7%90%86%E8%A7%A3.png"></p><p>其中关于最后一个命令，这里演示一下，现在users键是没创建的，或者说是空的，在一个终端里输入：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">BLPOP</span> users <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>这是终端会停止不动，等待100s，这期间如果在其他终端向users添加元素，这个终端就会移除并返回列表左侧的第一个元素</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/%E6%BC%94%E7%A4%BAList%E7%9A%84BLPOP%E5%91%BD%E4%BB%A4.png"></p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/%E6%BC%94%E7%A4%BAList%E7%9A%84BLPOP%E5%91%BD%E4%BB%A41.png"></p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/%E6%BC%94%E7%A4%BAList%E7%9A%84BLPOP%E5%91%BD%E4%BB%A42.png"></p><p>思考：</p><p>如何利用List结构模拟一个栈?  —- 入口和出口在同一边</p><p>如何利用List结构模拟一个队列?  —- 入口和出口在不同边</p><p>如何利用List结构模拟一个阻塞队列?  —- 入口和出口在不同边，出队时采用BLPOP或BRPOP</p><h1 id="6-Set类型"><a href="#6-Set类型" class="headerlink" title="6. Set类型"></a>6. Set类型</h1><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集、并集、差集等功能</li></ul><p>Set的常见命令有：</p><ul><li>SADD key member … ：向set中添加一个或多个元素</li><li>SREM key member … : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2 … ：求key1与key2的交集</li><li>SDIFF key1 key2 … ：求key1与key2的差集</li><li>SUNION key1 key2 ..：求key1和key2的并集</li></ul><h1 id="7-SortedSet类型"><a href="#7-SortedSet类型" class="headerlink" title="7. SortedSet类型"></a>7. SortedSet类型</h1><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><p>SortedSet的常见命令有：</p><ul><li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member : 获取sorted set中的指定元素的score值</li><li>ZRANK key member：获取sorted set 中的指定元素的排名</li><li>ZCARD key：获取sorted set中的元素个数</li><li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li><li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li></ul><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可2</p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis：04.Redis实战应用一：短信登录</title>
    <link href="/2022/06/16/Redis/04.Redis%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8%E4%B8%80%EF%BC%9A%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95/"/>
    <url>/2022/06/16/Redis/04.Redis%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8%E4%B8%80%EF%BC%9A%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>黑马的实战篇教程是用一个点评项目来运用Redis，这里记录一下</p><h1 id="1-导入后端项目"><a href="#1-导入后端项目" class="headerlink" title="1. 导入后端项目"></a>1. 导入后端项目</h1><p>导入黑马点评项目，先用sql文件建表，然后复制idea项目到工作目录，然后在IDEA里打开项目，在配置文件中修改MySQL和Redis的相关配置</p><p>再把资料里的nginx文件夹拷贝到工作目录，在nginx所在目录下打开一个CMD窗口，输入命令：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-literal">start</span> nginx.exe<br></code></pre></td></tr></table></figure><p>打开chrome浏览器，访问: <a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a> ，即可看到页面。在空白页面点击鼠标右键，选择检查，即可打开开发者工具，然后打开手机模式</p><h1 id="2-基于Session实现登录"><a href="#2-基于Session实现登录" class="headerlink" title="2. 基于Session实现登录"></a>2. 基于Session实现登录</h1><h2 id="2-1-发送短信验证码"><a href="#2-1-发送短信验证码" class="headerlink" title="2.1 发送短信验证码"></a>2.1 发送短信验证码</h2><p>功能展示</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/%E7%9F%AD%E4%BF%A1%E7%99%BB%E9%99%86-%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81-%E5%8A%9F%E8%83%BD%E5%B1%95%E7%A4%BA.png" alt="image-20220613234932578"></p><p>功能逻辑</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/%E7%9F%AD%E4%BF%A1%E7%99%BB%E9%99%86-%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81-%E5%8A%9F%E8%83%BD%E9%80%BB%E8%BE%91.png" alt="image-20220613235129586"></p><p>功能代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserService</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sendCode</span><span class="hljs-params">(String phone, HttpSession session)</span> &#123;<br>        <span class="hljs-comment">// 1.校验手机号</span><br>        <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;<br>            <span class="hljs-comment">// 2.如果不符合，返回错误信息</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 3.符合，生成验证码</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> RandomUtil.randomNumbers(<span class="hljs-number">6</span>);<br><br>        <span class="hljs-comment">// 4.保存验证码到 session</span><br>        session.setAttribute(<span class="hljs-string">&quot;code&quot;</span>,code);<br><br>        <span class="hljs-comment">// 5.发送验证码</span><br>        log.debug(<span class="hljs-string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>, code);<br>        <span class="hljs-comment">// 返回ok</span><br>        <span class="hljs-keyword">return</span> Result.ok();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中发送验证码只是简单的后台打印下，没有真正的发送</p><h2 id="2-2-短信验证码登录"><a href="#2-2-短信验证码登录" class="headerlink" title="2.2 短信验证码登录"></a>2.2 短信验证码登录</h2><p>功能展示</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/%E7%9F%AD%E4%BF%A1%E7%99%BB%E9%99%86-%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E7%99%BB%E5%BD%95-%E5%8A%9F%E8%83%BD%E5%B1%95%E7%A4%BA.png" alt="image-20220614124619440"></p><p>功能逻辑</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/%E7%9F%AD%E4%BF%A1%E7%99%BB%E9%99%86-%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E7%99%BB%E5%BD%95-%E5%8A%9F%E8%83%BD%E9%80%BB%E8%BE%91.png" alt="image-20220614124832196"></p><p>功能代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 登录和注册功能</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> loginForm 登录参数，包含手机号、验证码；或者手机号、密码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">// 1.校验手机号</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> loginForm.getPhone();<br>    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;<br>        <span class="hljs-comment">// 2.如果不符合，返回错误信息</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.校验验证码</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">cacheCode</span> <span class="hljs-operator">=</span> session.getAttribute(<span class="hljs-string">&quot;code&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> loginForm.getCode();<br>    <span class="hljs-keyword">if</span> (cacheCode == <span class="hljs-literal">null</span> || !cacheCode.equals(code)) &#123;<br>        <span class="hljs-comment">// 不一致，报错</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 4.一致，根据手机号查询用户 select * from tb_user where phone = ? 这里使用了MybatisPlus，代码比较简洁</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;phone&quot;</span>, phone).one();<br><br>    <span class="hljs-comment">// 5.判断用户是否存在</span><br>    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 6.不存在，创建新用户并保存</span><br>        user = createUserWithPhone(phone);<br>    &#125;<br><br>    <span class="hljs-comment">// 7.保存用户信息到Session里</span><br>    session.setAttribute(<span class="hljs-string">&quot;user&quot;</span>,user);<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建并保存用户</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> phone</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> User</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> User <span class="hljs-title function_">createUserWithPhone</span><span class="hljs-params">(String phone)</span> &#123;<br>    <span class="hljs-comment">// 1.创建用户</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setPhone(phone);<br>    user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(<span class="hljs-number">10</span>));<br>    <span class="hljs-comment">// 2.保存用户</span><br>    save(user);<br>    <span class="hljs-keyword">return</span> user;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-拦截器登录验证"><a href="#2-3-拦截器登录验证" class="headerlink" title="2.3 拦截器登录验证"></a>2.3 拦截器登录验证</h2><p>用户登录成功之后，以后每次请求资源自然不能都要登录，而是改为每次请求之前都要校验登录状态。而我们自然不希望在每个Controller里都编写校验登录的代码，耦合性太强，这里需要使用拦截器进行登录验证。</p><p>功能逻辑</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/%E7%9F%AD%E4%BF%A1%E7%99%BB%E9%99%86-%E6%8B%A6%E6%88%AA%E5%99%A8%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81-%E5%8A%9F%E8%83%BD%E9%80%BB%E8%BE%91.png" alt="image-20220614130627614"></p><p>值得一提的是，为了确保获取当前访问的用户，拦截器需要将每个用户信息传递到Controller里，这里选择将用户保存到 ThreadLocal 里，保证线程的安全问题</p><p>拦截器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.hmdp.utils;<br>...<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 进入controller之前进行登录校验</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> handler</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.获取Session</span><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br>        <span class="hljs-comment">// 2.获取session中的用户</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br>        <span class="hljs-comment">// 3.判断用户是否存在</span><br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 4. 不存在，拦截，返回401状态码</span><br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 5.存在，保存用户信息到ThreadLocal</span><br>        UserHolder.saveUser((UserDTO) user);<br>        <span class="hljs-comment">// 6.放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 业务执行完毕销毁对应的用户信息，避免内存泄漏</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> handler</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ex</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 移除用户</span><br>        UserHolder.removeUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.hmdp.config;<br>...<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-comment">// 登录拦截器</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginInterceptor</span>())<br>                .excludePathPatterns(<br>                        <span class="hljs-string">&quot;/shop/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/voucher/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/shop-type/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/upload/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/blog/hot&quot;</span>,<br>                        <span class="hljs-string">&quot;/user/code&quot;</span>,<br>                        <span class="hljs-string">&quot;/user/login&quot;</span><br>                );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里黑马给的nginx代码 login.html 跳转返回的是index.html首页，视频演示的是跳转到info.html详情页，如果要和视频保持一致，就去nginx文件夹里找到 login.html 把跳转代码改了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html">axios.post(&quot;/user/login&quot;, this.form)<br>.then((&#123;data&#125;) =&gt; &#123;<br>    if(data)&#123;<br>      // 保存用户信息到session<br>      sessionStorage.setItem(&quot;token&quot;, data);<br>    &#125;<br>    // 跳转到首页<br>    location.href = &quot;/info.html&quot;<br></code></pre></td></tr></table></figure><p>如果还是有问题，建议继续往后面看视频，还有一些数据类型转换的东西没有讲完，可能是那一部分原因导致的跳转失败。并且此处应该更关注后端尤其是数据库里的现象，不用太在意前端现象</p><h2 id="2-4-隐藏用户敏感信息"><a href="#2-4-隐藏用户敏感信息" class="headerlink" title="2.4 隐藏用户敏感信息"></a>2.4 隐藏用户敏感信息</h2><p>之前Session里存取的都是完整的User，包括密码等属性，一方面这是敏感信息，不应该在HTTP里传输，另一方面多余的信息也会带来额外的内存消耗，因此可以建立UserDTO，仅使用必要的信息完成数据传输</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.hmdp.dto;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDTO</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String nickName;<br>    <span class="hljs-keyword">private</span> String icon;<br>&#125;<br></code></pre></td></tr></table></figure><p>随后可以将Session里存取的User也换成UserDTO</p><h1 id="3-集群的session共享问题"><a href="#3-集群的session共享问题" class="headerlink" title="3. 集群的session共享问题"></a>3. 集群的session共享问题</h1><p><strong>session共享问题</strong>：多台Tomcat并不共享session存储空间，由于负载均衡，集群会把请求切换到不同的tomcat服务，这时其他的tomcat没有之前的session，导致数据丢失。</p><p>tomcat也有过一些解决方案，比如在tomcat集群里拷贝所有的Session，但这会导致内存和时间上的浪费</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/%E7%9F%AD%E4%BF%A1%E7%99%BB%E9%99%86-%E9%9B%86%E7%BE%A4%E7%9A%84session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98.png" alt="image-20220615111417359"></p><p>session的替代方案应该满足：</p><ul><li>数据共享</li><li>内存存储</li><li>key、value结构</li></ul><p>所以可以使用Redis作为替代方案</p><h1 id="4-基于Redis实现共享session登录"><a href="#4-基于Redis实现共享session登录" class="headerlink" title="4. 基于Redis实现共享session登录"></a>4. 基于Redis实现共享session登录</h1><p>Redis代替session需要考虑的问题：</p><ul><li>为value选择合适的Redis数据结构</li><li>选择合适的key方便存取</li><li>选择合适的存储粒度</li></ul><h2 id="4-1-发送短信验证码"><a href="#4-1-发送短信验证码" class="headerlink" title="4.1 发送短信验证码"></a>4.1 发送短信验证码</h2><p>之前是将验证码保存到Session里，现在要将验证码保存到Redis里</p><ul><li><p>为value选择合适的Redis数据结构：由于验证码就是6位数字，所以value可以选择String类型</p></li><li><p>选择合适的key：key显然不能是之前session里的”code”了，因为每个session里有自己的code，现在如果再用code作为key，显然不能满足不同请求的需求。这里可以将手机号作为key，有两方面的原因：</p><ul><li><p>存：每个用户提交的手机号是不同的，根据不同手机号往redis里存验证码，能够保证key的唯一性</p></li><li><p>取：后续的功能里，即之前讲的2.2用户使用短信验证码登录时，直接使用session里的信息，不用考虑取信息的问题，tomcat自动帮你维护了，但现在用Redis得考虑怎么取数据。而用手机号作为key，刚好能够在用户使用短信验证码登录时提供的手机号去Reids里取出验证码</p></li></ul></li></ul><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/%E7%9F%AD%E4%BF%A1%E7%99%BB%E9%99%86-Redis%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E7%99%BB%E5%BD%95-%E5%8A%9F%E8%83%BD%E9%80%BB%E8%BE%91.png" alt="img"></p><p>代码：更新 sendCode() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 发送手机验证码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sendCode</span><span class="hljs-params">(String phone, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">// 1.校验手机号</span><br>    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;<br>        <span class="hljs-comment">// 2.如果不符合，返回错误信息</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.符合，生成验证码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> RandomUtil.randomNumbers(<span class="hljs-number">6</span>);<br><br>    <span class="hljs-comment">// 4.保存验证码到 Redis // set key value ex 120</span><br>    stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);<br><br>    <span class="hljs-comment">// 5.发送验证码</span><br>    log.debug(<span class="hljs-string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>, code);<br>    <span class="hljs-comment">// 返回ok</span><br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-2-短信验证码登录"><a href="#4-2-短信验证码登录" class="headerlink" title="4.2 短信验证码登录"></a>4.2 短信验证码登录</h2><p>之前短信验证码登录有一个必不可缺的逻辑就是校验验证码之后总需要保存用户对象信息到session里，方便后续每次请求里对该信息进行处理，现在不用session了，可以将其存在redis里，还是考虑两个问题：</p><ul><li>为value选择合适的Redis数据结构：保存一个对象，Redis通常有两种数据结构可选，一是String结构，以JSON字符串来保存，比较直观。二是Hash结构，它可以将对象中的每个字段独立存储，可以针对单个字段做CRUD，并且内存占用更少（JSON里有不必要的符号）。一般如果数据较少的话，两个都行，数据较多从优化的角度，Hash结构更适合。此处我们选择Hash结构</li><li>选择合适的key：这里也可以将手机号作为key，但不推荐，原因后面讲，而是用一个随机字符串 token，作为key，存储用户数据。也有两方面原因：<ul><li>存：随机字符串能够保证key的唯一性，能够存数据</li><li>取：后续的功能里，即之前讲的2.3登录验证时，用户每次请求时，是携带cookie的，里面有sessionID，这样就能用session里的用户信息进行判断，这是tomcat帮我们维护的。现在不用session了，得去redis里取出用户信息，这里就可以根据 token 取出，即把 token 作为用户的登陆凭证，取代之前的cookie。那么如何让用户每次请求时都带上 token 呢，这里需要我们在保存用户信息到Redis之后，不能结束流程，而是要将 token 通过响应信息返回给客户端，以便于客户端以后每次请求时都带上这个token。这里也是不将手机号作为key的原因，在响应中放这种敏感信息是不合理的。</li></ul></li></ul><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/%E7%9F%AD%E4%BF%A1%E7%99%BB%E9%99%86-Redis%E9%AA%8C%E8%AF%81%E7%A0%81%E7%99%BB%E5%BD%95%E4%B8%8E%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81-%E5%8A%9F%E8%83%BD%E9%80%BB%E8%BE%91.png" alt="image-20220615125514215"></p><p>代码：更新 login() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 登录和注册功能</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> loginForm 登录参数，包含手机号、验证码；或者手机号、密码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">// 1.校验手机号</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> loginForm.getPhone();<br>    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;<br>        <span class="hljs-comment">// 2.如果不符合，返回错误信息</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.从redis获取验证码并校验</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">cacheCode</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> loginForm.getCode();<br>    <span class="hljs-keyword">if</span> (cacheCode == <span class="hljs-literal">null</span> || !cacheCode.equals(code)) &#123;<br>        <span class="hljs-comment">// 不一致，报错</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 4.一致，根据手机号查询用户 select * from tb_user where phone = ? 这里使用了MybatisPlus，代码比较简洁</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;phone&quot;</span>, phone).one();<br><br>    <span class="hljs-comment">// 5.判断用户是否存在</span><br>    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 6.不存在，创建新用户并保存</span><br>        user = createUserWithPhone(phone);<br>    &#125;<br><br>    <span class="hljs-comment">// 7.保存用户信息到 redis中</span><br>    <span class="hljs-comment">// 7.1.随机生成token，作为登录令牌。UUID是工具类，toStirng如果给参数true表示不生成带下划线的随机字符串</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 7.2.将User对象先转为UserDTO再转为HashMap存储到redis里，都是用的BeanUtil里的工具。这里由于UserDTO有long型的id，转换时需要自定义规则</span><br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);<br>    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(),<br>            CopyOptions.create()                 <span class="hljs-comment">// 自定义规则</span><br>                    .setIgnoreNullValue(<span class="hljs-literal">true</span>)    <span class="hljs-comment">// 忽略空的值（UserDTO里有icon属性暂时还没管）</span><br>                    .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));  <span class="hljs-comment">// 将所有的属性都转成String类型</span><br>    <span class="hljs-comment">// 7.3.存储</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">tokenKey</span> <span class="hljs-operator">=</span> LOGIN_USER_KEY + token;<br>    stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);<br>    <span class="hljs-comment">// 7.4.设置token有效期，模仿session设置为30min</span><br>    stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);<br><br>    <span class="hljs-comment">// 8.返回token</span><br>    <span class="hljs-keyword">return</span> Result.ok(token);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里关于token有效期有一个问题是，expire这个函数是设定死了30min之后失效，不管这期间有没有继续访问请求，但实际上的逻辑应该是如果用户继续不断访问，则应该不断更新有效期，只有用户完全不访问了，再等30min才失去登录状态。这里的逻辑写在后续的拦截器中</p><h2 id="4-3-拦截器登录验证"><a href="#4-3-拦截器登录验证" class="headerlink" title="4.3 拦截器登录验证"></a>4.3 拦截器登录验证</h2><p>拦截器的功能逻辑如下图所示</p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/%E7%9F%AD%E4%BF%A1%E7%99%BB%E9%99%86-Redis%E6%8B%A6%E6%88%AA%E5%99%A8%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81-%E5%8A%9F%E8%83%BD%E9%80%BB%E8%BE%91.png" alt="image-20220615164223203" style="zoom:67%;" /><p>代码：更新 LoginInterceptor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LoginInterceptor</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 进入controller之前进行登录校验</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> handler</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.获取请求头中的token</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;authorization&quot;</span>); <span class="hljs-comment">// 前端代码里这样写的</span><br>        <span class="hljs-keyword">if</span> (StrUtil.isBlank(token)) &#123;<br>            <span class="hljs-comment">// token为空，拦截，返回401状态码</span><br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 2.基于TOKEN获取redis中的用户</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span>  <span class="hljs-operator">=</span> LOGIN_USER_KEY + token;<br>        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);<br>        <span class="hljs-comment">// 3.判断用户是否存在</span><br>        <span class="hljs-keyword">if</span> (userMap.isEmpty()) &#123;<br>            <span class="hljs-comment">// 4.用户不存在，拦截，返回401状态码</span><br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 5.将查询到的hash数据转为UserDTO</span><br>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(), <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 6.存在，保存用户信息到 ThreadLocal</span><br>        UserHolder.saveUser(userDTO);<br>        <span class="hljs-comment">// 7.刷新token有效期</span><br>        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);<br>        <span class="hljs-comment">// 8.放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 业务执行完毕销毁对应的用户信息，避免内存泄漏</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> handler</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ex</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 移除用户</span><br>        UserHolder.removeUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>更新WebMvcConfigurer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-comment">// 登录拦截器</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginInterceptor</span>(stringRedisTemplate))<br>                .excludePathPatterns(<br>                        <span class="hljs-string">&quot;/shop/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/voucher/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/shop-type/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/upload/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/blog/hot&quot;</span>,<br>                        <span class="hljs-string">&quot;/user/code&quot;</span>,<br>                        <span class="hljs-string">&quot;/user/login&quot;</span><br>                );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><p>redis 的内容</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/%E7%9F%AD%E4%BF%A1%E7%99%BB%E9%99%86-Redis%E6%8B%A6%E6%88%AA%E5%99%A8%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81-Redis%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="Snipaste_2022-06-15_18-43-43"></p><p>每次请求中登录验证的 token</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/%E7%9F%AD%E4%BF%A1%E7%99%BB%E9%99%86-Redis%E6%8B%A6%E6%88%AA%E5%99%A8%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81-%E7%BB%93%E6%9E%9C%E4%B8%AD%E7%9A%84%E8%AF%B7%E6%B1%82tkoen.png" alt="Snipaste_2022-06-15_18-44-25"></p><p>注意，在拦截器类 LoginInterceptor 注入 StringRedisTemplate可能会失败，参考笔记：<a href="https://juejin.cn/post/7109412059917320200">问题解决：springboot拦截器无法注入 StringRedisTemplate - 掘金 (juejin.cn)</a></p><h2 id="4-4-优化拦截器登陆验证"><a href="#4-4-优化拦截器登陆验证" class="headerlink" title="4.4 优化拦截器登陆验证"></a>4.4 优化拦截器登陆验证</h2><p>在前面的拦截器思路中（如下图所示），拦截器负责更新 token 的有效期，但其实有些网页请求是不用拦截的，比如商户信息。现在假设一个用户登录了之后浏览了30分钟的商户信息，这30分钟没有用到拦截器，然后 token 就过期了，用户得重新登录，这显然是不合理的，因此我们需要对拦截器做出优化。</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/%E7%9F%AD%E4%BF%A1%E7%99%BB%E9%99%86-Redis%E6%8B%A6%E6%88%AA%E5%99%A8%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-%E9%80%BB%E8%BE%91%E6%A1%86%E5%9B%BE.png" alt="image-20220615221757251"></p><p>优化方法：</p><p>可以新增加一个拦截器拦截一切信息，在这个拦截器里负责获取、查询、更新 token，原先的 LoginInterceptor 拦截器只负责查询用户是否存在，逻辑图如下，这样就可以解决前面提到的问题。</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/%E7%9F%AD%E4%BF%A1%E7%99%BB%E9%99%86-Redis%E6%8B%A6%E6%88%AA%E5%99%A8%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF-%E9%80%BB%E8%BE%91%E6%A1%86%E5%9B%BE.png" alt="image-20220615222048131"></p><p>代码：</p><p>新添加拦截器 RefreshTokenInterceptor，注意此处是拦截一切请求，所以查不到 token 也没事，放行就行。查不到用户也放行，用户判断放到原先的 LoginInterceptor 拦截器去处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefreshTokenInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RefreshTokenInterceptor</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br>    <span class="hljs-comment">// 拦截一切请求，获取、查询、更新 token</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.获取请求头中的token</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;authorization&quot;</span>);<br>        <span class="hljs-keyword">if</span> (StrUtil.isBlank(token)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;   <span class="hljs-comment">// 注意这里的变化，此处是拦截一切请求，所以查不到token也没事，放行就行</span><br>        &#125;<br>        <span class="hljs-comment">// 2.基于TOKEN获取redis中的用户</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span>  <span class="hljs-operator">=</span> LOGIN_USER_KEY + token;<br>        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);<br>        <span class="hljs-comment">// 3.判断用户是否存在</span><br>        <span class="hljs-keyword">if</span> (userMap.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 同上，放行</span><br>        &#125;<br>        <span class="hljs-comment">// 5.将查询到的hash数据转为UserDTO</span><br>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(), <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 6.存在，保存用户信息到 ThreadLocal</span><br>        UserHolder.saveUser(userDTO);<br>        <span class="hljs-comment">// 7.刷新token有效期</span><br>        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);<br>        <span class="hljs-comment">// 8.放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 业务执行完毕销毁对应的用户信息，避免内存泄漏</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 移除用户</span><br>        UserHolder.removeUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>更新 LoginInterceptor，只需要去ThreadLocal中查询是否有用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.判断是否需要拦截（ThreadLocal中是否有用户）</span><br>        <span class="hljs-keyword">if</span> (UserHolder.getUser() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 没有，需要拦截，设置状态码</span><br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-comment">// 拦截</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 有用户，则放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>更新拦截器配置类，注意添加拦截器 registry.addInterceptor() 时，用 order() 方法指定顺序，确保 token刷新拦截器比登录验证拦截器先执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-comment">// token刷新拦截器</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>).order(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 登录验证拦截器</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginInterceptor</span>())<br>                .excludePathPatterns(<br>                        <span class="hljs-string">&quot;/shop/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/voucher/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/shop-type/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/upload/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/blog/hot&quot;</span>,<br>                        <span class="hljs-string">&quot;/user/code&quot;</span>,<br>                        <span class="hljs-string">&quot;/user/login&quot;</span><br>                ).order(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><p>登录之后不断访问 个人主页 和 首页，去查看Redis里 token 的TTL ，应该是不断被刷新重置的。这样就能够解决登录状态刷新的问题</p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis问题解决：springboot拦截器无法注入StringRedisTemplate</title>
    <link href="/2022/06/16/Redis/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%EF%BC%9Aspringboot%E6%8B%A6%E6%88%AA%E5%99%A8%E6%97%A0%E6%B3%95%E6%B3%A8%E5%85%A5StringRedisTemplate/"/>
    <url>/2022/06/16/Redis/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%EF%BC%9Aspringboot%E6%8B%A6%E6%88%AA%E5%99%A8%E6%97%A0%E6%B3%95%E6%B3%A8%E5%85%A5StringRedisTemplate/</url>
    
    <content type="html"><![CDATA[<h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><p>在学习Redis实战课程过程中，需要用拦截器实现登录验证功能，其需要从Redis中获取用户信息，大致功能逻辑如图</p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Redis/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/%E7%9F%AD%E4%BF%A1%E7%99%BB%E9%99%86-Redis%E6%8B%A6%E6%88%AA%E5%99%A8%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81-%E5%8A%9F%E8%83%BD%E9%80%BB%E8%BE%91.png" style="zoom:67%;" /><p>这里一个问题，拦截器里使用Redis时，自然需要使用 StringRedisTemplate ，然而发现不能在拦截器类 LoginInterceptor 注入 StringRedisTemplate，<font color=red>因为拦截器执行在bean实例化前执行的，拦截器会先加载，所以 StringRedisTemplate 还没有被实例化</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>报错信息：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">java.lang.NullPointerException: Cannot<span class="hljs-built_in"> invoke </span><span class="hljs-string">&quot;org.springframework.data.redis .core.StringRedisTemplate.opsForHash()&quot;</span> because <span class="hljs-string">&quot;this.stringRedisTemplate&quot;</span> is null<br>at com.hmdp.utils.LoginInterceptor.preHandle(LoginInterceptor.java:50) ~[classes/:na]<br></code></pre></td></tr></table></figure><h1 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2. 解决方法"></a>2. 解决方法</h1><h2 id="2-1-方法一"><a href="#2-1-方法一" class="headerlink" title="2.1 方法一"></a>2.1 方法一</h2><p>在 WebMvcConfigurer 里注入 StringRedisTemplate，并把 StringRedisTemplate 作为 LoginInterceptor 的一个属性，然后用有参构造函数传递到 LoginInterceptor 里去，也是黑马视频教程的用法</p><p>拦截器配置类：MvcConfig.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-comment">// 登录拦截器</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginInterceptor</span>(stringRedisTemplate))<br>                .excludePathPatterns(<br>...<br>                );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>拦截器类：LoginInterceptor.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LoginInterceptor</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br>    <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-方法二"><a href="#2-2-方法二" class="headerlink" title="2.2 方法二"></a>2.2 方法二</h2><p>还是在拦截器类 LoginInterceptor 注入 StringRedisTemplate，现在知道拦截器执行是在bean实例化前执行的，那么我们就让拦截器执行的时候实例化拦截器Bean，在拦截器配置类里面先实例化拦截器，然后再获取 。我也实验了代码，确实可行</p><p>LoginInterceptor.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>MvcConfig.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> LoginInterceptor <span class="hljs-title function_">getLoginInterceptor</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginInterceptor</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-comment">// 登录拦截器</span><br>        registry.addInterceptor(getLoginInterceptor())<br>                .excludePathPatterns(<br>...<br>                );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考资料：<a href="https://www.jb51.net/article/216067.htm">springboot拦截器无法注入redisTemplate的解决方法_java_脚本之家 (jb51.net)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo用法</title>
    <link href="/2022/03/28/Hexo%E7%94%A8%E6%B3%95/"/>
    <url>/2022/03/28/Hexo%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h1><h2 id="1-创建新博客"><a href="#1-创建新博客" class="headerlink" title="1. 创建新博客"></a>1. 创建新博客</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;文章标题&quot;</span><br></code></pre></td></tr></table></figure><p>并不推荐手动在本地博客文件夹中创建 markdown 文件，很多模板配置要重新写</p><h2 id="2-清除本地缓存"><a href="#2-清除本地缓存" class="headerlink" title="2. 清除本地缓存"></a>2. 清除本地缓存</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo clean<br></code></pre></td></tr></table></figure><p>每次无论 <code>hexo g</code> 或 <code>hexo s</code>，最好先使用 <code>hexo clean</code> 清除本地缓存</p><h2 id="3-生成静态页面并远程部署"><a href="#3-生成静态页面并远程部署" class="headerlink" title="3. 生成静态页面并远程部署"></a>3. 生成静态页面并远程部署</h2><p>生成静态页面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate 或 hexo g<br></code></pre></td></tr></table></figure><p>运行服务器，这是在本地运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server 或 hexo s<br></code></pre></td></tr></table></figure><p>部署远程页面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy 或 hexo d<br></code></pre></td></tr></table></figure><p>部署后的异常大部分是线上缓存原因，在确认没有报错的情况下，等待若干时间后即可正常</p><p><strong>推荐每次博客写完使用如下命令</strong>，直接生成静态页面并远程部署</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">$ hexo g <span class="hljs-meta">&amp;&amp; hexo d</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二分查找法</title>
    <link href="/2021/03/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"/>
    <url>/2021/03/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h1><h2 id="一、概念及其介绍"><a href="#一、概念及其介绍" class="headerlink" title="一、概念及其介绍"></a>一、概念及其介绍</h2><p>二分查找是一种在<strong>有序数组</strong>中查找某一特定元素的搜索算法。</p><h2 id="二、算法性能"><a href="#二、算法性能" class="headerlink" title="二、算法性能"></a>二、算法性能</h2><p>二分查找法只针对有序数组，查找次数为1+1+1+…+1，最多有logn的长度，所以复杂度为O(logn)</p><p>排序是二分查找法的前置条件，不将排序时间算在二分查找的时间复杂度里，但想运行二分查找确实需要考虑排序的时间。虽然排序是前置条件，比较耗时，但当多次查找时，仍然具有较低的复杂度。比如查找n次，排序只用1次，时间为nlogn，每次查找为logn，n次查找就是nlogn，合起来就是2nlogn，均摊复杂度就是2nlogn&#x2F;n &#x3D; 2logn，仍然是logn级别。</p><p>所以面对无序数组，多次查找仍然具有较低的时间复杂度，否则不排序每次都用线性查找，将是O(n^2)的复杂度</p><h2 id="三、实例代码"><a href="#三、实例代码" class="headerlink" title="三、实例代码"></a>三、实例代码</h2><h3 id="1-寻找一个数"><a href="#1-寻找一个数" class="headerlink" title="1. 寻找一个数"></a>1. 寻找一个数</h3><p>寻找一个数需要数组中无重复元素，否则极限情况下数组中都是目标数，那第一次就找到了。这种寻找一个数一般都默认数组中无重复元素，否则就是寻找边界问题。</p><p>二分查找只有一个思想，那就是：<strong>逐步缩小搜索区间</strong>。</p><p>使用 left 和 right 向中间靠拢的方法，有一个非常强的语义，那就是：当 left 与 right 重合的时候，我们就找到了问题的答案</p><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%80%9D%E6%83%B3-%E7%BC%A9%E5%B0%8F%E6%90%9C%E7%B4%A2%E5%8C%BA%E9%97%B4.gif" alt="1639968622-EzQzeJ-binary-search-裁剪"></p><p>二分查找的边界细节是一个能很好理解循环不变量这一概念的例子，循环不变量分别是在<code>nums[l,r]</code>中查找和在<code>nums[l,r)</code>中查找。前者很好理解，是最基本的二分查找模型。代码如下：</p><p>循环不变量： 在<code>nums[l,r]</code>中查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 注意</span><br><br>    <span class="hljs-comment">//循环不变量是在nums[l,r]中查找target</span><br>    <span class="hljs-keyword">while</span>(l &lt;= r) &#123;        <span class="hljs-comment">// 注意，&lt;=时区间都不为空</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)<br>            <span class="hljs-keyword">return</span> mid; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            l = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            r = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 元素不在区间返回-1  力扣704</span><br>    <span class="hljs-comment">// return l;  // 元素不在区间返回按顺序插入的位置，即left   力扣35</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而当循环不变量变为在<code>nums[l,r)</code>中查找时，右区间的开闭影响了：<code>r</code> 的初始值、循环条件、查找边界 <code>r</code> 的移动规则。之所以会在这三个地方有差别， 最主要的原因就是因为 <code>r</code> 的定义。右区间开的时候， <code>r</code> 所代表的位置实际上是要查找的数组的<strong>最后一个元素的后一个元素</strong>，是 <strong>不被</strong> 包括在循环以内的。正因如此，这三个地方应该改为：</p><ul><li><code>r</code> 的初始值改为<code>nums.length</code>，因为仍然希望遍历数组中所有元素，但因为右边是开的，所以要让r指向右边界的下一个位置，例如数组{1,2,3,4} 可写为区间[1,4]，也可写成区间[1,5)，但如果是区间[1,4)，则只能代表前三个元素。</li><li>循环条件应该改为<code>while(l &lt; r)</code>，因为当l&#x3D;r时，区间[l,r)是空区间，已经可以作为循环结束的条件了。</li><li>边界 <code>r</code> 的移动规则应改为<code>r = mid</code>，而不是之前的<code>r = mid-1</code>，因为当mid位置的元素大于target时，确定区间缩短为左半区，右边界确实应该为mid-1，但mid-1这个位置的值是要被索引到的，[l,mid-1)这样的区间是不能索引到mid-1位置的元素的，所以要和r的初始值一样，向右移动一位，即<code>r = mid</code>。</li></ul><p><strong>循环不变量的意义也在此体现</strong>，既然最开始就是左闭右开，那么后面每次循环都得是左闭右开，不能突然变成左闭右闭。每次循环中 l 和 r 共同约束了本次查找的范围， 要让本次循环与上一次循环查找的范围既不重复(重复了会引起死循环)， 也不遗漏， 并且要让 l 和 r 共同约束的查找的范围变得无意义时不再进行查找（即跳出 while）(否则会导致访问越界)</p><p>循环不变量：  在<code>nums[l,r)</code>中查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> nums.length;  <span class="hljs-comment">// 注意，由于右边是开区间，所以要让r大一个</span><br><br>    <span class="hljs-comment">//循环不变量是在nums[l,r)中查找target</span><br>    <span class="hljs-keyword">while</span>(l &lt; r) &#123;     <span class="hljs-comment">// 注意，由于右边是开区间，l=r已经为空，不能取=</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)<br>            <span class="hljs-keyword">return</span> mid; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            l = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意，左区间是不变的</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            r = mid;    <span class="hljs-comment">// 注意，此时是要搜索到mid-1这个数，因为右边是开区间，所以r要改成mid</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-寻找左侧边界"><a href="#2-寻找左侧边界" class="headerlink" title="2. 寻找左侧边界"></a>2. 寻找左侧边界</h3><p>在<code>nums[l,r]</code>中查找target目标值的左侧边界</p><p>需要注意的是，找到一个 target，然后向左或向右线性搜索是不行的，因为这样难以保证二分查找对数级的复杂度了，比如最坏情况全是某一元素，这就是O(n)复杂度了</p><ul><li>还是原来的二分套路</li><li>当我们遇到目标值target时，不断更新右边界，向左收缩，<code>right = mid - 1</code>。终止时 left &#x3D; right+1 , 由于区间是不断向左收缩的，最后的 right 已经到左边界的前一位了，因此返回 left ，或者返回  right +1。（头脑里想象：都是相同的数字，right不断向左二分移动，不断向左收缩，left不变，终止时，right在左边界前一位）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">LeftBound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> nums.length -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt;= r)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r-l)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target)<br>            r = mid - <span class="hljs-number">1</span>;       <span class="hljs-comment">// 注意，寻找左边界的要点，不断更新右边界，向左收缩</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)&#123;<br>            l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)&#123;<br>            r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关于 target 是否在数组内</strong></p><p>如果不考虑target 是否在数组内的话代码其实就已经结束了，返回的 left 不管怎么样都是这个元素按顺序应该插入的位置</p><ul><li>如果target 在数组内，返回的 left 就应该是左侧边界所在位置</li><li>如果target 不在数组内，返回的就是按顺序应插入的位置</li></ul><p>但大部分情况是，target 不在区间内返回-1，因此需要进行额外的判断</p><ul><li><p>正因为返回的 left 不管怎么样都是这个元素按顺序应该插入的位置，那么如果 nums[left] 和 target 不等，则说明 target 不在区间内，即<code>if(nums[left] != target)</code></p></li><li><p>因为用到了数组值nums[left]的比较，所以<strong>在这之前</strong>需要对 left  进行检查，防止数组越界。left什么情况下会越界？letf最小就是0，不会再比0小了，左侧不会越界。l 最大会是下图的情况 。此时，需要对left进行判断，<code>if (l &gt;= nums.length)</code>，返回-1</p>  <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2-%E8%B6%8A%E7%95%8C.png" alt="image-20220122172457055" style="zoom: 50%;" /></li><li><p>注意<code>if (l &gt;= nums.length)</code>要放在<code>if(nums[left] != target)</code>之前判定，<code>if (l &gt;= nums.length)</code>逻辑上看起来像是防止target在区间右侧的情况，但其实它只是为了防止数组越界这一Java语法而设立的判定</p></li><li><p>事实上，因为终止条件是<code>left = right + 1</code>，我们也完全可以返回 right + 1 ，right + 1 是元素按顺序应该插入的位置，那么为了判定 target 是否在区间内就需要比较 <code>if(nums[right+1] != target)</code> ，同理，在这之前就应该先检查 right +1 是否会越界。right +1 什么情况下会越界？ 右侧是不可能的，因为 right 只可能减小，但左侧有可能，如下图。显然 right +1 &lt; 0 会导致数组左侧越界。返回-1  然后再判定 target 是否在区间内</p>  <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E5%8F%B3%E4%BE%A7%E8%BE%B9%E7%95%8C-%E8%B6%8A%E7%95%8C.png" alt="image-20220122190719199" style="zoom: 55%;" /></li><li><p>两种写法都是可以的，只不过一般左侧边界返回left看起来更合逻辑</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">LeftBound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> nums.length -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt;= r)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r-l)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target)<br>            r = mid - <span class="hljs-number">1</span>;       <span class="hljs-comment">// 注意，寻找左边界的要点，不断更新右边界，向左收缩</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)&#123;<br>            l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)&#123;<br>            r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (l &gt;= nums.length)  <span class="hljs-comment">// 防止数组越界</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (nums[l] != target)  <span class="hljs-comment">// 检查target 是否在数组内</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/** 上面两个也可以合并，但注意要把越界写在||前面</span><br><span class="hljs-comment">    * if (l &gt;= nums.length || nums[l] != target)</span><br><span class="hljs-comment">    *     return -1;</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-寻找右侧边界"><a href="#3-寻找右侧边界" class="headerlink" title="3. 寻找右侧边界"></a>3. 寻找右侧边界</h3><p>在<code>nums[l,r]</code>中查找target目标值的右侧边界</p><ul><li>与左侧边界不同之处在于，当我们遇到目标值target时，向右进行偏移<code>left = mid + 1</code>.  终止时 left &#x3D; right+1 ,由于区间是不断向右收缩的，最后的left已经到右边界的下一位了，因此返回right，或者返回 letf-1。（头脑里想象：都是相同的数字，left不断向右二分移动，不断向右收缩，right不变，终止时，left在右边界下一位）</li><li>关于 target 是否在数组内的分析和左侧边界同理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">RightBound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt;= r) &#123;    <span class="hljs-comment">// 终止条件： l = r +1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (r - l) / <span class="hljs-number">2</span> + l;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            l = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 注意，寻找右边界的要点，不断更新左边界，向右收缩</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            l = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 先判断下标越界，在判断是否在数组内</span><br>    <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span> || nums[r] != target) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>    <span class="hljs-comment">/* 如果是用l来表示则为：</span><br><span class="hljs-comment">    * left &lt;= 0 等价于 l-1 &lt; 0 即 l &lt; 1 </span><br><span class="hljs-comment">    if (left &lt;= 0 || nums[left-1] != target)</span><br><span class="hljs-comment">    return -1;</span><br><span class="hljs-comment">    return left - 1;</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-左闭右开区间"><a href="#4-左闭右开区间" class="headerlink" title="4. 左闭右开区间"></a>4. 左闭右开区间</h3><p>根据前面的分析，区间左闭右开只需改动三个地方</p><ul><li>右边界定义<code>r = nums.length</code></li><li>循环条件<code>while (l &lt; r)</code></li><li>左边界不动，右边界处理时<code>r = mid</code></li></ul><p><strong>越界条件变不变暂时不清楚，下面这两段代码先验证完没问题再说，主要就是越界不清楚对不对，网上代码众说纷纭，最好能找个代码测一下</strong></p><p>在<code>nums[l,r)</code>中查找target目标值的左侧边界，没有则返回-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">left_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> nums.length;     <span class="hljs-comment">// 注意，右边为开区间，右边界为索引下一位</span><br>    <br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;          <span class="hljs-comment">// 注意，右边为开区间，停止条件是l=r，这样[l,r)为空，可以正确中止</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            r = mid;         <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            l = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            r = mid;         <span class="hljs-comment">// 注意</span><br>        &#125;<br>    &#125;<br><span class="hljs-keyword">if</span> (l &gt;= nums.length || nums[l] != target) <br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>nums[l,r)</code>中查找target目标值的右侧边界，没有则返回-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">right_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length;<br>    <br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;          <span class="hljs-comment">// 停止条件是l=r</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            l = mid + <span class="hljs-number">1</span>;     <span class="hljs-comment">// 注意,增大搜索区间的下界,向右收缩</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            l = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            r = mid;        <br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 这里不太肯定，等我找个题目验证下</span><br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> nums[r-<span class="hljs-number">1</span>] == target ? (r-<span class="hljs-number">1</span>) : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
