

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="万宇">
  <meta name="keywords" content="">
  
    <meta name="description" content="JavaSEJava语言相关Java语言有哪些特点？ Java是一种面向对象的语言 Java通过Java虚拟机实现了平台无关性，一次编译，到处运行 支持多线程 支持网络编程 具有较高的安全性和可靠性  Java和C++有什么关系，它们有什么区别？ Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。 Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的">
<meta property="og:type" content="article">
<meta property="og:title" content="八股文">
<meta property="og:url" content="http://example.com/2022/06/17/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1%E6%96%87/index.html">
<meta property="og:site_name" content="Wynn&#39;s blog">
<meta property="og:description" content="JavaSEJava语言相关Java语言有哪些特点？ Java是一种面向对象的语言 Java通过Java虚拟机实现了平台无关性，一次编译，到处运行 支持多线程 支持网络编程 具有较高的安全性和可靠性  Java和C++有什么关系，它们有什么区别？ Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。 Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/icon/%E9%9D%A2%E8%AF%95-%E9%A6%96%E9%A1%B5%E5%B0%81%E9%9D%A2%E5%9B%BE.jpeg">
<meta property="article:published_time" content="2022-06-17T01:12:22.000Z">
<meta property="article:modified_time" content="2022-06-17T02:13:11.339Z">
<meta property="article:author" content="万宇">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/icon/%E9%9D%A2%E8%AF%95-%E9%A6%96%E9%A1%B5%E5%B0%81%E9%9D%A2%E5%9B%BE.jpeg">
  
  
  
  <title>八股文 - Wynn&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.1","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":false},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wynn&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/log/">
                <i class="iconfont icon-tags-fill"></i>
                日志
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                时间线
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/icon/%E9%9D%A2%E8%AF%95-%E6%96%87%E7%AB%A0%E9%A1%B5%E9%A1%B6%E9%83%A8%E5%9B%BE.jpeg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="八股文"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-06-17 09:12" pubdate>
          2022年6月17日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          125k 字
        
      </span>
    

    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">八股文</h1>
            
            <div class="markdown-body">
              
              <h1 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h1><h2 id="Java语言相关"><a href="#Java语言相关" class="headerlink" title="Java语言相关"></a>Java语言相关</h2><h3 id="Java语言有哪些特点？"><a href="#Java语言有哪些特点？" class="headerlink" title="Java语言有哪些特点？"></a>Java语言有哪些特点？</h3><ul>
<li>Java是一种面向对象的语言</li>
<li>Java通过Java虚拟机实现了平台无关性，一次编译，到处运行</li>
<li>支持多线程</li>
<li>支持网络编程</li>
<li>具有较高的安全性和可靠性</li>
</ul>
<h3 id="Java和C-有什么关系，它们有什么区别？"><a href="#Java和C-有什么关系，它们有什么区别？" class="headerlink" title="Java和C++有什么关系，它们有什么区别？"></a>Java和C++有什么关系，它们有什么区别？</h3><ul>
<li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li>
<li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li>
<li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li>
<li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li>
<li>Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操<br>  作符重载，而 C++ 可以。</li>
<li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li>
</ul>
<h3 id="JVM、JRE和JDK的关系是什么？"><a href="#JVM、JRE和JDK的关系是什么？" class="headerlink" title="JVM、JRE和JDK的关系是什么？"></a>JVM、JRE和JDK的关系是什么？</h3><p>JVM是Java虚拟机</p>
<p>JRE是Java Runtime Environment缩写，它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>
<p>JDK是（Java Development Kit）的缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/JVM%20JRE%20JDK%E7%9A%84%E5%8C%BA%E5%88%AB.png" srcset="/img/loading.gif" lazyload alt="JVM JRE JDK的区别"></p>
<h3 id="什么是字节码-采用字节码的好处是什么"><a href="#什么是字节码-采用字节码的好处是什么" class="headerlink" title="什么是字节码?采用字节码的好处是什么?"></a>什么是字节码?采用字节码的好处是什么?</h3><p>之所以被称之为字节码，是因为字节码文件由十六进制值组成，而JVM以两个十六进制值为一组，即以字节为单位进行读取。在Java中一般是用javac命令编译源代码为字节码文件，再由 JVM 的类加载器加载字节码文件</p>
<p>Java之所以可以“一次编译，到处运行”，一是因为JVM针对各种操作系统、平台都进行了定制，二是因为无论在什么平台，都可以编译生成固定格式的字节码（.class文件）供JVM使用。因此，也可以看出字节码对于Java生态的重要性。</p>
<p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p>
<h3 id="Java是编译性还是解释性语言？"><a href="#Java是编译性还是解释性语言？" class="headerlink" title="Java是编译性还是解释性语言？"></a>Java是编译性还是解释性语言？</h3><p>既是编译性语言（需要由编译器编译为.class字节码文件），又是解释性语言（需要由JVM读一行执行一行，由解释器解释为操作系统能执行的命令） Java的编译器是javac.exe，解释器是java.exe</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="Java有哪些数据类型？"><a href="#Java有哪些数据类型？" class="headerlink" title="Java有哪些数据类型？"></a>Java有哪些数据类型？</h3><p>Java 语言的数据类型分为两种：基本数据类型和引用数据类型。</p>
<p>基本数据类型包括 8 种：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>关键字</th>
<th>包装类</th>
<th>占用内存（字节）1个字节8位</th>
<th>取值范围</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>字节型</td>
<td>byte</td>
<td>Byte</td>
<td>1</td>
<td>-128(-2^7) ~127(2^7-1)</td>
<td>0</td>
</tr>
<tr>
<td>字符型</td>
<td>char</td>
<td>Character</td>
<td>2</td>
<td></td>
<td>‘\u0000’</td>
</tr>
<tr>
<td>布尔型</td>
<td>boolean</td>
<td>Boolean</td>
<td>1</td>
<td>true&#x2F;flase</td>
<td>false</td>
</tr>
<tr>
<td>短整型</td>
<td>short</td>
<td>Short</td>
<td>2</td>
<td>-2^15 ~ 2^15-1</td>
<td>0</td>
</tr>
<tr>
<td>整型</td>
<td>int</td>
<td>Integer</td>
<td>4</td>
<td>-2^31 ~ 2^31-1</td>
<td>0</td>
</tr>
<tr>
<td>长整型</td>
<td>long</td>
<td>Long</td>
<td>8</td>
<td>-2^63 ~ 2^63-1</td>
<td>0L</td>
</tr>
<tr>
<td>单精度浮点型</td>
<td>float</td>
<td>Float</td>
<td>4</td>
<td>3.4e-45 ~ 1.4e38</td>
<td>0.0F</td>
</tr>
<tr>
<td>双精度浮点型</td>
<td>double</td>
<td>Double</td>
<td>8</td>
<td>4.9e-324 ~1.8e308</td>
<td>0.0D</td>
</tr>
</tbody></table>
<p>引用数据类型建立在基本数据类型的基础上，包括<strong>数组、类和接口</strong>。引用数据类型是由用户自定义，用来限制其他数据的类型。另外，Java 语言中不支持 C++ 中的指针类型、结构体类型、联合类型和枚举类型（Java的枚举是一种特殊的类）。</p>
<h3 id="数据类型的初始化"><a href="#数据类型的初始化" class="headerlink" title="数据类型的初始化"></a>数据类型的初始化</h3><p>Java的基本数据类型如果是<strong>局部变量</strong>则必须要进行初始化，只声明的话后续无法使用。String同理</p>
<p>数组可以只声明，用new创建之后，JVM会自动将每个元素赋为初始值0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">int</span> a;  <span class="hljs-comment">// 应改为int a = 0;</span><br>System.out.println(a); <span class="hljs-comment">// 报错</span><br><br><span class="hljs-type">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span>];<br>System.out.println(b[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 0</span><br><br>String c; <span class="hljs-comment">// 应改为 String c = null 或 String c = &quot;&quot;;</span><br>System.out.println(c); <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure>

<p>如果是全局变量则可以不同初始化，后续面向对象里会提到细节</p>
<h3 id="隐式-自动-类型转换和显示-强制-类型转换"><a href="#隐式-自动-类型转换和显示-强制-类型转换" class="headerlink" title="隐式(自动)类型转换和显示(强制)类型转换"></a>隐式(自动)类型转换和显示(强制)类型转换</h3><p>隐式(自动)类型转换：从存储范围小的类型到存储范围大的类型。</p>
<p>byte → short(char) → int → long → float → double</p>
<p>显示(强制)类型转换：从存储范围大的类型到存储范围小的类型。</p>
<p>double → float → long → int → short(char) → byte 。该类类型转换很可能存在精度的损失。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">short</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>a = a + <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 报错，1是int 型， a+1 会自动转换为int 型，将 int 型直接赋值给 short 型会报错。需要强制类型转换</span><br><span class="hljs-type">short</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>a = (<span class="hljs-type">short</span>)(a + <span class="hljs-number">1</span>); <span class="hljs-comment">// 正确</span><br><span class="hljs-comment">// 或者像下面这样写，因为+=会自动进行强制类型转换</span><br><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>s += <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>



<h3 id="switch-表达式支持的数据类型"><a href="#switch-表达式支持的数据类型" class="headerlink" title="switch 表达式支持的数据类型"></a>switch 表达式支持的数据类型</h3><p>switch仅支持 byte、short、char、int及其包装类，还有枚举（1.5）、String（1.7）类型</p>
<h3 id="解释一下自动装箱和自动拆箱"><a href="#解释一下自动装箱和自动拆箱" class="headerlink" title="解释一下自动装箱和自动拆箱"></a>解释一下自动装箱和自动拆箱</h3><p>从 Java 5 开始引入了自动装箱&#x2F;拆箱机制，把基本类型转换成包装类型的过程叫做装箱（boxing）；反之，把包装类型转换成基本类型的过程叫做拆箱（unboxing），使得二者可以相互转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 声明一个Integer对象，隐含自动装箱</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>;<br><span class="hljs-comment">// 进行计算时隐含的有自动拆箱</span><br>System.out.print(num--);<br></code></pre></td></tr></table></figure>

<p>9是属于基本数据类型的，原则上它是不能直接赋值给一个对象Integer的。但jdk1.5 开始引入了自动装箱&#x2F;拆箱机制，就可以进行这样的声明，自动将基本数据类型转化为对应的封装类型，成为一个对象以后就可以调用对象所声明的所有的方法。而进行运算时候又会转为基本数据类型，因为对象时不能直接进行运算的，而是要转化为基本数据类型后才能进行加减乘除。</p>
<h3 id="包装类型是什么？基本类型和包装类型有什么区别？"><a href="#包装类型是什么？基本类型和包装类型有什么区别？" class="headerlink" title="包装类型是什么？基本类型和包装类型有什么区别？"></a>包装类型是什么？基本类型和包装类型有什么区别？</h3><p>Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），</p>
<p>原始类型: boolean，char，byte，short，int，long，float，double</p>
<p>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p>
<p>区别：</p>
<ul>
<li><p>定义方式不同：基本类型直接定义，包装类型需要new</p>
</li>
<li><p>存放位置不同：基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用。 很显然，相比较于基本类型而言，包装类型需要占用更多的内存空间。所以基本类型比包装类型更高效。</p>
</li>
<li><p>包装类型可以为 null，而基本类型不可以。</p>
<blockquote>
<p>包装类型可以应用于 POJO 中，而基本类型则不行。那为什么 POJO 的属性必须要用包装类型呢？《阿里巴巴 Java 开发手册》上有详细的说明， 数据库的查询结果可能是 null，如果使用基本类型的话，因为要自动拆箱（将包装类型转为基本类型，比如说把 Integer 对象转换成 int 值），就会抛出 NullPointerException 的异常。</p>
</blockquote>
<blockquote>
<p>POJO 的英文全称是 <code>Plain Ordinary Java Object</code>，翻译一下就是，简单无规则的 Java 对象，只有属性字段以及 setter 和 getter 方法。和 POJO 类似的，还有数据传输对象 DTO（Data Transfer Object，泛指用于展示层与服务层之间的数据传输对象）、视图对象 VO（View Object，把某个页面的数据封装起来）、持久化对象 PO（Persistant Object，可以看成是与数据库中的表映射的 Java 对象）</p>
</blockquote>
</li>
<li><p>初始值不同，基本类型的初始值如int为0，boolean为false，而包装类型的初始值为null</p>
</li>
<li><p>包装类型可用于泛型，而基本类型不可以。泛型不能使用基本类型，因为使用基本类型时会编译出错。因为泛型在编译时会进行类型擦除，最后只保留原始类型，而原始类型只能是 Object 类及其子类——基本类型是个特例</p>
</li>
</ul>
<h3 id="只使用基本类型或者包装类型可以吗？"><a href="#只使用基本类型或者包装类型可以吗？" class="headerlink" title="只使用基本类型或者包装类型可以吗？"></a>只使用基本类型或者包装类型可以吗？</h3><p>单从java语言来说只是用包装类型可以，但基本类型使用效率更高，更节省内存，而变成工程中基本类型的使用大量且频繁，所以使用基本类型可以节省大量资源，提高效率。</p>
<p>但是只有基本类型就会有点问题（集合），基本类型可以实现大部分操作，但是基本类型不具备类的特性，包装类型是对基本类型的封装，两者之间可以相互转化，丰富了基本类型的操作。</p>
<h3 id="int-和-Integer-有什么区别"><a href="#int-和-Integer-有什么区别" class="headerlink" title="int 和 Integer 有什么区别?"></a>int 和 Integer 有什么区别?</h3><p>Integer是int的包装类；int是基本数据类型；</p>
<p>Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；</p>
<p>Integer的默认值是null；int的默认值是0。</p>
<h3 id="Integer变量和int变量的对比"><a href="#Integer变量和int变量的对比" class="headerlink" title="Integer变量和int变量的对比"></a>Integer变量和int变量的对比</h3><p>Integer变量和int变量比较时，只要两个变量的值是相等的，则结果为true，因为包装类Integer和基本数据类型int比较时，java会自动拆包为int，然后进行比较，实际上就变为两个int变量的比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1000</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>System.out.println(a==b); <span class="hljs-comment">// true</span><br>System.out.println(a==c); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>



<h3 id="两个new生成的Integer变量，值可以相同，但两个变量不相等"><a href="#两个new生成的Integer变量，值可以相同，但两个变量不相等" class="headerlink" title="两个new生成的Integer变量，值可以相同，但两个变量不相等"></a>两个new生成的Integer变量，值可以相同，但两个变量不相等</h3><p>由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的，因为new生成的是两个对象，其内存地址不同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br><br>System.out.println(a == b); <span class="hljs-comment">// false</span><br>System.out.println(a.equals(b)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>而 <code>a.equals(b)</code> 的输出结果为 true，是因为 Integer类 的 equals 方法内部比较的是两个 int 值是否相等。</p>
<h3 id="两个非new生成的Integer对象的对比"><a href="#两个非new生成的Integer对象的对比" class="headerlink" title="两个非new生成的Integer对象的对比"></a>两个非new生成的Integer对象的对比</h3><p>对于两个非new生成的Integer对象，其实是通过valueOf 方法创建Integer 对象，如果变量的值在区间-128到127之间，会对数值进行缓存，第二次创建的时候直接在缓存中取出使用。缓存是通过Integer的内部类IntegerCache来完成的。所以用连等号判断，会返回true</p>
<p>当值超出此范围，会在堆中new出一个对象来存储，两个对象比较结果为false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>System.out.print(a == b); <span class="hljs-comment">//true</span><br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>System.out.print(a == b); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure>

<p>采用同样的方法，可以看到Double 的valueOf 方法，每次返回都是重新new 一个新的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span>;<br><span class="hljs-type">Double</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span>;<br>System.out.println(a==b); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure>

<p>说下结论 ：</p>
<p>Integer 、Short 、Byte 、Character 、Long 这几个类的valueOf 方法的实现是类似的。有缓存机制在</p>
<p>Double 、Float 的valueOf 方法的实现是类似的。没有缓存机制</p>
<p>然后是Boolean 的valueOf 方法是单独一组的。fasle就相等，true就不相等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Boolean</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-type">Boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-type">Boolean</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-type">Boolean</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>System.out.println(a==b);  <span class="hljs-comment">//true</span><br>System.out.println(c==d);  <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>



<h3 id="非new生成的Integer变量和new-Integer-生成变量的对比"><a href="#非new生成的Integer变量和new-Integer-生成变量的对比" class="headerlink" title="非new生成的Integer变量和new Integer()生成变量的对比"></a>非new生成的Integer变量和new Integer()生成变量的对比</h3><p>（个人理解，资料和博客上不太全）</p>
<p>如果是-128到127范围内，非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同。</p>
<p>如果不是-128到127的范围，则两种方式在堆中创建不同的对象，自然也不同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>System.out.println(a==b); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>





<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="访问修饰符public、private、protected、以及不写（默认）时的区别？"><a href="#访问修饰符public、private、protected、以及不写（默认）时的区别？" class="headerlink" title="访问修饰符public、private、protected、以及不写（默认）时的区别？"></a>访问修饰符public、private、protected、以及不写（默认）时的区别？</h3><table>
<thead>
<tr>
<th>修饰符</th>
<th>同一个类</th>
<th>同一个包中</th>
<th>子类</th>
<th>所有类</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>default</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody></table>
<ul>
<li>private 表示私有，只有自己类能访问</li>
<li>default表示没有修饰符修饰，只有同一个包的类能访问</li>
<li>protected表示可以被同一个包的类以及其他包中的子类访问</li>
<li>public表示可以被该项目的所有包中的所有类访问</li>
</ul>
<p>类的属性一般使用private修饰访问权限，但会提供相应的get&#x2F;set方法来访问相关属性，这些方法通常是public修饰的，以提供对属性的赋值与读取操作</p>
<h3 id="运算符-amp-amp-和-amp-，-和"><a href="#运算符-amp-amp-和-amp-，-和" class="headerlink" title="运算符&amp;&amp;和&amp;，||和|"></a>运算符&amp;&amp;和&amp;，||和|</h3><p>&amp;&amp; 和&amp; 都可以表示逻辑与，但他们是有区别的，共同点是他们两边的条件都成立的时候最终结果才是true ；不同点是&amp;&amp; 只要是第一个条件不成立为false ，就不会再去判断第二个条件，最终结果直接为false ，而&amp; 判断的是所有的条件。</p>
<p>|| 和| 都表示逻辑或，共同点是只要两个判断条件其中有一个成立最终的结果就是true ，区别是|| 只要满足第一个条件，后面的条件就不再判断，而| 要对所有的条件进行判断。</p>
<h3 id="break-continue-的区别及作用"><a href="#break-continue-的区别及作用" class="headerlink" title="break , continue 的区别及作用"></a>break , continue 的区别及作用</h3><p>break 跳出总上一层循环，不再执行循环(结束当前的循环体)</p>
<p>continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)</p>
<h3 id="Java中final的作用"><a href="#Java中final的作用" class="headerlink" title="Java中final的作用"></a>Java中final的作用</h3><p>Java中final关键字仅可以用来修饰类、方法和变量（包括成员变量和局部变量）：</p>
<ul>
<li>当final修饰<strong>类</strong>时，被修饰的类不能被继承，并且final类中的所有成员方法都会被隐式地指定为final方法，但成员变量则不会变。（比如String类）</li>
<li>当final修饰<strong>方法</strong>时，被修饰的方法无法被所在类的子类重写，但可以被重载，一个类的private方法会隐式的被指定为final方法。</li>
<li>当final修饰<strong>变量</strong>时，如果是基本数据类型，被修饰的变量<strong>必须被初始化</strong>(赋值)，且后续不能修改其值，实质上是<strong>常量</strong>；如果是引用类型，则在对其初始化之后便不能再让其指向另一个对象。即引用的<strong>地址不能改变</strong>，但是这个引用所指向的<strong>对象里面的内容可以改变</strong>。即final修饰其实是防止其被重新初始化 也就是被重新new 一个 或者被 &#x3D; 赋值而已</li>
</ul>
<h3 id="Java中finalize的作用"><a href="#Java中finalize的作用" class="headerlink" title="Java中finalize的作用"></a>Java中finalize的作用</h3><p>finalize 是在 java.lang.Object 里定义的方法，也就是说每一个对象都有这么个方法，这个方法在gc 启动，该对象被回收的时候被调用。一个对象的 finalize 方法只会被调用一次，finalize 被调用不一定会立即回收该对象，所以有可能调用finalize 后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会再次调用 finalize 了，进而产生问题，因此不推荐使用 finalize 方法。</p>
<h3 id="Java中static的作用"><a href="#Java中static的作用" class="headerlink" title="Java中static的作用"></a>Java中static的作用</h3><p>static关键字的基本作用：方便在没有实例化对象的情况下来进行调用方法或者变量，只要类被加载了，就可以通过类名去进行访问。static可以用来修饰类的成员方法、类的成员变量，另外可以编写static代码块来优化程序性能</p>
<p>static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在<strong>静态方法中不能访问类的非静态成员变量和非静态成员方法</strong>，因为非静态成员方法&#x2F;变量都是必须依赖具体的对象才能够被调用，但是在<strong>非静态成员方法中是可以访问静态成员方法&#x2F;变量</strong>的</p>
<p>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。static成员变量的初始化顺序按照定义的顺序进行初始化。</p>
<p>static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。</p>
<h3 id="static关键字会改变类中成员的访问权限吗？"><a href="#static关键字会改变类中成员的访问权限吗？" class="headerlink" title="static关键字会改变类中成员的访问权限吗？"></a>static关键字会改变类中成员的访问权限吗？</h3><p>与C&#x2F;C++中的static不同，Java中的static关键字不会影响到变量或者方法的作用域。在Java中能够影响到访问权限的只有private、public、protected（包括包访问权限）这几个关键字</p>
<h3 id="非静态方法能通过this访问静态成员变量吗？"><a href="#非静态方法能通过this访问静态成员变量吗？" class="headerlink" title="非静态方法能通过this访问静态成员变量吗？"></a>非静态方法能通过this访问静态成员变量吗？</h3><p>可以，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）</p>
<h3 id="static能作用于局部变量么？"><a href="#static能作用于局部变量么？" class="headerlink" title="static能作用于局部变量么？"></a>static能作用于局部变量么？</h3><p>Java中切记：static是不允许用来修饰局部变量。不要问为什么，这是Java语法的规定。但在C&#x2F;C++中static是可以作用域局部变量的</p>
<h3 id="Java中是否可以重写-override-或者重载一个private或者是static的方法？"><a href="#Java中是否可以重写-override-或者重载一个private或者是static的方法？" class="headerlink" title="Java中是否可以重写(override)或者重载一个private或者是static的方法？"></a>Java中是否可以重写(override)或者重载一个private或者是static的方法？</h3><p>都不可以重写，父类中修饰了一个private的方法，子类继承之后，对子类也是不可见的。子类重写则在编译阶段就会报错。</p>
<p>Java中static方法不能被重写&#x2F;覆盖，因为方法重写是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用</p>
<p>都可以重载。</p>
<h3 id="java构造函数、静态代码块、构造代码块的执行顺序是什么？"><a href="#java构造函数、静态代码块、构造代码块的执行顺序是什么？" class="headerlink" title="java构造函数、静态代码块、构造代码块的执行顺序是什么？"></a>java构造函数、静态代码块、构造代码块的执行顺序是什么？</h3><p>基本上代码块分为三种</p>
<ul>
<li><p>静态代码块：用static声明，jvm加载类的时候执行，只执行一次，并优于各种代码块以及构造函数。静态代码块中的变量是局部变量，一个类中可以有多个静态代码块</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>	<span class="hljs-keyword">static</span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>构造代码块：由{ }定义，不加任何修饰符，每一次创建对象的时候执行，优先于构造函数。有对象建立才会运行构造代码块，类不能调用构造代码块。构造函数可能有多个，调用不同构造函数会进行不同的初始化，但构造代码块都会执行</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>	&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行构造代码块&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>普通代码块：方法后面使用”{}”括起来的代码片段,不能单独执行,必须调下其方法名才可以执行.</p>
</li>
</ul>
<p>静态代码块是给类初始化的，构造代码块是给对象初始化用的</p>
<p>代码块执行顺序：静态代码块—&gt; 构造代码块 —&gt; 构造函数—&gt; 普通代码块</p>
<p>继承中代码块执行顺序：父类静态块—&gt;子类静态块—&gt;父类构造代码块—&gt;父类构造器—&gt;子类构造代码块—&gt;子类构造器</p>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>this 关键字可用来引用当前类的实例变量。主要用于形参与成员名字重名，用this 来区分。</p>
<p>this 关键字可用于调用当前类方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun1</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;hello,word&quot;</span>);<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun2</span><span class="hljs-params">()</span>&#123;<br>		<span class="hljs-built_in">this</span>.fun1();<span class="hljs-comment">//this可省略</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>this() 可以用来调用当前类的构造函数。(注意： this() 一定要放在构造函数的第一行，否则编译不通过)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>	<span class="hljs-keyword">private</span> String name;<br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>		<span class="hljs-built_in">this</span>.name = name;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>		<span class="hljs-built_in">this</span>(name);<br>		<span class="hljs-built_in">this</span>.age = age;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>this 关键字可作为调用方法中的参数传递。</p>
<p>this 关键字可作为参数在构造函数调用中传递。</p>
<p>this 关键字可用于从方法返回当前类的实例</p>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><ul>
<li>super 可以用来引用直接父类的实例变量。和this 类似，主要用于区分父类和子类中相同的字段</li>
<li>super 可以用来调用直接父类构造函数。(注意： super() 一定要放在构造函数的第一行，否则编译不通过)</li>
<li>super 可以用来调用直接父类方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Child</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&quot;Father&quot;</span>,<span class="hljs-string">&quot;Child&quot;</span>);<br>        child.test();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-keyword">protected</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Father</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Say</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello,child&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Child</span><span class="hljs-params">(String name1, String name2)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name1); <span class="hljs-comment">//调用直接父类构造函数</span><br>        <span class="hljs-built_in">this</span>.name = name2;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name);<br>        System.out.println(<span class="hljs-built_in">super</span>.name); <span class="hljs-comment">//引用直接父类的实例变量</span><br>        <span class="hljs-built_in">super</span>.Say(); <span class="hljs-comment">//调用直接父类方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>Child<br>Father<br>hello,child</p>
</blockquote>
<h3 id="this与super的区别"><a href="#this与super的区别" class="headerlink" title="this与super的区别"></a>this与super的区别</h3><p>相同点：</p>
<ul>
<li>super() 和this() 都必须在构造函数的第一行进行调用，否则就是错误的</li>
<li>this() 和super() 都指的是对象，所以，均不可以在static 环境中使用。</li>
</ul>
<p>不同点：</p>
<ul>
<li>super() 主要是对父类构造函数的调用， this() 是对重载构造函数的调用</li>
<li>super() 主要是在继承了父类的子类的构造函数中使用，是在不同类中的使用； this() 主要是在同一类的不同构造函数中的使用</li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象和面向过程的区别？"><a href="#面向对象和面向过程的区别？" class="headerlink" title="面向对象和面向过程的区别？"></a>面向对象和面向过程的区别？</h3><p>面向过程性能比面向对象高，因为面向对象在类调用时需要实例化，开销比较大，比较消耗资源</p>
<p>面向对象易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。</p>
<h3 id="面向对象五大基本原则是什么"><a href="#面向对象五大基本原则是什么" class="headerlink" title="面向对象五大基本原则是什么?"></a>面向对象五大基本原则是什么?</h3><ul>
<li><p>单一职责原则：</p>
<p>  一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。</p>
</li>
<li><p>开放封闭原则：</p>
<p>  软件实体应该是可扩展的，而且是不可修改的。也就是，对扩展开放，对修改封闭的。</p>
</li>
<li><p>里氏替换原则：</p>
<p>  子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。</p>
</li>
<li><p>依赖倒置原则：</p>
<p>  依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。</p>
</li>
<li><p>接口隔离原则</p>
<p>  使用多个小的专门的接口，而不要使用一个大的总接口。</p>
</li>
</ul>
<h3 id="面向对象三大特性？"><a href="#面向对象三大特性？" class="headerlink" title="面向对象三大特性？"></a>面向对象三大特性？</h3><p>封装：把客观事物封装成抽象的类，隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别。</p>
<p>继承：继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>
<p>多态：一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定</p>
<h3 id="怎样理解Java的多态"><a href="#怎样理解Java的多态" class="headerlink" title="怎样理解Java的多态"></a>怎样理解Java的多态</h3><p>本质上多态分两种：编译时多态（又称静态多态）、运行时多态（又称动态多态）</p>
<p>重载（overload）就是编译时多态的一个例子，调用方法时通过传递的参数类型来决定具体使用哪个方法，这就是多态性，编译时多态在编译时就已经确定，运行的时候调用的是确定的方法</p>
<p>我们通常所说的多态指的都是运行时多态，指<strong>一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定</strong>。也就是编译时不确定究竟调用哪个具体方法，一直延迟到运行时才能确定。这也是为什么有时候多态方法又被称为延迟方法的原因。多态通常有两种实现方法：</p>
<ul>
<li>子类继承父类（extends）</li>
<li>类实现接口（implements）</li>
</ul>
<p>无论是哪种方法，其核心之处就在于对父类方法的改写或对接口方法的实现，以取得在运行时不同的执行效果。要使用多态，在声明对象时就应该遵循一条法则：<strong>声明的总是父类类型或接口类型，创建的是实际类型</strong>。比如如下的代码中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 都是将 ArrayList对象 赋给其父类 List </span><br><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><span class="hljs-comment">// 而不是 </span><br><span class="hljs-type">ArrayList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><span class="hljs-comment">// 在定义方法参数时也通常总是应该优先使用父类类型或接口类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">(List list)</span>;<br><span class="hljs-comment">//而不是 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">(ArrayList list)</span>;<br></code></pre></td></tr></table></figure>

<p>这样声明最大的好处在于结构的灵活性：假如某一天我认为ArrayList的特性无法满足我的要求，我希望能够用LinkedList来代替它，那么只需要在对象创建的地方把new ArrayList()改为new LinkedList即可，其它代码一概不用改动</p>
<h3 id="Java实现多态的条件"><a href="#Java实现多态的条件" class="headerlink" title="Java实现多态的条件"></a>Java实现多态的条件</h3><p>Java实现多态有 3 个必要条件：继承、重写和向上转型。只有满足这 3 个条件，开发人员才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而执行不同的行为。</p>
<ul>
<li>继承：在多态中必须存在有继承关系的子类和父类。</li>
<li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li>
<li>向上转型：在多态中需要将<font color=red>子类引用赋给父类对象</font>，只有这样该引用才既能可以调用父类的方法，又能调用子类的方法。</li>
</ul>
<p>深入JVM底层，JVM为类在方法区中建立一个虚方法表，存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类重写了父类的方法，子类方法表中的地址会替换为指向子类实现版本的入口地址。</p>
<h3 id="Java子类和父类的转换"><a href="#Java子类和父类的转换" class="headerlink" title="Java子类和父类的转换"></a>Java子类和父类的转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;父类func&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;父类func1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;子类func&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func2</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;子类func2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>子类转为父类</li>
</ul>
<p>让父类的引用指向子类的实例即可，这是多态。</p>
<p>方法：注意此时父类引用只能调用父类方法，如果子类重写父类方法，则调用子类重写的方法，不能调用子类未重写的方法。</p>
<p>属性：属性不存在重写，那么父类的引用调用的为父类的属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Father</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br>a.func(); <span class="hljs-comment">// 子类func</span><br>a.func1(); <span class="hljs-comment">// 父类func1</span><br><span class="hljs-comment">// a.func2(); 报错</span><br>System.out.println(a.value); <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure>

<ul>
<li>父类转换成子类</li>
</ul>
<p>其实父类转换成子类有两种方式</p>
<p>第一种方式就是：强制转换，这种是父类引用指向父类实例，然后把实例强转为子类，会报类型转换异常：ClassCastException</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Father</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>();<br><span class="hljs-type">Son</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (Son)a; <span class="hljs-comment">// 会报类型转换异常：ClassCastException</span><br></code></pre></td></tr></table></figure>

<p>第二种方式有个前提：父类的引用指向子类的实例，但这种方式其实意义也不大</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Father</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br><span class="hljs-type">Son</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (Son)a;<br>System.out.println(b.value); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>

<p>因此一般都认为子类可以转为父类，但父类不能转为子类</p>
<h3 id="Java中，类是单继承多实现，接口是多继承"><a href="#Java中，类是单继承多实现，接口是多继承" class="headerlink" title="Java中，类是单继承多实现，接口是多继承"></a>Java中，类是单继承多实现，接口是多继承</h3><p>java的类只支持单继承，如果子类继承的多个父类里面有相同的方法或者属性，子类将不知道具体继承哪一个，会产生歧义。</p>
<p>但类可以实现多个接口，通过实现接口拓展了类的功能，若实现的多个接口中有重复的方法也没关系，因为实现类中必须重写接口中的方法，所以调用时还是调用的实现类中重写的方法，不会导致歧义。也不用担心属性重复问题，由于接口的所有属性都是 static final修饰的，是常量，在编译时期确定了其值，若在使用时，两个相同的常量值不同，在编译时期就不能通过，不会导致歧义。</p>
<p>接口可以继承多个接口，原因和上面一样。</p>
<h3 id="Java的方法分派？"><a href="#Java的方法分派？" class="headerlink" title="Java的方法分派？"></a>Java的方法分派？</h3><p>方法分派指的是虚拟机如何确定应该执行哪个方法。</p>
<p>静态分派（方法重载）：编译器确定，根据调用者的声明类型和方法参数类型。</p>
<p>动态分派（方法重写）：运行时确定，根据调用者的实际类型分派。</p>
<h3 id="重载（Overload）和重写（Override）的区别是什么？"><a href="#重载（Overload）和重写（Override）的区别是什么？" class="headerlink" title="重载（Overload）和重写（Override）的区别是什么？"></a>重载（Overload）和重写（Override）的区别是什么？</h3><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p>
<p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个<strong>独一无二的参数类型列表</strong>。最常用的地方就是构造器的重载。</p>
<p>重写发生在子类与父类之间, 重写方法返回值和形参都不能改变，与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分。即外壳不变，核心重写</p>
<h3 id="重载的方法能否根据返回值类型进行区分？"><a href="#重载的方法能否根据返回值类型进行区分？" class="headerlink" title="重载的方法能否根据返回值类型进行区分？"></a>重载的方法能否根据返回值类型进行区分？</h3><p>不能根据返回值类型来区分重载的方法。因为调用时不指定类型信息，编译器不知道你要调用哪个函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">float</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br></code></pre></td></tr></table></figure>

<p>当调用<code>max（1,2）</code>时无法确定调用的是哪个，单从这一点上来说，<strong>仅返回值类型不同的重载是不可行的。</strong></p>
<h3 id="构造器（constructor）是否可被重写（override）"><a href="#构造器（constructor）是否可被重写（override）" class="headerlink" title="构造器（constructor）是否可被重写（override）"></a>构造器（constructor）是否可被重写（override）</h3><p>构造器不能被继承，因此不能被重写，但可以被重载。每一个类必须有自己的构造函数，负责构造自己这部分的构造。子类不会覆盖父类的构造函数，相反必须一开始调用父类的构造函数。</p>
<h3 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="构造方法有哪些特性？"></a>构造方法有哪些特性？</h3><p>方法名称和类同名</p>
<p>不用定义返回值类型</p>
<p>不可以写retrun 语句</p>
<p>构造方法可以被重载</p>
<h3 id="在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在Java中定义一个不做事且没有参数的构造方法的作用"></a>在Java中定义一个不做事且没有参数的构造方法的作用</h3><p>Java程序存在继承，在执行子类的构造方法时，如果没有用super() 来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。如果父类只定义了有参数的构造函数，而子类的构造函数没有用super 调用父类那个特定的构造函数，就会出错。</p>
<h3 id="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是"><a href="#在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是" class="headerlink" title="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是"></a>在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是</h3><p>帮助子类做初始化工作</p>
<h3 id="一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"><a href="#一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？" class="headerlink" title="一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"></a>一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？</h3><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li>类变量：独立于方法之外的变量，用static 修饰。</li>
<li>实例变量：独立于方法之外的变量，不过没有 static 修饰。</li>
<li>局部变量：类的方法中的变量。</li>
<li>成员变量：成员变量又称全局变量，可分为类变量和实例变量，有static 修饰为类变量，没有static 修饰为实例变量。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>类变量</th>
<th>实例变量</th>
<th>局部变量</th>
</tr>
</thead>
<tbody><tr>
<td>定义位置</td>
<td>类中，方法外</td>
<td>类中，方法外</td>
<td>方法中</td>
</tr>
<tr>
<td>初始值</td>
<td>有默认初始值</td>
<td>有默认初始值</td>
<td>无默认初始值</td>
</tr>
<tr>
<td>存储位置</td>
<td>方法区</td>
<td>堆</td>
<td>栈</td>
</tr>
<tr>
<td>生命周期</td>
<td>类何时被加载和卸载</td>
<td>实例何时被创建及销毁</td>
<td>方法何时被调用及结束调用</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a;  <span class="hljs-comment">// 类变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> b;         <span class="hljs-comment">// 实例变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> c=<span class="hljs-number">0</span>;           <span class="hljs-comment">// 局部变量，调用前必须要初始化</span><br>        System.out.println(c);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(Test.a);    <span class="hljs-comment">// 类变量不用初始化，0</span><br>        <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        System.out.println(test.b);    <span class="hljs-comment">// 实例变量不用初始化，0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类</p>
<ul>
<li>成员内部类<ul>
<li>成员内部类定义位于另一个类的内部，成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private 成员和静态成员）</li>
<li>当成员内部类拥有和外部类同名的成员变量或者方法时，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：外部类. this .成员变量</li>
<li>在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问。</li>
<li>成员内部类是依附外部类而存在的，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outter</span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Outter</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Outter</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span> &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>        <span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>        inner.fun(); <span class="hljs-comment">//调用内部类的方法</span><br>	&#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123; <span class="hljs-comment">//内部类</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(a);<br>            System.out.println(b);             <span class="hljs-comment">//访问内部类的b</span><br>            System.out.println(Outter.<span class="hljs-built_in">this</span>.b); <span class="hljs-comment">//访问外部类的b</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Outter</span> <span class="hljs-variable">outter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outter</span>();<br>        Outter.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> outter.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>(); <span class="hljs-comment">//创建内部类的对象</span><br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>

<ul>
<li><p>局部内部类</p>
<p>  局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。</p>
</li>
<li><p>匿名内部类</p>
<p>  匿名内部类只没有名字的内部类，在日常开发中使用较多。使用匿名内部类的前提条件：必须继承一个父类或实现一个接口。</p>
</li>
<li><p>静态内部类<br>  静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static 。静态内部类是不需要依赖于外部类的，并且它不能使用外部类的非static 成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static 成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。</p>
</li>
</ul>
<h3 id="内部类的优点"><a href="#内部类的优点" class="headerlink" title="内部类的优点"></a>内部类的优点</h3><ul>
<li>内部类不为同一包的其他类所见，具有很好的封装性；</li>
<li>匿名内部类可以很方便的定义回调。</li>
<li>每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。</li>
<li>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。</li>
</ul>
<h3 id="抽象类是什么？"><a href="#抽象类是什么？" class="headerlink" title="抽象类是什么？"></a>抽象类是什么？</h3><p>抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。抽象方法必须用abstract关键字进行修饰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>

<p>如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰。因为抽象类中含有无具体实现的方法，所以<strong>不能用抽象类创建对象</strong>。包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样<strong>可以拥有成员变量和普通的成员方法</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">[<span class="hljs-keyword">public</span>] <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>抽象类和普通类的主要有三点区别：</p>
<ul>
<li>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。</li>
<li>抽象类不能用来创建对象；</li>
<li>如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。</li>
</ul>
<h3 id="抽象类和接口的区别是什么？"><a href="#抽象类和接口的区别是什么？" class="headerlink" title="抽象类和接口的区别是什么？"></a>抽象类和接口的区别是什么？</h3><p>接口中可以含有变量和方法。但是要注意，接口中的变量会被隐式地指定为<strong>public static fina</strong>l变量，并且也只能是这个，一般情况下不在接口中定义变量。接口里的方法会被隐式地指定为public abstract方法且只能是<strong>public abstract</strong>方法，也就是说，接口中的方法必须都是抽象方法。如果一个非抽象类遵循了某个接口，就必须<strong>实现该接口中的所有方法</strong>。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。</p>
<p>抽象类和接口的区别：</p>
<p>相同点：</p>
<ul>
<li>接口和抽象类都不能实例化</li>
<li>都包含抽象方法，其子类都必须覆写这些抽象方法</li>
</ul>
<p>不同点：</p>
<ul>
<li><p>语法层面上</p>
<ul>
<li><p>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</p>
</li>
<li><p>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</p>
</li>
<li><p>抽象类可以有静态代码块和静态方法，而接口中不能含有静态代码块以及静态方法</p>
</li>
<li><p>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
</li>
</ul>
</li>
<li><p>设计层面上的区别：</p>
<ul>
<li><p>抽象类是对一种<strong>事物</strong>的抽象，对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部即<strong>行为</strong>进行抽象。</p>
</li>
<li><p>设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。</p>
</li>
</ul>
</li>
</ul>
<h3 id="抽象类能使用-final-修饰吗？"><a href="#抽象类能使用-final-修饰吗？" class="headerlink" title="抽象类能使用 final 修饰吗？"></a>抽象类能使用 final 修饰吗？</h3><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</p>
<h3 id="java-创建对象有哪几种方式？"><a href="#java-创建对象有哪几种方式？" class="headerlink" title="java 创建对象有哪几种方式？"></a>java 创建对象有哪几种方式？</h3><p>new创建新对象；通过反射机制；采用clone机制；通过序列化机制</p>
<p>前两者都需要显式地调用构造方法。对于clone机制，需要注意浅拷贝和深拷贝的区别，对于序列化机制需要明确其实现原理，在java中序列化可以通过实现Externalizable或者Serializable来实现</p>
<h3 id="什么是不可变对象-好处是什么"><a href="#什么是不可变对象-好处是什么" class="headerlink" title="什么是不可变对象?好处是什么?"></a>什么是不可变对象?好处是什么?</h3><p>不可变对象指对象一旦被创建，状态就不能再改变,任何修改都会创建一个新的对象，如 String、Integer及其它包装类。</p>
<p>不可变对象最大的好处是线程安全</p>
<h3 id="能否创建一个包含可变对象的不可变对象"><a href="#能否创建一个包含可变对象的不可变对象" class="headerlink" title="能否创建一个包含可变对象的不可变对象?"></a>能否创建一个包含可变对象的不可变对象?</h3><p>当然可以,比如final Person[] persons &#x3D; new Persion[]{ } . persons 是不可变对象的引用,但其数组中的Person实例却是可变的.这种情况下需要特别谨慎,不要共享可变对象的引用.这种情况下，如果数据需要变化时,就返回原对象的一个拷贝</p>
<h3 id="值传递和引用传递的区别的什么？为什么说Java中只有值传递？"><a href="#值传递和引用传递的区别的什么？为什么说Java中只有值传递？" class="headerlink" title="值传递和引用传递的区别的什么？为什么说Java中只有值传递？"></a>值传递和引用传递的区别的什么？为什么说Java中只有值传递？</h3><p>值传递：指的是在方法调用时，将实际参数<strong>复制一份</strong>传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p>
<p>引用传递：指的是在方法调用时，将实际参数的地址直接传递到方法中，在方法中对参数所进行的修改，将影响到实际参数。</p>
<p>java中方法参数传递方式只有按值传递。</p>
<p>如果参数是基本类型，传递的是基本类型的字面量<strong>值的拷贝</strong>。</p>
<p>如果参数是引用类型，传递的是该参量所引用的对象在堆中地址<strong>值的拷贝</strong>。</p>
<p>基本类型示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>	printValue(a);<br>	System.out.println(<span class="hljs-string">&quot;a:&quot;</span> + a);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printValue</span><span class="hljs-params">(<span class="hljs-type">int</span> b)</span>&#123;<br>	b = <span class="hljs-number">2</span>;<br>	System.out.println(<span class="hljs-string">&quot;b:&quot;</span>+ b);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">b</span>:<span class="hljs-number">2</span><br><span class="hljs-attribute">a</span>:<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>a 的值还是1，并未发生改变，所以这种情况下为值传递。</p>
<p>引用类型示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>	<span class="hljs-type">Preson</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Preson</span>();<br>	p.name = <span class="hljs-string">&quot;zhangsan&quot;</span>;<br>	printValue(p);<br>	System.out.println(<span class="hljs-string">&quot;p.name: &quot;</span> + p.name);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printValue</span><span class="hljs-params">(Preson q)</span>&#123;<br>	q.name = <span class="hljs-string">&quot;lisi&quot;</span>;<br>	System.out.println(<span class="hljs-string">&quot;q.name: &quot;</span>+ q.name);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">q</span><span class="hljs-selector-class">.name</span>: lisi<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.name</span>: lisi<br></code></pre></td></tr></table></figure>

<p>在将p 传入printValue 方法后，方法调用结束， p 的name 属性竟然被改变了！但其实是因为方法里传递的是一个地址引用的副本，这个副本引用和原始的引用指向的同一个对象，所以副本引用修改过对象属性后，通过原始引用查看对象属性肯定也是被修改过的。</p>
<p>换句话说， printValue 方法中修改的是副本引用指向的对象的属性，不是引用本身，如果修改的是引用本身，那么原始引用肯定不受影响。看下面这个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>	<span class="hljs-type">Preson</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Preson</span>();<br>	p.name = <span class="hljs-string">&quot;zhangsan&quot;</span>;<br>	printValue(p);<br>	System.out.println(<span class="hljs-string">&quot;p.name: &quot;</span> + p.name);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printValue</span><span class="hljs-params">(Preson q)</span>&#123;<br>	q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Preson</span>();<br>	q.name = <span class="hljs-string">&quot;lisi&quot;</span>;<br>	System.out.println(<span class="hljs-string">&quot;q.name: &quot;</span>+ q.name);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">q</span><span class="hljs-selector-class">.name</span>: lisi<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.name</span>: zhangsan<br></code></pre></td></tr></table></figure>

<p>printValue 方法中并没有改变副本引用q 所指向的对象，而是改变了副本引用q 本身，将副本引用q 指向了另一个对象并对这个对象的属性进行修改，所以原始引用p 所指向的对象不受影响。</p>
<h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><p>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，两个引用指向两个对象，但对象内容相同。</p>
<p>浅拷贝：对基本数据类型进行值传递，对引用数据类型复制一个引用指向原始引用的对象，就是复制的引用和原始引用指向同一个对象。</p>
<h3 id="x3D-x3D-和-equals-区别是什么？"><a href="#x3D-x3D-和-equals-区别是什么？" class="headerlink" title="&#x3D;&#x3D; 和 equals 区别是什么？"></a>&#x3D;&#x3D; 和 equals 区别是什么？</h3><ul>
<li><p>&#x3D;&#x3D;<br>  对于基本数据类型， &#x3D;&#x3D; 比较的是值；</p>
<p>  对于引用数据类型， &#x3D;&#x3D; 比较的是内存地址。</p>
</li>
<li><p>equals()</p>
<p>  对于没有重写equals 方法的类（默认是不重写）， equals 方法和&#x3D;&#x3D; 作用类似；基本类型比较值，引用类型比较地址</p>
<p>  对于重写过equals 方法的类，equals 一般会重写为比较值了</p>
</li>
</ul>
<h3 id="java语言规范要求equals方法具有以下特性"><a href="#java语言规范要求equals方法具有以下特性" class="headerlink" title="java语言规范要求equals方法具有以下特性"></a>java语言规范要求equals方法具有以下特性</h3><ul>
<li>自反性：对于任意不为null的引用值x，x.equals(x)一定是true。</li>
<li>对称性：对于任意不为null的引用值x和y，当且仅当x.equals(y)是true时，y.equals(x)也是true。</li>
<li>传递性。对于任意不为null的引用值x、y和z，如果x.equals(y)是true，同时y.equals(z)是true，那么x.equals(z)一定是true。</li>
<li>一致性。对于任意不为null的引用值x和y，如果用于equals比较的对象信息没有被修改的话，多次调用时x.equals(y)要么一致地返回true要么一致地返回false。</li>
<li>对于任意不为null的引用值x，x.equals(null)返回false。</li>
</ul>
<h3 id="介绍下hashCode-？"><a href="#介绍下hashCode-？" class="headerlink" title="介绍下hashCode()？"></a>介绍下hashCode()？</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashcode能够使得集合具有很好的对象检索性能</p>
<p>hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。</p>
<h3 id="为什么引入Hash？好处是什么？"><a href="#为什么引入Hash？好处是什么？" class="headerlink" title="为什么引入Hash？好处是什么？"></a>为什么引入Hash？好处是什么？</h3><p>简称散列算法，是将一个大文件映射成一个小串字符。与指纹一样，就是以较短的信息来保证文件的唯一性的标志，这种标志与文件的每一个字节都相关，而且难以找到逆向规律。</p>
<p>好处：</p>
<ul>
<li>在庞大的数据库中，由于哈希值更为短小，被找到更为容易，因此，哈希使数据的存储与查询速度更快。</li>
<li>哈希能对信息进行加密处理，使得数据传播更为安全。</li>
</ul>
<h3 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode?"></a>为什么要有 hashCode?</h3><p>hashcode能够使得集合具有很好的对象检索性能</p>
<p>以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</p>
<p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来寻找对应的一块内存区域，如果该区域没有元素，即没有对象与该对象hashcode相等，就加入该对象；如果有hashcode相等的对象，则再调用equals方法判断对象是否相同，相同就不加入，不同就加入这片内存区域。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<p>总结：先计算hashcode -&gt; hashcode不等则加入，hashcode相等再调用equals -&gt; equals相同则不加入，equals不同则加入</p>
<h3 id="hashCode-，equals-两种方法是什么关系"><a href="#hashCode-，equals-两种方法是什么关系" class="headerlink" title="hashCode()，equals()两种方法是什么关系?"></a>hashCode()，equals()两种方法是什么关系?</h3><p>根据上一题的描述，这里能够得出这些结论</p>
<p>如果两个对象 hashCode 相等，他们不一定 equals。</p>
<p>如果两个对象 hashCode 不相等，他们一定不 equals</p>
<p>如果两个对象 equals， hashCode 一定相等。</p>
<p>如果两个对象不 equals，他们的 hashCode 有可能相等。</p>
<p>补充：关于 equals() 和 hashCode() 的重要规范</p>
<ul>
<li><strong>若重写 equals() 方法，有必要重写 hashcode()方法</strong>，确保通过 equals()方法判断结果为true 的两个对象具备相等的 hashcode() 方法返回值。说得简单点就是：“如果两个对象相同，那么他们的 hashCode 应该相等”。不过请注意：这个只是规范，如果非要写一个类让 equals() 方法返回 true 而 hashCode() 方法返回两个不相等的值，编译和运行都是不会报错的。不过这样违反了Java 规范，程序也就埋下了 BUG。</li>
<li>如果 equals() 方法返回 false，即两个对象“不相同”，并不要求对这两个对象调用hashCode() 方法得到两个不相同的数。说的简单点就是：“如果两个对象不相同，他们的hashCode 可能相同”。</li>
</ul>
<h3 id="为什么重写-equals-方法必须重写-hashcode-方法-？"><a href="#为什么重写-equals-方法必须重写-hashcode-方法-？" class="headerlink" title="为什么重写 equals 方法必须重写 hashcode 方法 ？"></a>为什么重写 equals 方法必须重写 hashcode 方法 ？</h3><p>因为Hash比equals方法的开销要小，速度更快，所以在涉及到hashcode的容器中（比如HashSet），判断自己是否持有该对象时，会先检查hashCode是否相等，如果hashCode不相等，就会直接认为不相等，并存入容器中，不会再调用equals进行比较。这样就会导致，如果该对象已经存在HashSet中，但是因为hashCode不同，还会再次被存入。即导致相同的对象散列到不同的位置而造成对象的不能覆盖的问题。</p>
<p><strong>因此要重写hashCode保证：如果equals判断是相等的，那hashCode值也要相等</strong></p>
<h3 id="常见的Object方法"><a href="#常见的Object方法" class="headerlink" title="常见的Object方法"></a>常见的Object方法</h3><p>Object clone() ：创建与该对象的类相同的新对象</p>
<p>boolean equals(Object) ：比较两对象是否相等</p>
<p>void finalize() ：当垃圾回收器确定不存在对该对象的更多引用时，对象垃圾回收器调用该方法</p>
<p>Class getClass() ：返回一个对象运行时的实例类</p>
<p>int hashCode() ：返回该对象的散列码值</p>
<p>void notify() ：唤醒等待在该对象的监视器上的一个线程</p>
<p>void notifyAll() ：唤醒等待在该对象的监视器上的全部线程</p>
<p>String toString() ：返回该对象的字符串表示</p>
<p>void wait() ：在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是java的反射机制？"><a href="#什么是java的反射机制？" class="headerlink" title="什么是java的反射机制？"></a>什么是java的反射机制？</h3><p>反射是<strong>动态获取信息</strong>以及<strong>动态调用对象方法</strong>的一种机制。</p>
<p>Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。而这也是Java被视为动态语言的一个关键性质。</p>
<p>Java反射的功能是在运行时判断任意一个对象所属的类，在运行时构造任意一个类的对象，在运行时判断任意一个类所具有的成员变量和方法，在运行时调用任意一个对象的方法，生成动态代理。</p>
<h3 id="为什么引入反射概念？反射机制的应用有哪些？"><a href="#为什么引入反射概念？反射机制的应用有哪些？" class="headerlink" title="为什么引入反射概念？反射机制的应用有哪些？"></a>为什么引入反射概念？反射机制的应用有哪些？</h3><p>从 Oracle 官方文档中可以看出，反射主要应用在以下几方面：</p>
<ul>
<li>反射让开发人员可以通过外部类的全路径名创建对象，并使用这些类，实现一些扩展的功能。</li>
<li>反射让开发人员可以枚举出类的全部成员，包括构造函数、属性、方法。以帮助开发者写出正确的代码。</li>
<li>测试时可以利用反射 API 访问类的私有成员，以保证测试代码覆盖率。</li>
</ul>
<p>比如：JDBC 的数据库的连接、Spring 框架</p>
<h3 id="反射机制的优缺点有哪些？"><a href="#反射机制的优缺点有哪些？" class="headerlink" title="反射机制的优缺点有哪些？"></a>反射机制的优缺点有哪些？</h3><p>优点：能够运行时动态获取类的实例，提高灵活性；可与动态编译结合</p>
<p>缺点：使用反射性能较低，需要解析字节码，将内存中的对象进行解析。其解决方案是：通过setAccessible(true)关闭JDK的安全检查来提升反射速度；多次创建一个类的实例时，有缓存会快很多；ReflflectASM工具类，通过字节码生成的方式加快反射速度。</p>
<h3 id="如何获取反射中的运行时类-x2F-如何获取Class对象？"><a href="#如何获取反射中的运行时类-x2F-如何获取Class对象？" class="headerlink" title="如何获取反射中的运行时类&#x2F;如何获取Class对象？"></a>如何获取反射中的运行时类&#x2F;如何获取Class对象？</h3><ul>
<li>Class.forName(“类的路径”)；当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。（常用）</li>
<li>类名.class。这种方法只适合在编译前就知道操作的 Class。</li>
<li>对象名.getClass()。</li>
<li>如果是基本类型的包装类，可以调用包装类的Type属性来获得该包装类的Class对象。</li>
</ul>
<p>地址相同，加载到内存中的运行时类，会缓存一定的时间，同一个运行时类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Person.class;<br><span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> p1.getClass();<br><span class="hljs-type">Class</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;Person&quot;</span>);<br>System.out.println(c1 == c2);  <span class="hljs-comment">//true</span><br>System.out.println(c1 == c3);  <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>



<h3 id="反射使用的步骤？"><a href="#反射使用的步骤？" class="headerlink" title="反射使用的步骤？"></a>反射使用的步骤？</h3><ul>
<li><p>获取想要操作的运行时类<code>clazz</code></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.itheima.Person&quot;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>获取类之后需要创建运行时类的对象（实例），区别于用new去创建对象，运行时类创建对象使用方法：<code>clazz.newInstance()</code>，在Java9之后更推荐先创建其构造器，再创建实例，即<code>clazz.getDeclaredConstructor().-newInstance()</code></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> clazz.newInstance();<br><span class="hljs-comment">// Object person = clazz.getDeclaredConstructor().newInstance()</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>调用不同的反射API 获取或设置想要的类信息。比如成员变量属性值、成员方法</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> clazz.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>name.set(person,<span class="hljs-string">&quot;Tom&quot;</span>);<br><span class="hljs-comment">// 注意想要调用方法时需要使用`Method.invoke()`方法，参数1：方法的调用者  参数2：给方法形参赋值的实参,invoke()的返回值即为对应类中调用的方法的返回值。如果是静态方法，因为没有实例，所以直接给invoke函数传入运行时类即可，或者传入null</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">show</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;show&quot;</span>, String.class);<br>show.invoke(person, <span class="hljs-string">&quot;北京&quot;</span>);<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="创建运行时类的对象的前提是什么？"><a href="#创建运行时类的对象的前提是什么？" class="headerlink" title="创建运行时类的对象的前提是什么？"></a>创建运行时类的对象的前提是什么？</h3><p>运行时类必须提供空参的构造器，并且访问权限得够。通常，设置为<strong>public</strong>。否则调用<code>clazz.newInstance()</code>无法创建对象</p>
<h3 id="为什么java-bean中要求提供一个public的空参构造器"><a href="#为什么java-bean中要求提供一个public的空参构造器" class="headerlink" title="为什么java bean中要求提供一个public的空参构造器"></a>为什么java bean中要求提供一个public的空参构造器</h3><ul>
<li>便于通过反射，创建运行时类的对象</li>
<li>便于子类继承此运行时类时，默认调用super()时，保证父类有此构造器</li>
</ul>
<h3 id="Java反射API有几类？"><a href="#Java反射API有几类？" class="headerlink" title="Java反射API有几类？"></a>Java反射API有几类？</h3><p>反射 API 用来生成 JVM 中的类、接口或则对象的信息。</p>
<ul>
<li>Class 类：反射的核心类，可以获取类的属性，方法等信息。例如<code>public final native Class&lt;?&gt; getClass();</code></li>
<li>Field 类：Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。例如<code>public Field getDeclaredField()</code></li>
<li>Method 类：Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。例如<code>public Method getDeclaredMethod()</code></li>
<li>Constructor 类：Java.lang.reflec 包中的类，表示类的构造方法。例如<code>public Constructor&lt;T&gt; getDeclared-Constructor()</code></li>
</ul>
<h3 id="反射机制的原理是什么？"><a href="#反射机制的原理是什么？" class="headerlink" title="反射机制的原理是什么？"></a>反射机制的原理是什么？</h3><p>有点复杂，如果问到再看</p>
<h3 id="什么是动态代理？"><a href="#什么是动态代理？" class="headerlink" title="什么是动态代理？"></a>什么是动态代理？</h3><p>动态代理就是，在<strong>程序运行期</strong>，创建目标对象的代理对象，并<strong>对目标对象中的方法进行功能性增强</strong>的一种技术。在生成代理对象的过程中，目标对象不变，代理对象中的方法是目标对象方法的增强方法。可以理解为<strong>运行期间，对象中方法的动态拦截，在拦截方法的前后执行功能操作</strong>。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="Java中的泛型是什么"><a href="#Java中的泛型是什么" class="headerlink" title="Java中的泛型是什么 ?"></a>Java中的泛型是什么 ?</h3><p>泛型就是将类型参数化，其在编译时才确定具体的参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。</p>
<p>泛型是一种语法糖，泛型这种语法糖的基本原理是类型擦除（使用泛型的时候加上的类型参数，编译器在编译的时候去掉类型参数）。Java中的泛型基本上都是在编译器这个层次来实现的，也就是说：泛型只存在于编译阶段，而不存在于运行阶段。在编译后的 class 文件中，是没有泛型这个概念的。</p>
<h3 id="使用泛型的好处是什么"><a href="#使用泛型的好处是什么" class="headerlink" title="使用泛型的好处是什么?"></a>使用泛型的好处是什么?</h3><p>没有泛型时，使用 Object 来实现通用、不同类型的处理，每次使用时都需要强制转换成想要的类型，在编译时编译器并不知道类型转换是否正常，运行时才知道，不安全</p>
<p>所以泛型的好处有：</p>
<ul>
<li>类型安全：泛型的主要目标是提高 Java 程序的类型安全，编译时期就可以检查出因 Java 类型不正确导致的 ClassCastException 异常，符合越早出错代价越小原则</li>
<li>消除强制类型转换：使用时直接得到目标类型，消除许多强制类型转换</li>
</ul>
<h3 id="什么是泛型擦除？"><a href="#什么是泛型擦除？" class="headerlink" title="什么是泛型擦除？"></a>什么是泛型擦除？</h3><p>Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>	ArrayList&lt;Integer&gt; arrayList1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>	ArrayList&lt;String&gt; arrayList2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>	System.out.println(arrayList1.getClass() == arrayList2.getClass());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<p>可以看到ArrayList<Integer> 和ArrayList<String> 的原始类型是相同，在编译成字节码文件后都会变成List ，JVM看到的只有List ，看不到泛型信息，这就是泛型的类型擦除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>	ArrayList&lt;Integer&gt; arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>	arrayList.add(<span class="hljs-number">1</span>);<br>	arrayList.getClass().getMethod(<span class="hljs-string">&quot;add&quot;</span>,Object.class).invoke(arrayList, <span class="hljs-string">&quot;a&quot;</span>);<br>	System.out.println(arrayList.get(<span class="hljs-number">0</span>));<br>	System.out.println(arrayList.get(<span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">1</span><br><span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure>

<p>可以看到通过反射进行add 操作， ArrayList<Integer> 竟然可以存储字符串，这是因为在反射就是在运行期调用的add 方法，在<strong>运行期泛型信息已经被擦除</strong>。</p>
<p>既然存在类型擦除，那么Java是如何保证在ArrayList<Integer> 添加字符串会报错呢？Java编译器是通过先检查代码中泛型的类型，然后再进行类型擦除，再进行编译。</p>
<h3 id="什么是泛型中的限定通配符和非限定通配符"><a href="#什么是泛型中的限定通配符和非限定通配符" class="headerlink" title="什么是泛型中的限定通配符和非限定通配符 ?"></a>什么是泛型中的限定通配符和非限定通配符 ?</h3><p>限定通配符对类型进行了限制。有两种限定通配符，一种是<code>&lt;? extends T&gt;</code>它通过确保类型必须是T的子类来设定类型的<strong>上界</strong>，另一种是<code>&lt;? super T&gt;</code>它通过确保类型必须是T的父类来设定类型的<strong>下界</strong>。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误</p>
<p>非限定通配符 ？,可以用任意类型来替代。如List&lt;?&gt; 的意思是这个集合是一个可以持有任意类型的集合，它可以是List<A> ，也可以是List<B> ,或者List<C> 等等</p>
<h3 id="List可以转成List-吗"><a href="#List可以转成List-吗" class="headerlink" title="List可以转成List 吗"></a>List<String>可以转成List <Object>吗</h3><p>不可以，二者无法互相转换。真这样做的话会导致编译错误。因为List <Object>可以存储任何类型的对象包括String, Integer等等，而List<String>却只能用来存储String。</p>
<h3 id="判断ArrayList与ArrayList的运行时类是否相等？"><a href="#判断ArrayList与ArrayList的运行时类是否相等？" class="headerlink" title="判断ArrayList与ArrayList的运行时类是否相等？"></a>判断ArrayList<String>与ArrayList<Integer>的运行时类是否相等？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java">ArrayList&lt;String&gt; a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>ArrayList&lt;Integer&gt; b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br><span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> a.getClass();<br><span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> b.getClass();<br>System.out.println(c1 == c2); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>输出的结果是 true。因为无论对于 ArrayList 还是 ArrayList，它们的 Class 类型都是一直的，都是ArrayList.class。</p>
<p>那它们声明时指定的 String 和 Integer 到底体现在哪里呢？答案是体现在类编译的时候。当 JVM 进行类编译时，会进行泛型检查，如果一个集合被声明为 String类型，那么它往该集合存取数据的时候就会对数据进行判断，从而避免存入或取出错误的数据。</p>
<h3 id="Array中可以用泛型吗"><a href="#Array中可以用泛型吗" class="headerlink" title="Array中可以用泛型吗?"></a>Array中可以用泛型吗?</h3><p>不可以。这也是为什么《Effective Java》一书中建议使用 List 来代替 Array，因为 List可以提供编译期的类型安全保证，而 Array 却不能。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="Java的异常体系，Error和Exception的区别，运行时异常一般异常区别"><a href="#Java的异常体系，Error和Exception的区别，运行时异常一般异常区别" class="headerlink" title="Java的异常体系，Error和Exception的区别，运行时异常一般异常区别"></a>Java的异常体系，Error和Exception的区别，运行时异常一般异常区别</h3><p>Throwable（表示可抛出）是所有异常和错误的超类，两个直接子类为Error和Exception，分别表示错误和异常。异常又可分为运行时异常（不检查异常）和非运行时异常（检查异常）。</p>
<p><strong>Error</strong>是程序<strong>无法处理</strong>的错误，是由JVM产生和抛出的。例如，系统崩溃，内存不足(OutOfMemoryError)，堆栈溢出（StackOverFlowError）等，编译器不会对这类错误进行检测，一旦这类错误发生，通常应用程序会被终止（JVM会选择<strong>线程终止</strong>），仅靠应用程序本身无法恢复。Error发生时我们没办法通过 catch 来进行捕获 。</p>
<p>Exception是程序可以处理的异常，可以通过 catch 来进行捕获，通常遇到这种错误，应当在程序中尽可能去处理这些异常，使应用程序可以继续正常运行。</p>
<p>Exception 又可以分为：</p>
<ul>
<li>运行时异常（ RuntimeException，非受检查异常）：包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常，即使出现运行时异常，编译也会通过。例如：空指针异常、数组越界异常等。程序中<strong>可以选择捕获处理，也可以不处理</strong>。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</li>
<li>非运行时异常（编译时异常、受检查异常） ：是Exception 中除 RuntimeException 及其子类之外的异常。例如IO 相关的异常、ClassNotFoundException 、SQLException 等 。编译器要求必须处置的异常，<strong>如果不处理，程序就不能编译通过</strong>。</li>
</ul>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/JavaSE-%E5%BC%82%E5%B8%B8%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="image-20220402214427811"></p>
<h3 id="throw-和-throws-的区别是什么？"><a href="#throw-和-throws-的区别是什么？" class="headerlink" title="throw 和 throws 的区别是什么？"></a>throw 和 throws 的区别是什么？</h3><p>throw关键字用于<strong>方法体内部</strong>，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。如果<strong>抛出了检查异常，则应该在方法头部声明方法可能抛出的异常类型</strong>，该方法的调用者必须处理或继续抛出异常。如果<strong>所有方法都层层上抛获取的异常，最终JVM会进行处理</strong>，处理方式就是打印异常消息和堆栈信息。</p>
<p> throws关键字用于<strong>方法上（方法名后面）的方法声明部分</strong>，可以抛出多个异常，用来标识该方法可能抛出的异常列表。调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常</p>
<h3 id="Java常见异常有哪些？"><a href="#Java常见异常有哪些？" class="headerlink" title="Java常见异常有哪些？"></a>Java常见异常有哪些？</h3><ul>
<li>java.lang.IllegalAccessError：违法访问错误。</li>
<li>java.lang.InstantiationError：实例化错误。</li>
<li>java.lang.OutOfMemoryError：内存不足错误。</li>
<li>java.lang.StackOverflowError：堆栈溢出错误。</li>
<li>java.lang.ClassCastException：类造型异常。</li>
<li>java.lang.ClassNotFoundException：找不到类异常。</li>
<li>java.lang.ArithmeticException：算术条件异常。</li>
<li>java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。</li>
<li>java.lang.IndexOutOfBoundsException：索引越界异常。</li>
<li>java.lang.InstantiationException：实例化异常。</li>
<li>java.lang.NoSuchFieldException：属性不存在异常。</li>
<li>java.lang.NoSuchMethodException：方法不存在异常。</li>
<li>java.lang.NullPointerException：空指针异常。</li>
<li>java.lang.NumberFormatException：数字格式异常。</li>
<li>java.lang.StringIndexOutOfBoundsException：字符串索引越界异常。</li>
</ul>
<h3 id="try-catch-finally-中哪个部分可以省略？每个部分可以访问其他部分的变量嘛？多个catch会匹配几个？"><a href="#try-catch-finally-中哪个部分可以省略？每个部分可以访问其他部分的变量嘛？多个catch会匹配几个？" class="headerlink" title="try-catch-finally 中哪个部分可以省略？每个部分可以访问其他部分的变量嘛？多个catch会匹配几个？"></a>try-catch-finally 中哪个部分可以省略？每个部分可以访问其他部分的变量嘛？多个catch会匹配几个？</h3><p>可以省略catch或者finally。catch和finally不可以同时省略。组成try…catch…finally、try…catch、try…finally三种结构。<strong>catch可以有一个或多个</strong>，<strong>finally最多一个</strong>。</p>
<p>一旦对一段代码加上try，就等于显式地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理，</p>
<p>如果处理运行时异常，不加catch是可以的，加了也可以，然后必须要用finally收尾处理</p>
<p>如果要处理编译时异常，则必须加catch，finally不加可以</p>
<p>try、catch、finally三个代码块中<strong>变量的作用域为代码块内部</strong>，分别独立而不能相互访问。如果要在三个块中都可以访问，则需要将变量定义到这些块的外面。</p>
<p>多个catch块时候，<strong>最多只会匹配其中一个异常类且只会执行该catch块代码</strong>，而不会再执行其它的catch块，且匹配catch语句的顺序为从上到下，也可能所有的catch都没执行</p>
<h3 id="什么情形下，finally代码块不会执行？"><a href="#什么情形下，finally代码块不会执行？" class="headerlink" title="什么情形下，finally代码块不会执行？"></a>什么情形下，finally代码块不会执行？</h3><ul>
<li>没有进入try代码块；</li>
<li>System.exit()强制退出程序；</li>
<li>守护线程被终止；</li>
</ul>
<h3 id="try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h3><p>会执行，首先，整个程序真正的返回之前必须执行finally代码块，即在try或catch中的return语句<strong>执行之后返回之前</strong>执行，对结果的影响要分情况讨论</p>
<ul>
<li><p>finally中如果有return，它肯定会覆盖try或者catch中的返回值，最终返回的就是finally里面return的结果</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">try</span> &#123;a=<span class="hljs-number">1</span>; <span class="hljs-keyword">return</span> a+<span class="hljs-number">1</span>;&#125;<br><span class="hljs-keyword">finally</span>&#123;<span class="hljs-keyword">return</span> a&#125;; <span class="hljs-comment">// 1,因为会执行finally中的return</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>finally中如果没有return语句：</p>
<ul>
<li><p>如果返回值是<strong>基本数据类型</strong>，finally中对返回值的改变不会影响返回值。因为在return前已经将返回值存储在栈中了。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">catch</span>(...)&#123;a=<span class="hljs-number">1</span>; <span class="hljs-keyword">return</span> a;&#125; <br><span class="hljs-keyword">finally</span>&#123;a=<span class="hljs-number">2</span>&#125; <span class="hljs-comment">//结果 1，因为catch中已经是return 1了，之后finally把a改成2对结果没影响</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>如果返回值是<strong>引用数据类型</strong>，finally块中对返回值的改变会影响返回值。因为在return之前已经将引用对象的地址存储在栈中，finally块中对于引用对象值的改变会影响到返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;A&quot;</span>);<br><span class="hljs-keyword">try</span> &#123; <span class="hljs-type">int</span> i=<span class="hljs-number">5</span>/<span class="hljs-number">0</span>; <span class="hljs-keyword">return</span> result;&#125; <br><span class="hljs-keyword">catch</span> (Exception e) &#123;<span class="hljs-keyword">return</span> result;&#125; <span class="hljs-comment">// 返回&quot;AB&quot;</span><br><span class="hljs-keyword">finally</span> &#123;result.append(<span class="hljs-string">&quot;B&quot;</span>);&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>  关于return语句，看一下你类的class字节码文件就知道了。 return的时候是复制了一个变量然后返回，所以之后finally操作的变量如果是基本类型的话不会影响返回值。 但是如果返回值是引用类型的话，因为指向同一个对象所以还是有影响的。</p>
</li>
</ul>
<h3 id="JVM-是如何处理异常的？"><a href="#JVM-是如何处理异常的？" class="headerlink" title="JVM 是如何处理异常的？"></a>JVM 是如何处理异常的？</h3><p>在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。<strong>创建异常对象并转交给 JVM 的过程称为抛出异常</strong>。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</p>
<p><strong>JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码</strong>。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给<strong>默认的异常处理器</strong>（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息<strong>并终止应用程序</strong>。</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>Annotation 注解可以看成是java中的一种标记记号，用来给java中的类，成员，方法，参数等任何程序元素添加一些额外的说明信息，同时不改变程序语义。注解可以分为三类：基本注解，元注解，自定义注解</p>
<ul>
<li><p>标准注解</p>
<ul>
<li>@Deprecated：该注解用来说明程序中的某个元素（类，方法，成员变量等）已经不再使用，如果使用的话的编译器会给出警告。</li>
<li>@SuppressWarnings(value&#x3D;“”)：用来抑制各种可能出现的警告。</li>
<li>@Override：用来说明子类方法覆盖了父类的方法，保护覆盖方法的正确使用</li>
</ul>
</li>
<li><p>元注解</p>
<p>  （元注解也称为元数据注解，是对注解进行标注的注解，元注解更像是一种对注解的规范说明，用来对定义的注解进行行为的限定。例如说明注解的生存周期，注解的作用范围等）</p>
<ul>
<li>@Target(value&#x3D;“ ”)：该注解是用来限制注解的使用范围的，即该注解可以用于哪些程序元素。</li>
<li>@Retention(value&#x3D;“ ”)：用于说明注解的生存周期</li>
<li>@Documnent：用来说明指定被修饰的注解可以被javadoc.exe工具提取进入文档中，所有使用了该注解进行标注的类在生成API文档时都在包含该注解的说明。</li>
<li>@Inherited：用来说明使用了该注解的父类，其子类会自动继承该注解。</li>
<li>@Repeatable：java1.8新出的元注解，如果需要在给程序元素使用相同类型的注解，则需将该注解标注上。</li>
</ul>
</li>
<li><p>自定义注解：用@Interface来声明注解。</p>
</li>
</ul>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="Java序列化与反序列化是什么？"><a href="#Java序列化与反序列化是什么？" class="headerlink" title="Java序列化与反序列化是什么？"></a>Java序列化与反序列化是什么？</h3><ul>
<li>序列化：序列化是把对象转换成有序<strong>字节流</strong>，以便在网络上传输或者保存在本地文件中。核心作用是对象状态的<strong>保存</strong>。</li>
<li>反序列化：客户端从文件中或网络上获得序列化后的对象字节流，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。核心作用是对象的<strong>重建</strong></li>
</ul>
<h3 id="为什么需要序列化与反序列化？"><a href="#为什么需要序列化与反序列化？" class="headerlink" title="为什么需要序列化与反序列化？"></a>为什么需要序列化与反序列化？</h3><p>简要描述：对内存中的对象进行持久化或网络传输, 这个时候都需要序列化和反序列化</p>
<p>深入描述：</p>
<ul>
<li>对象序列化可以实现分布式对象。</li>
<li>java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。</li>
<li>序列化可以将内存中的类写入文件或数据库中。</li>
<li>对象、文件、数据，有许多不同的格式，很难统一传输和保存。</li>
</ul>
<h3 id="Serializable接口中serialVersionUID的作用？"><a href="#Serializable接口中serialVersionUID的作用？" class="headerlink" title="Serializable接口中serialVersionUID的作用？"></a>Serializable接口中serialVersionUID的作用？</h3><p>在序列化的时候系统将serialVersionUID写入到序列化的文件中去，当反序列化的时候系统会先去检测文件中的serialVersionUID是否跟当前类的serialVersionUID是否一致，如果一致则反序列化成功，否则就说明当前类跟序列化后的类发生了变化，比如是成员变量的数量或者是类型发生了变化，那么在反序列化时就会发生crash，并且报错。</p>
<h3 id="序列化实现的方式有哪些？"><a href="#序列化实现的方式有哪些？" class="headerlink" title="序列化实现的方式有哪些？"></a>序列化实现的方式有哪些？</h3><p>实现Serializable接口或者Externalizable接口。</p>
<ul>
<li><p>Serializable接口：类通过实现 java.io.Serializable 接口以启用其序列化功能。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段，仅用于标识可序列化的语义。</p>
</li>
<li><p>Externalizable接口：Externalizable 继承自Serializable ，该接口中定义了两个抽象方法： writeExternal() 与readExternal() 。当使用Externalizable 接口来进行序列化与反序列化的时候需要开发人员重写writeExternal() 与readExternal() 方法。否则所有变量的值都会变成默认值。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>实现Serializable接口</th>
<th>实现Externalizable接口</th>
</tr>
</thead>
<tbody><tr>
<td>系统自动存储必要的信息</td>
<td>程序员决定存储哪些信息</td>
</tr>
<tr>
<td>Java内建支持，易于实现，只需要实现该接口即可，无需任何代码支持</td>
<td>必须实现接口内的两个方法</td>
</tr>
<tr>
<td>性能略差</td>
<td>性能略好</td>
</tr>
</tbody></table>
<h3 id="什么是serialVersionUID？为什么还要显示指定serialVersionUID的值"><a href="#什么是serialVersionUID？为什么还要显示指定serialVersionUID的值" class="headerlink" title="什么是serialVersionUID？为什么还要显示指定serialVersionUID的值?"></a>什么是serialVersionUID？为什么还要显示指定serialVersionUID的值?</h3><p>serialVersionUID 用来表明类的不同版本间的兼容性。Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。</p>
<p>在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常</p>
<p>serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容。如果类没有显示定义这个静态常量，它的值是JVM根据类的内部细节自动生成的。若类的实例变量做了修改（比如该类增加了一个属性），serialVersionUID可能发生变化。故建议，显式声明。简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常</p>
<p>在实际开发中, 不显示指定serialVersionUID的情况会导致什么问题? 如果我们的类写完后不再修改, 那当然不会有问题, 但这在实际开发中是不可能的, 我们的类会不断迭代, 一旦类被修改了, 那旧对象反序列化就会报错. 所以在实际开发中, 我们都会显示指定一个serialVersionUID, 值是多少无所谓, 只要不变就行。</p>
<h3 id="serialVersionUID什么时候修改？"><a href="#serialVersionUID什么时候修改？" class="headerlink" title="serialVersionUID什么时候修改？"></a>serialVersionUID什么时候修改？</h3><blockquote>
<p>10〖强制〗序列化类新增属性时，请不要修改seriatversionUID字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改serialVersionUID值。</p>
<p>说明：注意se1iatversionUID不一致会抛出序列化运行时异常。</p>
</blockquote>
<h3 id="Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="Java 序列化中如果有些字段不想进行序列化，怎么办？"></a>Java 序列化中如果有些字段不想进行序列化，怎么办？</h3><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p>
<p>transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后， transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。<strong>transient 只能修饰变量，不能修饰类和方法。</strong></p>
<h3 id="静态变量会被序列化吗"><a href="#静态变量会被序列化吗" class="headerlink" title="静态变量会被序列化吗?"></a>静态变量会被序列化吗?</h3><p>不会。因为序列化是针对对象而言的, 而静态变量优先于对象存在, 随着类的加载而加载, 所以不会被序列化.</p>
<p>看到这个结论, 是不是有人会问, serialVersionUID也被static修饰, 为什么serialVersionUID会被序列化?</p>
<p>其实serialVersionUID属性并没有被序列化, JVM在序列化对象时会自动生成一个serialVersionUID, 然后将我们显示指定的serialVersionUID属性值赋给自动生成的serialVersionUID。</p>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="Java的IO-流分为几种？"><a href="#Java的IO-流分为几种？" class="headerlink" title="Java的IO 流分为几种？"></a>Java的IO 流分为几种？</h3><ul>
<li><p>按照流的方向：输入流（inputStream）和输出流（outputStream）；</p>
</li>
<li><p>按照实现功能分：节点流（可以从或向一个特定的地方读写数据，如 FileReader）和处理流（是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写， BufferedReader）；</p>
</li>
<li><p>按照处理数据的单位：有四个抽象类组成，分为字节流（InputStream，OutputStream）和字符流（Reader，Writer）。Java中其他多种多样变化的流均是由它们派生出来的。</p>
</li>
</ul>
<h3 id="字符流与字节流的区别？"><a href="#字符流与字节流的区别？" class="headerlink" title="字符流与字节流的区别？"></a>字符流与字节流的区别？</h3><p>字节流适合所有类型文件的数据传输，因为计算机字节（Byte）是电脑中表示信息含义的最小单位。</p>
<p>字符流只能够处理纯文本数据，其他类型数据不行，但是字符流处理文本要比字节流处理文本要方便。</p>
<p>在读写文件需要对内容按行处理，比如比较特定字符，处理某一行数据的时候一般会选择字符流。只是读写文件，和文件内容无关时，一般选择字节流。</p>
<h3 id="字节流如何转为字符流？"><a href="#字节流如何转为字符流？" class="headerlink" title="字节流如何转为字符流？"></a>字节流如何转为字符流？</h3><p>字节输入流转字符输入流通过 InputStreamReader 实现，字节输出流转字符输出流通过 OutputStreamWriter 实现</p>
<h3 id="什么是阻塞IO？什么是非阻塞IO？"><a href="#什么是阻塞IO？什么是非阻塞IO？" class="headerlink" title="什么是阻塞IO？什么是非阻塞IO？"></a>什么是阻塞IO？什么是非阻塞IO？</h3><p>IO操作包括：对硬盘的读写、对socket的读写以及外设的读写。</p>
<p>当用户线程发起一个IO请求操作（本文以读请求操作为例），包括两个阶段：查看数据是否就绪、进行数据拷贝</p>
<p>阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于第一个阶段，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪，而不是一直在那里等待</p>
<p>Java中传统的IO都是阻塞IO</p>
<h3 id="BIO、NIO、AIO的区别？"><a href="#BIO、NIO、AIO的区别？" class="headerlink" title="BIO、NIO、AIO的区别？"></a>BIO、NIO、AIO的区别？</h3><ul>
<li>BIO：<strong>同步并阻塞</strong>，在服务器中实现的模式为<strong>一个连接一个线程</strong>。也就是说，客户端有连接请求的时候，服务器就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然这也可以通过线程池机制改善。<strong>BIO一般适用于连接数目小且固定的架构</strong>，这种方式对于服务器资源要求比较高，而且并发局限于应用中，是JDK1.4之前的唯一选择，但好在程序直观简单，易理解。</li>
<li>NIO：<strong>同步并非阻塞</strong>，在服务器中实现的模式为<strong>一个请求一个线程</strong>，也就是说，客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到<strong>有连接IO请求时才会启动一个线程进行处理</strong>。<strong>NIO一般适用于连接数目多且连接比较短（轻操作）的架构</strong>，并发局限于应用中，编程比较复杂，从JDK1.4开始支持。</li>
<li>AIO：<strong>异步并非阻塞</strong>，在服务器中实现的模式为<strong>一个有效请求一个线程</strong>，也就是说，客户端的IO请求都是通过<strong>操作系统先完成</strong>之后，再通知服务器应用去启动线程进行处理。<strong>AIO一般适用于连接数目多且连接比较长（重操作）的架构</strong>，充分调用操作系统参与并发操作，编程比较复杂，从JDK1.7开始支持。</li>
</ul>
<p>BIO ：来到厨房，开始烧水NIO，并坐在水壶面前一直等着水烧开。</p>
<p>NIO：来到厨房，开AIO始烧水，但是我们不一直坐在水壶前面等，而是做些其他事，然后每隔几分钟到厨房看一下水有没有烧开。</p>
<p>AIO：来到厨房，开始烧水，我们不一直坐在水壶前面等，而是在水壶上面装个开关，水烧开之后它会通知我。</p>
<h3 id="Java-IO都有哪些设计模式？"><a href="#Java-IO都有哪些设计模式？" class="headerlink" title="Java IO都有哪些设计模式？"></a>Java IO都有哪些设计模式？</h3><p>暂略</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符型常量和字符串常量的区别？"><a href="#字符型常量和字符串常量的区别？" class="headerlink" title="字符型常量和字符串常量的区别？"></a>字符型常量和字符串常量的区别？</h3><ul>
<li>形式上：字符常量是单引号引起的一个字符，字符串常量是双引号引起的若干个字符；</li>
<li>含义上：字符常量相当于一个整型值( ASCII 值)，可以参加表达式运算；字符串常量代表一个地址值（该字符串在内存中存放位置），相当于对象；</li>
<li>内存上：字符常量只占2个字节；字符串常量占若干个字节(至少一个字符结束标志)</li>
</ul>
<h3 id="什么是字符串常量池？"><a href="#什么是字符串常量池？" class="headerlink" title="什么是字符串常量池？"></a>什么是字符串常量池？</h3><p>java中常量池的概念主要有四个： 全局字符串常量池， class文件常量池， 运行时常量池，基本类型包装类对象常量池。我们现在所说的就是全局字符串常量池</p>
<p>字符串作为最常用也是最基础的引用数据类型，jvm为了提升性能和减少内存开销，避免字符的重复创建，其维护了一块特殊的内存空间，即字符串池（StringTable），当需要使用字符串时，先去字符串池中查看该字符串是否已经存在，如果存在，则可以直接使用，如果不存在，初始化，并将该字符串放入字符串常量池中。</p>
<p>字符串常量池的位置也是随着jdk版本的不同而位置不同。在jdk6中，常量池的位置在永久代（方法区）中，此时常量池中存储的是对象。在jdk7中，常量池的位置在堆中，此时，常量池存储的就是引用了。在jdk8中，永久代（方法区）被元空间取代了。</p>
<h3 id="字符串常量池的好处"><a href="#字符串常量池的好处" class="headerlink" title="字符串常量池的好处"></a>字符串常量池的好处</h3><p>避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享，在编译阶段就把所有的字符串文字放到一个常量池中。</p>
<ul>
<li>节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。</li>
<li>节省运行时间：比较字符串时，&#x3D;&#x3D;比equals()快。对于两个引用变量，只用&#x3D;&#x3D;判断引用是否相等，也就可以判断实际值是否相等。</li>
</ul>
<h3 id="String-str-x3D-”abc”与-String-str-x3D-new-String-“abc”-一样吗？new-String-“abc”-创建了几个对象"><a href="#String-str-x3D-”abc”与-String-str-x3D-new-String-“abc”-一样吗？new-String-“abc”-创建了几个对象" class="headerlink" title="String str&#x3D;”abc”与 String str&#x3D;new String(“abc”)一样吗？new String(“abc”)创建了几个对象?"></a>String str&#x3D;”abc”与 String str&#x3D;new String(“abc”)一样吗？new String(“abc”)创建了几个对象?</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;              <span class="hljs-comment">// 方式一</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);  <span class="hljs-comment">// 方式二</span><br></code></pre></td></tr></table></figure>

<p>字符串常用实例化有两种方式：</p>
<p>方式一：通过字面量定义的方式，将字符串常量<code>&quot;abc&quot;</code>存储在字符串常量池，目的是共享。</p>
<p>方式二：通过new + 构造器的方式，创建了一个字符串对象存储在堆中，堆中的对象又有一个value的字段，其指向常量池中的字符串（如果串池中没有的话，就新建一个）</p>
<p>所以new String(“abc”)创建了两个对象</p>
<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/String%E5%AE%9E%E4%BE%8B%E5%8C%96.png" srcset="/img/loading.gif" lazyload alt="String实例化" style="zoom:67%;" />



<h3 id="String有哪些特性"><a href="#String有哪些特性" class="headerlink" title="String有哪些特性?"></a>String有哪些特性?</h3><ul>
<li>不可变性：String 是只读字符串，是一个典型的不可变对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。比如将一个字符串“ab”改为“abc”，不是在原内存地址上修改“ab”，而是将变量重新指向一个新对象“abc”</li>
<li>常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用；</li>
<li>final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</li>
</ul>
<h3 id="String类为什么要用final修饰？"><a href="#String类为什么要用final修饰？" class="headerlink" title="String类为什么要用final修饰？"></a>String类为什么要用final修饰？</h3><p>String的源码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> implements...&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] value;<br>    ....<br>&#125;<br></code></pre></td></tr></table></figure>

<p>将String用final修饰是为了确保String不可继承，这意味着不允许任何人定义String的子类。换言之，如果有一个String的引用，它引用的一定是一个String对象，而不可能是其他类的对象</p>
<p>不过String不可变的根本原因还是：底层数组被private final这两个关键字修饰，final修饰数组表明数组的引用地址不可变，再加上private的私有访问权限（final并不能保证数组内容不被修改）</p>
<h3 id="String为什么要设计成不可变的？"><a href="#String为什么要设计成不可变的？" class="headerlink" title="String为什么要设计成不可变的？"></a>String为什么要设计成不可变的？</h3><p>String不可变的原因包括 设计考虑、效率优化、安全性几方面. 事实上，这也是Java面试中的许多 “为什么” 的回答角度。</p>
<ul>
<li>便于实现字符串池。String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。如果字符串是可变的，比如改变一个对象会影响到另一个独立对象，串池将不能够实现</li>
<li>加快字符串处理速度。由于String是不可变的，保证了hashcode的唯一性，于是在创建对象时其hashcode就可以放心的缓存了，只需要计算一次，不需要重新计算。这也就是Map喜欢将String作为Key的原因，处理速度要快过其它的键对象。</li>
<li>避免安全问题。在网络连接和数据库连接中字符串常常作为参数，如果字符串是可变的，黑客就有可能改变字符串指向对象的值，那么会引起很严重的安全问题。</li>
<li>使多线程安全。在并发场景下，多个线程同时读一个资源，是安全的，不会引发竞争，但对资源进行写操作时是不安全的，不可变对象不能被写，所以保证了多线程的安全</li>
</ul>
<h3 id="在使用-HashMap-的时候，用-String-做-key-有什么好处？"><a href="#在使用-HashMap-的时候，用-String-做-key-有什么好处？" class="headerlink" title="在使用 HashMap 的时候，用 String 做 key 有什么好处？"></a>在使用 HashMap 的时候，用 String 做 key 有什么好处？</h3><p>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。</p>
<h3 id="String常量拼接和变量拼接有什么不同？"><a href="#String常量拼接和变量拼接有什么不同？" class="headerlink" title="String常量拼接和变量拼接有什么不同？"></a>String常量拼接和变量拼接有什么不同？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;  <span class="hljs-comment">// 常量拼接，s4会直接去串池中找到&quot;ab&quot;，因此s3==s4会输出true</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> s1 + s2;    <span class="hljs-comment">// 变量拼接，本质为new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()，最后的这个`toString()`方法，又是创建了一个String，所以有又相当于new String(&quot;ab&quot;)，因此s3==s5会输出false</span><br></code></pre></td></tr></table></figure>

<p><strong>字符串常量拼接的本质其实是 javac在编译期间的优化</strong>，因为都是常量，相加的结果不会变了，结果在编译期就已经确定为”ab”，运行时不会更改。</p>
<p>而变量相加在运行时，其引用的值可能会修改，因此不能使用同样的方法。原理是使用<code>StringBuilder()</code>。不能多次执行<strong>变量+字符串</strong>的操作，否则会在堆中创造大量字符串副本，降低效率</p>
<p>注意final定义的变量是常量，所以<code>final String s1 = &quot;java&quot;;  s2 = s1 + &quot;se&quot;;</code>   s2也是定义在字符串常量池中的</p>
<h3 id="String的intern-方法？"><a href="#String的intern-方法？" class="headerlink" title="String的intern()方法？"></a>String的intern()方法？</h3><p>1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 同时会把串池中的对象返回</p>
<p>面试如果问到再整理</p>
<h3 id="串池的性能调优？"><a href="#串池的性能调优？" class="headerlink" title="串池的性能调优？"></a>串池的性能调优？</h3><p>根据串池的特性：</p>
<ul>
<li><strong>如果代码中有较多重复的字符串，可以考虑将字符串入池</strong>。因为intern会返回串池的对象，能够减少字符串的对象</li>
</ul>
<p>由于串池的底层结构是哈希表，如果哈希表桶（buckets）的个数比较多，链表比较短，哈希碰撞的几率就会减小，查找速度变快。反之则会很慢</p>
<ul>
<li>因此，<strong>如果代码中的字符串常量个数非常多时，可以将<code>StringTableSize（桶个数）</code>调大，减少查找时间</strong></li>
</ul>
<h3 id="String，StringBuffer，StringBuilder-的区别是什么？"><a href="#String，StringBuffer，StringBuilder-的区别是什么？" class="headerlink" title="String，StringBuffer，StringBuilder 的区别是什么？"></a>String，StringBuffer，StringBuilder 的区别是什么？</h3><table>
<thead>
<tr>
<th></th>
<th>是否可变</th>
<th>是否安全</th>
<th>性能</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>不可变</td>
<td>安全</td>
<td>低</td>
</tr>
<tr>
<td>StringBuffer</td>
<td>可变</td>
<td>安全</td>
<td>较高</td>
</tr>
<tr>
<td>StringBuilder</td>
<td>可变</td>
<td>不安全</td>
<td>高</td>
</tr>
</tbody></table>
<h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="什么是集合？常见的集合有哪些？"><a href="#什么是集合？常见的集合有哪些？" class="headerlink" title="什么是集合？常见的集合有哪些？"></a>什么是集合？常见的集合有哪些？</h3><p><strong>集合、数组</strong>都是对多个数据进行存储操作的结构，简称Java<strong>容器</strong>。此时的存储，主要是指<strong>内存</strong>层面的存储，<strong>不涉及持久化</strong>的存储（比如数据库）</p>
<p>Java集合类主要由两个根接口Collection和Map派生出来的，Collection派生出了三个子接口：List、Set、Queue（Java5新增的队列），因此Java集合大致也可分成：</p>
<ul>
<li>List接口：存储有序（有序指存入的顺序和取出的顺序相同，不是按照元素的某些特性排序）的、可重复的数据 ，可存储多个null–&gt; ”动态数组“</li>
<li>Queue接口：队列集合，单向队列是先进先出的</li>
<li>Set接口：存储无序（元素存入和取出顺序不一定相同）的、不可重复的数据，只能存储一个null –&gt; 数学中的“集合”</li>
<li>Map接口：键值对集合。key 是无序的，且是唯一的，value 值不唯一。不同的key 值可以对应相同的value 值。</li>
</ul>
<blockquote>
<p>注意：Collection是一个接口，Collections是一个工具类，Map不是Collection的子接口</p>
</blockquote>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java/Java%20SE/Java%E9%9B%86%E5%90%88-Collection%E7%BB%A7%E6%89%BF%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="Java集合-Collection继承图"></p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java/Java%20SE/Java%E9%9B%86%E5%90%88-Map%E7%BB%A7%E6%89%BF%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="image-20220405151252060"></p>
<h3 id="常用集合框架底层数据结构"><a href="#常用集合框架底层数据结构" class="headerlink" title="常用集合框架底层数据结构"></a>常用集合框架底层数据结构</h3><ul>
<li>List<ul>
<li>ArrayList ：数组</li>
<li>LinkedList ：双向链表</li>
</ul>
</li>
<li>Set <ul>
<li>HashSet ：底层基于HashMap 实现， HashSet 存入读取元素的方式和HashMap 中的Key 是一致的。</li>
<li>TreeSet ：红黑树</li>
</ul>
</li>
<li>Map ：<ul>
<li>HashMap ： JDK1.8之前HashMap 由数组+链表组成的， JDK1.8之后有数组+链表&#x2F;红黑树组成，当链表长度大于8时，链表转化为红黑树，当长度小于6时，从红黑树转化为链表。这样做的目的是能提高HashMap 的性能，因为红黑树的查找元素的时间复杂度远小于链表。</li>
<li>HashTable ：数组+链表</li>
<li>TreeMap ：红黑树</li>
</ul>
</li>
</ul>
<h3 id="线程安全的集合有哪些？线程不安全的呢？"><a href="#线程安全的集合有哪些？线程不安全的呢？" class="headerlink" title="线程安全的集合有哪些？线程不安全的呢？"></a>线程安全的集合有哪些？线程不安全的呢？</h3><p>线程安全的：</p>
<p>Vector ：相当于有同步机制的ArrayList</p>
<p>Stack ：栈</p>
<p>HashTable</p>
<p>enumeration ：枚举</p>
<p>剩下的都是线程不安全的</p>
<h3 id="Java集合的快速失败机制-“fail-fast”和安全失败机制“fail-safe”是什么？"><a href="#Java集合的快速失败机制-“fail-fast”和安全失败机制“fail-safe”是什么？" class="headerlink" title="Java集合的快速失败机制 “fail-fast”和安全失败机制“fail-safe”是什么？"></a>Java集合的快速失败机制 “fail-fast”和安全失败机制“fail-safe”是什么？</h3><ul>
<li>快速失败</li>
</ul>
<p>Java的快速失败机制是Java集合框架中的一种错误检测机制，当多个线程同时对集合中的内容进行修改时可能就会抛出ConcurrentModificationException 异常。其实不仅仅是在多线程状态下，在单线程中用增强for 循环中一边遍历集合一边修改集合的元素也会抛出ConcurrentModificationException 异常。看下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(Integer i : list)&#123;<br>            list.remove(i); <span class="hljs-comment">//运行时抛出ConcurrentModificationException异常</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>正确的做法是用Iterator的remove() 方法，便可正常运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Iterator&lt;Integer&gt; it = list.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            it.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>单线程的情况，用迭代器调用remove() 方法即可正常运行，但如果是多线程会怎么样呢？答案是在多线程的情况下即使用了迭代器调用remove() 方法，还是会报ConcurrentModificationException 异常。</p>
<ul>
<li>安全失败</li>
</ul>
<p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会抛出ConcurrentModificationException 异常。缺点是迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生了修改，迭代器是无法访问到修改后的内容。java.util.concurrent 包下的容器都是安全失败，可以在多线程下并发使用。</p>
<h3 id="如何边遍历边移除-Collection-中的元素？"><a href="#如何边遍历边移除-Collection-中的元素？" class="headerlink" title="如何边遍历边移除 Collection 中的元素？"></a>如何边遍历边移除 Collection 中的元素？</h3><p>从上文“快速失败机制”可知在遍历集合时如果直接调用remove() 方法会抛出<code>ConcurrentModificationException</code> 异常，所以使用迭代器中调用remove() 方法。</p>
<h3 id="迭代器-Iterator-是什么？"><a href="#迭代器-Iterator-是什么？" class="headerlink" title="迭代器 Iterator 是什么？"></a>迭代器 Iterator 是什么？</h3><p>Iterator 是 Java 迭代器最简单的实现，它不是一个集合，它是一种用于访问集合的方法， Iterator接口提供遍历任何Collection 的接口。<strong>Iterator 仅用于遍历集合</strong>，Iterator本身并不提供承装对象的能力。如果需要创建Iterator 对象，则必须有一个被迭代的集合。<strong>集合对象每次调用iterator()方法都得到一个全新的迭代器对象</strong>，默认指针都在集合的<strong>第一个元素之前</strong>。</p>
<h3 id="遍历一个-List-有哪些不同的方式？"><a href="#遍历一个-List-有哪些不同的方式？" class="headerlink" title="遍历一个 List 有哪些不同的方式？"></a>遍历一个 List 有哪些不同的方式？</h3><ol>
<li><p>for 循环遍历：遍历者自己在集合外部维护一个计数器，依次读取每一个位置的元素。</p>
</li>
<li><p>Iterator 遍历：基于顺序存储集合的Iterator 可以直接按位置访问数据。基于链式存储集合的Iterator ，需要保存当前遍历的位置，然后根据当前位置来向前或者向后移动指针。</p>
</li>
</ol>
<p>  集合元素的遍历操作，使用迭代器Iterator接口，使用内部的方法：</p>
<ul>
<li>hasNext()：判断集合是否还有下一个元素</li>
<li>next()：<strong>指针刚开始是在第一个元素之前，调用next()后指针先下移，将下移以后的位置上的元素返回</strong></li>
</ul>
<p>  遍历集合时需要先用hasNext()判断集合是否有下一个元素，否则没有元素的话直接next()会报异常</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Collection</span> <span class="hljs-variable">coll</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>    coll.add(<span class="hljs-number">123</span>);<br>    coll.add(<span class="hljs-number">456</span>);<br>    coll.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Jerry&quot;</span>,<span class="hljs-number">20</span>));<br>    coll.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Tom&quot;</span>));<br>    coll.add(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-comment">// 一定要先构造迭代器</span><br>    <span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> coll.iterator();<br>    <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>        System.out.println(iterator.next());<br>    &#125;<br> 	<br>    <span class="hljs-comment">// 错误方式一：</span><br>    <span class="hljs-comment">// 想遍历一个元素时，执行了两次next()，跳着输出元素，同时会报NoSuchElementException异常</span><br>    <span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> coll.iterator();<br>    <span class="hljs-keyword">while</span>(iterator.next() != <span class="hljs-literal">null</span>)&#123;<br>        System.out.println(iterator.next());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>foreach 遍历： foreach 内部也是采用了Iterator 的方式实现，但使用时不需要显示地声明Iterator 。</li>
</ol>
<p>  注意将容器中每个元素取出来赋值给新定义的变量，然后操作这个变量，容器本身并未发生改变</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span>&#123;<br>    String[] arr = &#123;<span class="hljs-string">&quot;SS&quot;</span>, <span class="hljs-string">&quot;KK&quot;</span>, <span class="hljs-string">&quot;RR&quot;</span>&#125;;<br><br>    <span class="hljs-comment">//方式一：普通for赋值，确实改变了数组本身的值</span><br>    <span class="hljs-comment">//        for(int i = 0;i &lt; arr.length;i++)&#123;</span><br>    <span class="hljs-comment">//            arr[i] = &quot;HH&quot;;</span><br>    <span class="hljs-comment">//        &#125;</span><br><br>    <span class="hljs-comment">//方式二：for each循环赋值，并未改变数组值，因为它是将arr里每个值取出来赋给了s，改s并没有改变数组本身</span><br>    <span class="hljs-keyword">for</span>(String s : arr)&#123;<br>        s = <span class="hljs-string">&quot;HH&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) <br>        System.out.println(arr[i]);  <span class="hljs-comment">// SS KK RR</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="comparable-和-comparator的区别？"><a href="#comparable-和-comparator的区别？" class="headerlink" title="comparable 和 comparator的区别？"></a>comparable 和 comparator的区别？</h3><p>comparable 接口出自java.lang 包，可以理解为一个内比较器，因为实现了Comparable 接口的类可以和自己比较，要和其他实现了Comparable 接口类比较，可以使用compareTo(Objectobj) 方法。compareTo 方法的返回值是int ，有三种情况：</p>
<ol>
<li>返回正整数（比较者大于被比较者）</li>
<li>返回0（比较者等于被比较者）</li>
<li>返回负整数（比较者小于被比较者）</li>
</ol>
<p>comparator 接口出自java.util 包，它有一个compare(Object obj1, Object obj2) 方法用来排序，返回值同样是int ，有三种情况，和compareTo 类似。</p>
<p>它们之间的区别：很多包装类都实现了comparable 接口，像Integer 、String 等，所以直接调用Collections.sort() 直接可以使用。如果对类里面自带的自然排序不满意，而又不能修改其源代码的情况下，使用Comparator 就比较合适。此外使用Comparator 可以避免添加额外的代码与我们的目标类耦合，同时可以定义多种排序规则，这一点是Comparable 接口没法做到的，从灵活性和扩展性讲Comparator更优，故在面对自定义排序的需求时，可以优先考虑使用Comparator 接口。</p>
<h3 id="Collection-和-Collections-有什么区别？"><a href="#Collection-和-Collections-有什么区别？" class="headerlink" title="Collection 和 Collections 有什么区别？"></a>Collection 和 Collections 有什么区别？</h3><ul>
<li><pre><code class="hljs">  Collection是集合类的上级接口，继承于他的接口主要有Set 、List和queue.
</code></pre>
</li>
<li><pre><code class="hljs">  Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。此类不能实例化，就像一个工具类，服务于Java的Collection 框架。
</code></pre>
</li>
</ul>
<p>列举一些方法：（均为static方法）</p>
<ul>
<li>reverse(List)：反转List 中元素的顺序</li>
<li>shuffle(List)：对List集合元素进行随机排序</li>
<li>sort(List)：根据元素的自然顺序对指定List 集合元素按升序排序</li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="Array-和-ArrayList-有什么区别？"><a href="#Array-和-ArrayList-有什么区别？" class="headerlink" title="Array 和 ArrayList 有什么区别？"></a>Array 和 ArrayList 有什么区别？</h3><ul>
<li>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</li>
<li>Array 大小是固定的，ArrayList 的大小是动态变化的。</li>
<li>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等</li>
<li>对于基本类型数据， ArrayList 使用自动装箱来减少编码工作量；而当处理固定大小的基本数据类型的时候，这种方式相对比较慢，这时候应该使用Array 。</li>
</ul>
<h3 id="说一说ArrayList-的扩容机制？"><a href="#说一说ArrayList-的扩容机制？" class="headerlink" title="说一说ArrayList 的扩容机制？"></a>说一说ArrayList 的扩容机制？</h3><p>ArrayList初始长度是10，jdk7是new ArrayList 的时候就创建长度为10的数组（类似于单例的<strong>饿汉式</strong>），jdk8是第一次add的时候才创建长度为10的数组（类似于单例的<strong>懒汉式</strong>）</p>
<p>扩容时对是旧的容量值加上旧的容量数值进行右移一位（位运算，相当于除以2，位运算的效率更高），所以每次扩容都是旧的容量的1.5倍，并将原有数组内容复制到新数组中去。</p>
<h3 id="Arraylist、LinkedList、-Vector的区别？"><a href="#Arraylist、LinkedList、-Vector的区别？" class="headerlink" title="Arraylist、LinkedList、 Vector的区别？"></a>Arraylist、LinkedList、 Vector的区别？</h3><ul>
<li>线程安全：Arraylist、LinkedList线程不安全，Vector线程安全（Vector在关键性的方法前面都加了synchronized关键字）</li>
<li>使用效率：Arraylist、LinkedList效率高、Vector效率低（因为加了同步锁）</li>
<li>底层数据结构： Arraylist、Vector 底层使用的是Object[ ] 数组；LinkedList 底层使用的是双向链表数据结构；</li>
<li>是否支持快速随机访问：即通过元素的序号快速获取元素对象， Arraylist、Vector支持（通过对应的get(int index) 方法），LinkedList 不支持</li>
<li>新增和删除操作：LinkedList比较占优势，因为ArrayList要移动数据</li>
<li>内存空间占用：ArrayList、Vector 的空间浪费主要体现在list列表的结尾会预留一定的容量空间，即扩容。LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存额外的前后指针）</li>
<li>扩容相关：ArrayList在底层数组不够用时在原来的基础上扩展为原来的<strong>1.5倍</strong>，Vector是扩为原来的<strong>2倍</strong></li>
<li>应用场景： <ul>
<li>ArrayList 的底层数据结构是数组，所以在插入和删除元素时的时间复杂度都会收到位置的影响，平均时间复杂度为o(n)，在读取元素的时候可以根据下标直接查找到元素，不受位置的影响，平均时间复杂度为o(1)，所以<strong>ArrayList读取速度快，而增删数据慢，更加适用于多读，少增删</strong>的场景。</li>
<li>LinkedList的底层数据结构是双向链表，所以插入和删除元素不受位置的影响，平均时间复杂度为o(1)，如果是在指定位置插入则是o(n)，因为在插入之前需要先找到该位置，读取元素的平均时间复杂度为o(n)。所以<strong>LinkedList增删数据快，读取慢，更加适用于多增删，少读写</strong>的场景。</li>
</ul>
</li>
</ul>
<p>由于Vector总是比ArrayList慢，所以尽量避免使用。多线程方面可以依然使用ArrayList，有方法将其变为线程安全的</p>
<h3 id="LinkedList-和-ArrayDeque的区别？"><a href="#LinkedList-和-ArrayDeque的区别？" class="headerlink" title="LinkedList 和 ArrayDeque的区别？"></a>LinkedList 和 ArrayDeque的区别？</h3><p>LinkedList 和 ArrayDeque 都可以用来实现栈和队列，除此以外，LinkedList 可以实现List接口，但ArrayDeque 不可以。</p>
<p>在效率上，ArrayDeque 是比 LinkedList 快的</p>
<ul>
<li>从速度的角度：ArrayDeque 基于数组实现双端队列，而 LinkedList 基于双向链表实现双端队列，数组采用连续的内存地址空间，通过下标索引访问，<strong>链表是非连续的内存地址空间</strong>，通过指针访问，不能充分利用cpu cache，所以在寻址方面数组的效率高于链表。</li>
<li>从内存的角度：虽然 LinkedList 没有扩容的问题，但<strong>每次插入和删除都涉及到一个节点对象的创建和弃用</strong>，非常低效和浪费空间，而动态数组几乎是0花费的(数组充满时重新拷贝除外)</li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="说一下-HashSet-的实现原理？"><a href="#说一下-HashSet-的实现原理？" class="headerlink" title="说一下 HashSet 的实现原理？"></a>说一下 HashSet 的实现原理？</h3><p>HashSet 的底层是HashMap ，默认构造函数是构建一个初始容量为16，负载因子为0.75 的HashMap 。HashSet 的值存放于HashMap 的key 上， HashMap 的value 统一为PRESENT 。present？</p>
<h3 id="HashSet如何检查重复？（HashSet是如何保证数据不可重复的？）"><a href="#HashSet如何检查重复？（HashSet是如何保证数据不可重复的？）" class="headerlink" title="HashSet如何检查重复？（HashSet是如何保证数据不可重复的？）"></a>HashSet如何检查重复？（HashSet是如何保证数据不可重复的？）</h3><p>HashSet 的特点是存储元素时无序且唯一，在向HashSet 中添加对象时，首先会计算对象的HashCode值来确定对象的存储位置，如果该位置没有其他对象，直接将该对象添加到该位置；如果该存储位置有存储其他对象（新添加的对象和该存储位置的对象的HashCode 值相同），调用equals 方法判断两个对象是否相同，如果相同，则添加对象失败，如果不相同，则会将该对象重新散列到其他位置。</p>
<p>这里面涉及到了HasCode() 和equals() 两个方法。</p>
<ul>
<li><p>equals()：equals 方法首先比较的是内存地址，如果内存地址相同，直接返回true ；如果内存地址不同，再比较对象的类型，类型不同直接返回false ；类型相同，再比较值是否相同；值相同返回true ，值不同返回false 。总结一下， <strong>equals 会先后比较内存地址、对象类型、以及值</strong>，内存地址相同， equals 一定返回true ；对象类型和值相同， equals 方法一定返回true 。</p>
<p>  如果没有重写equals 方法，那么equals 和&#x3D;&#x3D; 的作用相同，比较的是对象的地址值。</p>
</li>
<li><p>hashCode()：hashCode 方法返回对象的散列码，返回值是int 类型的散列码。散列码的作用是确定该对象在哈希表中的索引位置。</p>
</li>
</ul>
<h3 id="HashSet和HashMap是什么，他们的区别？"><a href="#HashSet和HashMap是什么，他们的区别？" class="headerlink" title="HashSet和HashMap是什么，他们的区别？"></a>HashSet和HashMap是什么，他们的区别？</h3><p>HashSet实现了Set接口，它不允许集合中有重复的值，当我们提到HashSet时，第一件事情就是在将对象存储在HashSet之前，要先确保对象重写equals()和hashCode()方法，这样才能比较对象的值是否相等，以确保set中没有储存相等的对象。如果我们没有重写这两个方法，将会使用这个方法的默认实现。HashSet底层是使用HashMap实现的，HashSet中的元素，只是存放在了底层HashMap的key上， 而value使用一个static final的Object对象标识。因此HashSet 的实现比较简单，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成</p>
<p>HashMap实现了Map接口，Map接口对键值对进行映射。Map中不允许重复的键。Map接口有两个基本的实现，HashMap和TreeMap。TreeMap保存了对象的排列次序，而HashMap则不能。HashMap允许键和值为null。HashMap是线程不安全的</p>
<table>
<thead>
<tr>
<th>HashSet</th>
<th>HashMap</th>
</tr>
</thead>
<tbody><tr>
<td>HashSet实现了Set接口</td>
<td>HashMap实现了Map接口</td>
</tr>
<tr>
<td>HashSet仅仅<strong>存储对象</strong></td>
<td>HashMap储存<strong>键值对</strong></td>
</tr>
<tr>
<td>使用add()方法将元素放入set中</td>
<td>使用put()方法将元素放入map中</td>
</tr>
<tr>
<td>HashSet使用<strong>成员对象</strong>来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性</td>
<td>HashMap中使用<strong>键对象</strong>来计算hashcode值</td>
</tr>
<tr>
<td>HashSet较HashMap来说比较慢</td>
<td>HashMap比较快，因为是使用唯一的键来获取对象</td>
</tr>
</tbody></table>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap在JDK1-7和JDK1-8中有哪些不同？HashMap的底层实现？"><a href="#HashMap在JDK1-7和JDK1-8中有哪些不同？HashMap的底层实现？" class="headerlink" title="HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现？"></a>HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现？</h3><table>
<thead>
<tr>
<th></th>
<th>JDK1.7</th>
<th>JDK1.8</th>
<th>JDK1.8的优势</th>
</tr>
</thead>
<tbody><tr>
<td>底层结构</td>
<td>数组+链表</td>
<td>数组+链表&#x2F;红黑树(链表大于8)</td>
<td>避免单条链表过长而影响查询效率，提高查询效率</td>
</tr>
<tr>
<td>hash值计算方式</td>
<td>9次扰动 &#x3D; 4次位运算 + 5次异或运算</td>
<td>2次扰动 &#x3D; 1次位运算 + 1次异或运算</td>
<td>可以均匀地把之前的冲突的节点分散到新的桶（具体细节见下面扩容部分）</td>
</tr>
<tr>
<td>插入数据方式</td>
<td>头插法（先将原位置的数据移到后1位，再插入数据到该位置）</td>
<td>尾插法（直接插入到链表尾部&#x2F;红黑树）</td>
<td>解决多线程造成死循环地问题</td>
</tr>
<tr>
<td>扩容后存储位置的计算方式</td>
<td>重新进行hash计算</td>
<td>原位置或原位置+旧容量</td>
<td>省去了重新计算hash值的时间</td>
</tr>
</tbody></table>
<p>JDK1.7的Hash函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> h)</span>&#123;<br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt;<span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h^(h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>JDK1.8的Hash函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Onject key)</span>&#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode())^(h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里简单解释下JDK1.8的hash函数，面试经常问这个，两次扰动分别是key.hashCode() 与key.hashCode() 右移16位进行异或。这样做的目的是，高16位不变，低16位与高16位进行异或操作，进而减少碰撞的发生，高低Bit都参与到Hash的计算。如何不进行扰动处理，因为hash值有32位，直接对数组的长度求余，起作用只是hash值的几个低位。</p>
<p>JDK1.8的函数经过了一次异或一次位运算一共两次扰动，而JDK1.7经过了四次位运算五次异或一共九次扰动。</p>
<h3 id="HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？"><a href="#HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？" class="headerlink" title="HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？"></a>HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</h3><p>Hash值的范围是-2147483648到2147483647，不可能建立一个这么大的数组来覆盖所有hash值。不可能在内存建立这么大的数组。</p>
<h3 id="HashMap-的长度为什么是2的幂次方"><a href="#HashMap-的长度为什么是2的幂次方" class="headerlink" title="HashMap 的长度为什么是2的幂次方"></a>HashMap 的长度为什么是2的幂次方</h3><p>因为HashMap 是通过key 的hash值来确定存储的位置，计算完hash值后会对数组的长度进行取余操作，如果数组的长度是2的幂次方， (length - 1)&amp;hash 等同于hash%length ，可以用(length - 1)&amp;hash <strong>这种位运算来代替%取余的操作进而提高性能</strong>。</p>
<h3 id="HashMap是怎么解决哈希冲突的？"><a href="#HashMap是怎么解决哈希冲突的？" class="headerlink" title="HashMap是怎么解决哈希冲突的？"></a>HashMap是怎么解决哈希冲突的？</h3><p>哈希冲突： hashMap 在存储元素时会先计算key 的hash值来确定存储位置，因为key 的hash值计算最后有个对数组长度取余的操作，所以即使不同的key 也可能计算出相同的hash值，这样就引起了hash冲突。hashMap 的底层结构中的链表&#x2F;红黑树就是用来解决这个问题的。</p>
<p>HashMap 中的哈希冲突解决方式可以主要从三方面考虑（以JDK1.8为背景）</p>
<ul>
<li><p>拉链法：HasMap 中的数据结构为数组+链表&#x2F;红黑树，当不同的key 计算出的hash值相同时，就用链表的形式将Node结点（冲突的key 及key 对应的value ）挂在数组后面。</p>
</li>
<li><p>hash函数：key 的hash值经过两次扰动， key 的hashCode 值与key 的hashCode 值的右移16位进行异或，然后对数组的长度取余（实际为了提高性能用的是位运算，但目的和取余一样），这样做可以让hashCode 取值出的高位也参与运算，进一步降低hash冲突的概率，使得数据分布更平均。</p>
</li>
<li><p>红黑树：在拉链法中，如果hash冲突特别严重，则会导致数组上挂的链表长度过长，性能变差，因此在链表长度大于8时，将链表转化为红黑树，可以提高遍历链表的速度。</p>
</li>
</ul>
<h3 id="HashMap的put方法的具体流程？"><a href="#HashMap的put方法的具体流程？" class="headerlink" title="HashMap的put方法的具体流程？"></a>HashMap的put方法的具体流程？</h3><p>以JDK1.8为例，简要流程如下：</p>
<ol>
<li>首先根据 key 的值计算 hash 值，找到该元素在数组中存储的下标；</li>
<li>如果数组是空的，则调用 resize 进行初始化；</li>
<li>如果没有哈希冲突直接放在对应的数组下标里；</li>
<li>如果冲突了，且 key 已经存在，就覆盖掉 value；</li>
<li>如果冲突后，发现该节点是红黑树，就将这个节点挂在树上；</li>
<li>如果冲突后是链表，判断该链表是否大于 8 ，如果大于 8 并且数组容量小于 64，就进行扩容；如果链表节点大于 8 并且数组的容量大于 64，则将这个结构转换为红黑树；否则，链表插入键值对，若 key 存在，就覆盖掉 value。</li>
</ol>
<h3 id="HashMap的扩容操作是怎么实现的？"><a href="#HashMap的扩容操作是怎么实现的？" class="headerlink" title="HashMap的扩容操作是怎么实现的？"></a>HashMap的扩容操作是怎么实现的？</h3><p>扩容操作为resize() 方法，它是在hashmap 中的键值对大于阀值时或者初始化时进行扩容。</p>
<p>每次扩容，容量都是之前的两倍，扩容时有个判断e.hash &amp; oldCap 是否为零，也就是相当于hash值对数组长度的取余操作，若等于0，则位置不变，若等于1，位置变为原位置加旧容量。</p>
<p>初始值为16，负载因子为0.75，阈值为负载因子*容量。</p>
<p>分析扩容源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br></code></pre></td></tr></table></figure>





<h3 id="HashMap默认加载因子为什么选择0-75？"><a href="#HashMap默认加载因子为什么选择0-75？" class="headerlink" title="HashMap默认加载因子为什么选择0.75？"></a>HashMap默认加载因子为什么选择0.75？</h3><p>这个主要是考虑空间利用率和查询成本的一个折中。如果加载因子过高，空间利用率提高，但是会使得哈希冲突的概率增加；如果加载因子过低，哈希冲突概率降低，但会频繁扩容，使得空间利用率变低。</p>
<p>具体为什么是0.75，不是0.74或0.76，这是一个基于数学分析（泊松分布）和行业规定一起得到的一个结论。</p>
<h3 id="为什么要将链表中转红黑树的阈值设为8？为什么不一开始直接使用红黑树？"><a href="#为什么要将链表中转红黑树的阈值设为8？为什么不一开始直接使用红黑树？" class="headerlink" title="为什么要将链表中转红黑树的阈值设为8？为什么不一开始直接使用红黑树？"></a>为什么要将链表中转红黑树的阈值设为8？为什么不一开始直接使用红黑树？</h3><p>可能有很多人会问，既然红黑树性能这么好，为什么不一开始直接使用红黑树，而是先用链表，链表长度大于8时，才转换为红红黑树。</p>
<ul>
<li>因为红黑树的节点所占的空间是普通链表节点的两倍，但查找的时间复杂度低，所以只有当节点特别多时，红黑树的优点才能体现出来。至于为什么是8，是通过数据分析统计出来的一个结果，链表长度到达8的概率是很低的，综合链表和红黑树的性能优缺点考虑将大于8的链表转化为红黑树。</li>
<li>链表转化为红黑树除了链表长度大于8，还要HashMap 中的数组长度大于64。也就是如果HashMap 长度小于64，链表长度大于8是不会转化为红黑树的，而是直接扩容。</li>
</ul>
<h3 id="能否使用任何类作为-Map-的-key？"><a href="#能否使用任何类作为-Map-的-key？" class="headerlink" title="能否使用任何类作为 Map 的 key？"></a>能否使用任何类作为 Map 的 key？</h3><p>可以，但要注意以下两点：</p>
<ul>
<li><p>如果类重写了 equals() 方法，也应该重写hashCode() 方法。</p>
</li>
<li><p>最好定义key 类是不可变的，这样key 对应的hashCode() 值可以被缓存起来，性能更好，这也是为什么String 特别适合作为HashMap 的key 。</p>
</li>
</ul>
<h3 id="为什么HashMap中String、Integer这样的包装类适合作为Key？"><a href="#为什么HashMap中String、Integer这样的包装类适合作为Key？" class="headerlink" title="为什么HashMap中String、Integer这样的包装类适合作为Key？"></a>为什么HashMap中String、Integer这样的包装类适合作为Key？</h3><p>这些包装类都是final 修饰，是不可变性的， 保证了key 的不可更改性，不会出现放入和获取时哈希值不同的情况。</p>
<p>它们内部已经重写过hashcode() , equal() 等方法。</p>
<h3 id="如果使用Object作为HashMap的Key，应该怎么办呢？"><a href="#如果使用Object作为HashMap的Key，应该怎么办呢？" class="headerlink" title="如果使用Object作为HashMap的Key，应该怎么办呢？"></a>如果使用Object作为HashMap的Key，应该怎么办呢？</h3><p>重写hashCode() 方法，因为需要计算hash值确定存储位置</p>
<p>重写equals() 方法，因为需要保证key 的唯一性。</p>
<h3 id="HashMap-多线程导致死循环问题"><a href="#HashMap-多线程导致死循环问题" class="headerlink" title="HashMap 多线程导致死循环问题"></a>HashMap 多线程导致死循环问题</h3><p>由于JDK1.7的hashMap 遇到hash冲突采用的是头插法，在多线程情况下会存在死循环问题，但JDK1.8已经改成了尾插法，不存在这个问题了。但需要注意的是JDK1.8中的HashMap 仍然是不安全的，在多线程情况下使用仍然会出现线程安全问题</p>
<h3 id="ConcurrentHashMap-底层具体实现知道吗？"><a href="#ConcurrentHashMap-底层具体实现知道吗？" class="headerlink" title="ConcurrentHashMap 底层具体实现知道吗？"></a>ConcurrentHashMap 底层具体实现知道吗？</h3><h3 id="HashTable的底层实现知道吗？"><a href="#HashTable的底层实现知道吗？" class="headerlink" title="HashTable的底层实现知道吗？"></a>HashTable的底层实现知道吗？</h3><p>Hashtable是个古老的Map 实现类，JDK1.0就提供了。不同于HashMap，Hashtable是<strong>线程安全</strong>的（尽管现在线程安全也还是使用HashMap）。</p>
<p>HashTable 的底层数据结构是数组+链表，链表主要是为了解决哈希冲突，并且整个数组都是synchronized 修饰的，所以HashTable 是线程安全的，但锁的粒度太大，锁的竞争非常激烈，效率很低。</p>
<p>与HashMap不同，Hashtable<strong>不允许使用null 作为key和value</strong>。与HashMap一样，Hashtable也不能保证其中Key-Value 对的顺序（<strong>无序性</strong>），Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。</p>
<h3 id="HashMap、ConcurrentHashMap及Hashtable-的区别"><a href="#HashMap、ConcurrentHashMap及Hashtable-的区别" class="headerlink" title="HashMap、ConcurrentHashMap及Hashtable 的区别"></a>HashMap、ConcurrentHashMap及Hashtable 的区别</h3><table>
<thead>
<tr>
<th></th>
<th>HashMap(JDK1.8)</th>
<th>ConcurrentHashMap(JDK1.8)</th>
<th>Hashtable</th>
</tr>
</thead>
<tbody><tr>
<td>底层实现</td>
<td>数组+链表&#x2F;红黑树</td>
<td>数组+链表&#x2F;红黑树</td>
<td>数组+链表</td>
</tr>
<tr>
<td>线程安全</td>
<td>不安全</td>
<td>安全( Synchronized 修饰Node节点)</td>
<td>安全( Synchronized 修饰整个表)</td>
</tr>
<tr>
<td>效率</td>
<td>高</td>
<td>较高</td>
<td>低</td>
</tr>
<tr>
<td>扩容</td>
<td>初始16，每次扩容成2n</td>
<td>初始16，每次扩容成2n</td>
<td>初始11，每次扩容成2n+1</td>
</tr>
<tr>
<td>是否支持Null key和Null Value</td>
<td>可以有一个Null key，Null Value多个</td>
<td>不支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>Java则需要先生成字节码，JVM再将字节码解释成机器码。这么做的好处就是JVM屏蔽了底层平台的差别，可以跨平台运行，比如在Windows编译，也可以在Linux运行，这么做的缺点是JVM会影响性能，这也是Java的性能一般不如C或C++的原因。</p>
<h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><h3 id="JVM的主要组成部分及作用"><a href="#JVM的主要组成部分及作用" class="headerlink" title="JVM的主要组成部分及作用"></a>JVM的主要组成部分及作用</h3><p>JVM主要由类装载系统、运行时数据区、执行引擎、本地接口等四部分组成，其中运行时数据区是重点掌握内容，如下图</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java/JVM/JVM%E7%BB%84%E6%88%90%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="image-20220505162915636"></p>
<p>类装载子系统（类加载器）：加载字节码到内存</p>
<p>运行时数据区：JVM的内存区域</p>
<p>执行引擎：也成为解释器，将字节码翻译成底层系统指令，交由操作系统执行</p>
<p>本地库接口：与其他语言交互时所使用的</p>
<p>工作原理：首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（ExecutionEngine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p>
<h3 id="JVM运行时数据区域（Java内存分区）？"><a href="#JVM运行时数据区域（Java内存分区）？" class="headerlink" title="JVM运行时数据区域（Java内存分区）？"></a>JVM运行时数据区域（Java内存分区）？</h3><p>方法区和堆是线程共享数据区，虚拟机栈、本地方法栈、程序计数器是线程私有数据区</p>
<p>1、程序计数器：执行字节码的行号指示器，<font color=red>唯一 一个不会出现 OutOfMemoryError</font></p>
<p>2、Java虚拟机栈：Java每个线程启动后，虚拟机就会为其分配一块栈内存。每个栈由多个栈帧（Frame）组成，对应着每次的方法调用。每个方法在执行的同时都会创建一个<strong>栈帧</strong>用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。方法从调用至完成对应着一个栈帧在虚拟机栈入栈到出栈。会抛出StackOverflowError 和OutOfMemoryError</p>
<p>3、本地方法栈：作用同虚拟机栈，但本地方法栈是为虚拟机调用 Native 方法服务</p>
<p>4、堆：Java 虚拟机中内存最大的一块，几乎所有的对象实例都在这里分配内存</p>
<p>5、方法区：用于存储已被虚拟机<strong>加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据</p>
<h3 id="java中的常量池"><a href="#java中的常量池" class="headerlink" title="java中的常量池"></a>java中的常量池</h3><p>用final修饰的成员变量表示常量，值一旦给定就无法改变！final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。</p>
<p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。</p>
<p>JVM常量池主要分为Class文件常量池、运行时常量池、全局字符串常量池、以及8种基本类型的包装类和常量池</p>
<ul>
<li><p><strong>Class文件常量池</strong></p>
<p>  在Class文件结构中，最头的4个字节用于存储魔数Magic Number，用于确定一个文件是否能被JVM接受，再接着4个字节用于存储版本号，前2个字节存储次版本号，后2个存储主版本号</p>
<p>  再接着是用于存放常量的常量池，由于常量的数量是不固定的，所以常量池的入口放置一个U2类型的数据(constant_pool_count)存储常量池容量计数值。常量池<strong>主要</strong>用于存放编译期生成的各种<strong>字面量</strong>(Literal)和<strong>符号引用量</strong>(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：类和接口的全限定名、字段名称和描述符、方法名称和描述符</p>
</li>
<li><p><strong>运行时常量池</strong></p>
<p>  运行时常量池是方法区的一部分。上面提到的Class文件常量池中存放了字面量和符号引用，这部分内容将在<strong>类加载后</strong>进入方法区的<strong>运行时常量池</strong>中存放。运行时常量池区别于CLass文件常量池的另外一个重要特征是<strong>具备动态性</strong>，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，<strong>运行期间也可能将新的常量放入池中</strong>，这种特性被开发人员利用比较多的就是**String类的intern()**方法。</p>
</li>
<li><p><strong>全局字符串常量池</strong></p>
<p> 略</p>
</li>
<li><p><strong>8种基本类型的包装类和常量池</strong></p>
<p>  java中基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean。前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象。两种浮点数类型的包装类Float,Double并没有实现常量池技术</p>
</li>
</ul>
<h3 id="Java内存泄漏是什么，如何避免"><a href="#Java内存泄漏是什么，如何避免" class="headerlink" title="Java内存泄漏是什么，如何避免"></a>Java内存泄漏是什么，如何避免</h3><p>内存泄漏：指程序中动态分配给内存一些临时对象，并且这些对象始终没有被回收，一直占用着内存，简单来说就是申请内存使用完了不进行释放</p>
<p>常见的内存泄漏产生原因：</p>
<ul>
<li><strong>数据库连接、网络连接等各种连接没有显示释放导致内存泄漏</strong>，例如在数据库连接后不再使用时，必须调用close方法释放与数据库的连接，否则会造成大量对象无法被回收进而造成内存泄漏</li>
<li><strong>哈希值改变</strong>，例如在一个对象存储到HashSet后，改变了对象中参与计算哈希值的字段，那么会导致对象的哈希值发生变化，和之前存入HashSet的哈希值不同，也就无法通过当前对象的引用在HashSet中找到这个对象，无法从HashSet中删除对象，造成内存泄漏，这也是为什么通常利用String类型的变量当作HashMap的key，因为String类型是不可变的</li>
<li><strong>内部类的对象被长期持有</strong>，那么内部类对象所属的外部类对象也不能被收回</li>
<li><strong>静态集合类引起内存泄漏</strong>，因为静态集合的生命周期和JVM一致，所以静态集合引用的对象不能被释放</li>
<li><strong>单例模式导致内存泄漏</strong>，因为单例模式的静态特性，它的生命周期和JVM的生命周期一致，如果单例对象持有外部对象的引用，这个对象也不会被回收</li>
</ul>
<p>内存泄漏解决方案：写代码时尽量避免上述会造成内存泄漏的情况</p>
<h3 id="Java内存溢出是什么，如何避免"><a href="#Java内存溢出是什么，如何避免" class="headerlink" title="Java内存溢出是什么，如何避免"></a>Java内存溢出是什么，如何避免</h3><p>Java内存溢出指程序运行过程中无法申请到足够的内存导致的错误</p>
<p>常见的造成内存溢出的原因：</p>
<ul>
<li>内存加载的数据量太大，内存不够用了</li>
<li>代码中存在死循环或循环产生大量对象</li>
<li>启动参数内存值设置过小</li>
<li>长期的内存泄漏也会导致内存溢出</li>
</ul>
<p>内存溢出解决方案：</p>
<ul>
<li>修改JVM启动参数，增加内存</li>
<li>使用内存查看工具动态查看内存使用情况</li>
<li>对代码进行排查，重点排查有没有上述提到的造成常见内存溢出情景的代码</li>
</ul>
<h3 id="什么情况下会出现OOM？"><a href="#什么情况下会出现OOM？" class="headerlink" title="什么情况下会出现OOM？"></a>什么情况下会出现OOM？</h3><blockquote>
<p>为什么会OOM？</p>
<p>1）分配的少了：比如虚拟机本身可使用的内存（一般通过启动时的VM参数指定）太少。</p>
<p>2）应用用的太多，并且用完没释放，浪费了。此时就会造成内存泄露或者内存溢出。</p>
</blockquote>
<p><strong>最常见的OOM情况有以下三种</strong>：</p>
<ul>
<li><p><code>java.lang.OutOfMemoryError: Java heap space</code> ：java堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。</p>
<p>  解决方法：对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx等修改。</p>
</li>
<li><p><code>java.lang.OutOfMemoryError: PermGen space</code> ：java永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区（一个启动类，加载了大量的第三方jar包；Tomcat部署了太多的应用；大量动态生成的反射类，不断地被加载，直到内存满，就会出现OOM）。</p>
<p>  解决方法：此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize&#x3D;64m，XX:MaxPermSize &#x3D;256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。</p>
</li>
<li><p><code>java.lang.StackOverflowError </code>：栈内存溢出，不属于OOM，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。</p>
<p>  解决方法：可以通过修改代码或者调整虚拟机参数-Xss来设置栈的大小。</p>
</li>
</ul>
<h3 id="JVM永久代、元空间"><a href="#JVM永久代、元空间" class="headerlink" title="JVM永久代、元空间"></a>JVM永久代、元空间</h3><p>为什么在JDK1.8会使用元空间取代永久代？</p>
<p>永久代使用的是设定好的虚拟机内存，无法动态扩展内存空间，当加载的类过多就可能发生OOM，并且永久代的内存大小设置也是难以确定的，所以对永久代调优也是比较困难的。元空间的出现就解决了永久代的问题，因为元空间不再使用虚拟机的内存了，而是使用了本地内存，本地内存可以自动扩展调节，内存不足也不会触发Full GC。</p>
<h3 id="Java对象的创建过程-可略"><a href="#Java对象的创建过程-可略" class="headerlink" title="Java对象的创建过程 可略"></a>Java对象的创建过程 可略</h3><ol>
<li>类加载检查：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li>
<li>分配内存：在类加载检查后，就要为新生对象分配内存了，对象内存所需大小在类加载完成后便可以确定，内存分配方式根据Java堆中内存是否完整主要分为指针碰撞和空闲列表两种。</li>
<li>初始化零值：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这也是为什么字段在Java代码中可以不赋值就能直接使用的原因。</li>
<li>设置对象头：初始化零值后，虚拟机需要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息都是存放在对象的对象头中。根据虚拟机当前的运行状态不同，如是否使用偏向锁等，对象头都会有不同的设置方式。</li>
<li>执行init方法：上述操作完成后，从虚拟机的角度看，一个新的对象已经产生了。但从Java程序的角度看，对象创建才刚刚开始，<code>init</code> 方法还没有执行，所有的字段都还为零。所以，一般执行完new 指令后还会接着执行<code>init</code> 方法，把对象按照程序员的意愿进行初始化（赋值），这样一个真正可用的对象才算生产出来</li>
</ol>
<h3 id="对象的访问方式有哪些-可略"><a href="#对象的访问方式有哪些-可略" class="headerlink" title="对象的访问方式有哪些 可略"></a>对象的访问方式有哪些 可略</h3><p>目前主流的访问方式有使用句柄和直接指针两种。</p>
<p>句柄：Java堆中会划分出一块内存来作为句柄，reference中存储的是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如下图</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java/JVM/%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F-%E5%8F%A5%E6%9F%84.png" srcset="/img/loading.gif" lazyload alt="image-20220510154418481"></p>
<p>直接指针：如果使用直接指针访问，reference中存储的就是对象地址，而Java堆对象的布局需要考虑如何放置访问<br>累类型数据的相关信息，如下图</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java/JVM/%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png" srcset="/img/loading.gif" lazyload alt="image-20220510154720424"></p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>Java和C++的一个明显区别就是Java具备内存动态分配和垃圾收集技术，而C++则需要程序员自己管理内存，这也使得一些初学者觉得C++比较难</p>
<h3 id="Java中垃圾回收是什么，为什么需要垃圾回收"><a href="#Java中垃圾回收是什么，为什么需要垃圾回收" class="headerlink" title="Java中垃圾回收是什么，为什么需要垃圾回收?"></a>Java中垃圾回收是什么，为什么需要垃圾回收?</h3><p>在Java中垃圾回收的目的是回收释放不再被引用的实例对象，这样做可以减少内存泄漏、内存溢出问题的出现</p>
<h3 id="垃圾回收算法有哪些？"><a href="#垃圾回收算法有哪些？" class="headerlink" title="垃圾回收算法有哪些？"></a>垃圾回收算法有哪些？</h3><p>垃圾收集算法主要有标记-清除算法、标记-复制算法、标记-整理算法、分代收集算法</p>
<ul>
<li>标记-清除算法：主要包含标记和清除两个阶段，首先标记出所有需要回收的对象，在标记完成后同一回收所有被标记的对象。效率低、产生大量不连续内存碎片</li>
<li>标记-复制算法：标记完后不直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉其他地方的内存。避免内存碎片产生、性能较低</li>
<li>标记-复制算法：将整个内存分成两个大小相等的区域from 和 to，在找出存活对象后，会将它们从 from 复制到 to 区域，复制的过程中自然完成了碎片整理，复制完成后，交换 from 和 to 的位置。效率高、避免内存碎片产生，但每次可以使用的内存只有原来的一半</li>
<li>分代收集算法：将Java堆分为新生代和老年代，根据每个年代的特点采用合适的收集算法。例如，在新生代每次垃圾回收时会有大量对象死亡，只有少量存活，所以在<strong>新生代选择用标记-复制</strong>算法，在<strong>老年代</strong>每次垃圾回收会有大量对象存活，考虑使用<strong>标记-清除或标记-整理</strong>算法。在商业虚拟机中一般都是采用分代收集算法。</li>
</ul>
<h3 id="Minor-GC和Full-GC有什么不同？"><a href="#Minor-GC和Full-GC有什么不同？" class="headerlink" title="Minor GC和Full GC有什么不同？"></a>Minor GC和Full GC有什么不同？</h3><ul>
<li>Minor GC（新生代GC）：指发生在新生代的垃圾收集动作，Java对象大多存活时间不长，所以Minor GC的发生会比较频繁，回收速度也比较快</li>
<li>Full GC&#x2F;Major GC（老年代GC）：指发生在老年代的GC，出现了Full GC，经常会伴随至少一次的Minor GC（不是必然的），Major GC的速度一般会比Minor GC慢10倍以上。</li>
</ul>
<h3 id="什么情况下会触发Minor-GC和Full-GC？"><a href="#什么情况下会触发Minor-GC和Full-GC？" class="headerlink" title="什么情况下会触发Minor GC和Full GC？"></a>什么情况下会触发Minor GC和Full GC？</h3><p>minorGC：</p>
<ul>
<li>Eden区满了</li>
<li>新创建对象的大小大于Eden所剩余空间</li>
</ul>
<p>Full GC：</p>
<ul>
<li><p>老年代空间不足，创建的大对象的内存大于老年代空间，导致老年代空间不足，则会发生Full GC</p>
</li>
<li><p>通过Minor GC后晋升到老年代的对象平均大小超过了老年代剩余空间，会触发FullGC</p>
</li>
<li><p>System.gc() 方法的调用，此方法会建议JVM进行Full GC，但JVM可能不接受这个建议，所以不一定会执行。</p>
</li>
<li><p>JDK1.7及以前的永久代空间满了，在JDK1.7以前，HotSpot虚拟机的方法区是永久代实现都得，在永久代中会存放一些Class的信息、常量、静态变量等数据，在永久代满了，并且没有配置CMS GC的情况下就会触发Full GC，在JDK1.8开始移除永久代也是为了减少Full GC的频率</p>
</li>
</ul>
<h3 id="为什么要减少Full-GC的发生？"><a href="#为什么要减少Full-GC的发生？" class="headerlink" title="为什么要减少Full GC的发生？"></a>为什么要减少Full GC的发生？</h3><p>Full GC发生过于频繁，会影响性能，因为Full GC会导致STW(Stop-The-World)，STW指的是用户线程在运行至安全点（safe point）或安全区域（safe region）之后，就自行挂起，进入暂停状态，对外的表现就是卡顿。所以应尽量减少Full GC的次数。不过不论是minor gc还是major gc都会STW，区别只在于STW的时间长短。</p>
<h3 id="minor-GC和Full-GC的过程？"><a href="#minor-GC和Full-GC的过程？" class="headerlink" title="minor GC和Full GC的过程？"></a>minor GC和Full GC的过程？</h3><p>Java堆的基本结构如下，大体上可以分为新生代和老年代：新生代默认占1&#x2F;3，老年代默认占2&#x2F;3，新生代包含Eden区、From Survivor0区和 To Survivor1区，默认比例是8：1：1，老年代就一个Old Memory区。</p>
<p>minor GC：对象先在Eden区分配，当Eden区没有足够的空间去分配时，虚拟机会发起一次Minor GC，将存活的对象放到From Survivor区（对象年龄为1）当再次发生Minor GC，会将Eden区和From区一起清理，存活的对象会被移动到To Survivor区（年龄加1）这时From 区会和To 区进行交换，然后重复第一步，不过这次第一步中的From 区其实是上一轮中的To 区。不管怎样，都会保证交换后名为To区里是空的。每次移动，对象的年龄就会加1，当年龄到达15时（默认是15，可以通过JVM参数设置），会从新生代进入老年代。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p>
<p>还有一种现象是大对象直接晋升老年代，判断了eden里放不下，就去老年代看看能不能放下，能放下就直接放在老年代。</p>
<p>当老年代空间不足时，会先触发 minor gc，如果空间仍然不足，那么就触发 full fc ，停止的时间更长！full GC 之后如果空间还是不足，则触发OOM</p>
<p>Full GC：参考CMS的工作过程。</p>
<h3 id="垃圾回收器有哪些？"><a href="#垃圾回收器有哪些？" class="headerlink" title="垃圾回收器有哪些？"></a>垃圾回收器有哪些？</h3><p>（JDK 8 默认打开了<code>UseParallelGC</code>参数，因此使用了<code>Parallel Scavenge + Serial Old</code>的收集器组合进行内存回收）</p>
<table>
<thead>
<tr>
<th></th>
<th>新&#x2F;老</th>
<th>清除算法</th>
</tr>
</thead>
<tbody><tr>
<td>Serial GC</td>
<td>新</td>
<td>标记复制</td>
</tr>
<tr>
<td>ParNew GC</td>
<td>新</td>
<td>标记复制</td>
</tr>
<tr>
<td>Parallel GC</td>
<td>新</td>
<td>标记复制</td>
</tr>
<tr>
<td>Serial Old GC</td>
<td>老</td>
<td>标记整理</td>
</tr>
<tr>
<td>Parallel Old GC</td>
<td>老</td>
<td>标记整理</td>
</tr>
<tr>
<td>CMS</td>
<td>老</td>
<td>标记清除</td>
</tr>
<tr>
<td>G1</td>
<td></td>
<td>整体上是标记整理算法，两个区域之间是复制算法</td>
</tr>
</tbody></table>
<p>搭配使用：</p>
<p>Serial GC ~ Serial Old GC    Parallel GC<del>Parallel Old GC     ParNew GC</del>CMS ~Serial Old GC  </p>
<p>（1）Serial收集器</p>
<p>Serial收集器是最基本的收集器，并且是单线程的收集器，这里的单线程不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，在它进行垃圾收集时，必须暂停其他所有的线程工作，直到它收集结束。不难想象，这对很多应用来说都是难以接受的。除了上面写到的缺点，Serial收集器也有着优于其他收集器的地方，简单而高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾回收自然可以获得最高的单线程的收集效率。</p>
<p>（2）ParNew收集器</p>
<p>ParNew收集器是Serial收集器的多线程版本，除了使用多条线程进行垃圾回收外，其他地方与Serial一样</p>
<p>（3）Parallel 收集器</p>
<p>Parallel Scavenge 是一个使用标记-复制算法的多线程收集器，看起来和ParNew很像，ParallelScavenge收集器的关注点和与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间（用户体验），而Parallel Scavenge收集器的关注点是达到一个可控制的吞吐量（提高CPU的效率），这里的吞吐量指的是CPU用于运行代码的时间和CPU总消耗时间的比值。</p>
<p>那更短的停顿时间和更高的吞吐量有什么好处呢？</p>
<p>停顿时间越短越适合需要与用户交互的程序，良好的响应速度可以提升用户体验。更高的吞吐量适合在后台运算而不需要太多交互的程序，高吞吐量可以提高CPU的利用率，尽快地完成程序的运算任务。</p>
<p>（4）Serial Old收集器</p>
<p>Serial Old是Serial收集器的老年代版本，同样是单线程收集器，采用标记-整理算法，主要有两大用途：一是在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使用，二是作为CMS收集器的后备预案。</p>
<p>（5）Parallel Old收集器</p>
<p>Parallel Old是Parallel Scavenge收集器的老年代版本，采用多线程和标记-整理算法。该收集器是在JDK1.6才开始提供的，因为当新生代选择了Parallel Scavenge收集器，老年代只能选择Serial Old（Parallel Scavenge无法与CMS搭配使用），这时Serial Old收集器会影响整体的吞吐量，所以提供了Parallel Old收集器和Parallel Scavenge搭配使用</p>
<p>（6）CMS收集器</p>
<p>（7）G1收集器</p>
<h3 id="CMS收集器是怎样的"><a href="#CMS收集器是怎样的" class="headerlink" title="CMS收集器是怎样的"></a>CMS收集器是怎样的</h3><p>CMS（Concurrent Mark Sweep）收集器是一种<strong>获取响应时间优先的收集器（最短回收停顿时间）</strong>，基于<strong>标记-清除</strong>算法实现，是一款<strong>老年代</strong>收集器，它非常符合那些集中在互联网站或者B&#x2F;S系统的服务端上的Java应用，这些应用都非常重视服务的响应速度。整个工作流程包括四个步骤：</p>
<ol>
<li><strong>初始标记</strong>：暂停用户线程（STW），标记GC Roots能直接关联的对象，速度很快</li>
<li><strong>并发标记</strong>：同时开启GC线程和用户线程，从GC Roots的直接关联对象开始遍历所有对象的过程，耗时较长</li>
<li><strong>重新标记</strong>：暂停用户线程（STW），修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</li>
<li><strong>并发清除</strong>：同时开启GC线程和用户线程，清理删除标记阶段判断的已经死亡的对象，不需要移动存活对象。此时的用户线程还是可能会产生新垃圾，这些垃圾就叫<strong>浮动垃圾</strong>，只能由下一次GC来处理，因此堆内存也需要预留一些空间给这些浮动垃圾，不能等整个堆内存都满了才GC。浮动垃圾如果也非常多，内存不够放，就会并发失败</li>
</ol>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/JVM-GC-%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88GC.png" srcset="/img/loading.gif" lazyload alt="image-20220303162716397"></p>
<p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<blockquote>
<p>并行：指多条垃圾收集器线程并行工作，此时用户线程仍处于等待状态</p>
<p>并发：指用户线程与垃圾收集线程同时执行（也可以交替执行）</p>
</blockquote>
<p>优点：并发收集、停顿低</p>
<p>缺点：</p>
<ul>
<li>对CPU资源敏感，总吞吐量会降低</li>
<li>无法处理浮动垃圾</li>
<li>标记-清除算法导致内存碎片</li>
<li>浮动垃圾、内存碎片过多会导致并发失败，此时老年代就会退化为serialOld回收器，进行标记整理，很耗费时间</li>
</ul>
<h3 id="G1收集器是怎样的？"><a href="#G1收集器是怎样的？" class="headerlink" title="G1收集器是怎样的？"></a>G1收集器是怎样的？</h3><p><strong>G1（Garbage First）</strong>，打破了原有的分代模型，将堆划分为一个个区域。</p>
<p>这么做的目的是在进行回收时不必在全堆范围内进行，可以根据<strong>暂停时间目标</strong>优先回收价值高的区域，实现了接近实时的回收特性</p>
<p>G1 具备如下特点：</p>
<ol>
<li><strong>并行与并发</strong>：G1 能充分利用多 CPU、多核环境下的硬件优势，<strong>使用多个 CPU 来缩短 Stop-the-world 停顿的时间</strong>，部分其他收集器原来需要停顿 Java 线程执行的 GC 操作，G1 收集器仍然可以通过并发的方式让 Java 程序继续运行。</li>
<li><strong>分代收集</strong>：打破了原有的分代模型，将堆划分为一个个区域，G1可以不需要其他收集器配合就能独自管理整个GC堆</li>
<li><strong>空间整合</strong>：G1 整体使用“标记-整理”算法，两个区域之间是复制算法。<strong>不会产生内存空间碎片</strong>，有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC</li>
<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的一个优势，降低停顿时间是 G1 和 CMS 共同的关注点。</li>
</ol>
<p>整个流程包括四个步骤：</p>
<ul>
<li>初始标记（会STW）：仅仅只是标记一下 GC Roots 能直接关联到的对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</li>
<li>并发标记：从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。</li>
<li>最终标记（会STW）：对用户线程做短暂的暂停，处理并发阶段结束后仍有引用变动的对象。</li>
<li>筛选回收（会STW）：更新每个内存块的统计数据，对各个内存块的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划（不会对所有老年代区域进行回收），即根据<strong>暂停时间目标</strong>优先回收价值高（这几个地方垃圾多，回收了能释放的空间多）的区域，可以自由选择任意多个内存块构成回收集，然后把决定回收的那一部分内存块的存活对象复制到空的内存块中，再清理掉整个旧内存块的全部空间。这里的操作涉及存活对象的移动，必须暂停用户线程，由多条回收器线程并行完成的。</li>
</ul>
<p>也有人将G1分为三个大步骤：</p>
<ul>
<li>新生代回收：Minor GC回收新生代垃圾，同时完成上面提到的初始标记</li>
<li>并发标记：Minor GC时完成了初始标记，当老年代占用内存超过阈值后，进行并发标记，这时无需暂停用户线程</li>
<li>混合回收：上面的最终标记+筛选回收</li>
</ul>
<h3 id="CMS和G1的区别？"><a href="#CMS和G1的区别？" class="headerlink" title="CMS和G1的区别？"></a>CMS和G1的区别？</h3><p>区别一：使用范围不一样</p>
<ul>
<li>CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用</li>
<li>G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用</li>
</ul>
<p>区别二：STW的时间</p>
<ul>
<li>CMS收集器以相应时间优先为目标</li>
<li>G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型）</li>
</ul>
<p>区别三：垃圾碎片</p>
<ul>
<li>CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片</li>
<li>G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。</li>
</ul>
<p>区别四：垃圾回收的过程不一样</p>
<ul>
<li>CMS收集器：初始标记、并发标记、重新标记、并发清除</li>
<li>G1收集器：初始标记、并发标记、最终标记、筛选回收</li>
</ul>
<h3 id="引用的几种方式？"><a href="#引用的几种方式？" class="headerlink" title="引用的几种方式？"></a>引用的几种方式？</h3><ol>
<li>强引用：强引用是在程序代码之中普遍存在的引用赋值，类似<code>Object o = new Object()</code>这种引用关系。无论任何情况下，只要强引用关系还在，垃圾收集器就<strong>永远不会回收</strong>掉被引用的对象。</li>
<li>软引用：用来描述一些还<strong>有用但非必须</strong>的对象。只被软引用关联的对象，<strong>在内存发生溢出之前会被回收。即可能有好几次回收都不回收它</strong>。 软引用自身想释放时需要配合<strong>引用队列</strong>来释放<br> 应用场景：做缓存（浏览器的后退按钮）</li>
<li>弱引用：也是用来描述那些<strong>有用但非必须</strong>对象，但它的强度比软引用更弱一些，<strong>这次不回收它，下次一定回收</strong></li>
<li>虚引用：最弱的一种引用关系，无法通过虚引用来获取一个对象，虚引用的唯一目的就是能在这个对象被回收时收到一个系统通知</li>
</ol>
<h3 id="如何判断对象是否可以回收？（垃圾判断算法）"><a href="#如何判断对象是否可以回收？（垃圾判断算法）" class="headerlink" title="如何判断对象是否可以回收？（垃圾判断算法）"></a>如何判断对象是否可以回收？（垃圾判断算法）</h3><ol>
<li><p>引用计数法</p>
<p> 给对象添加一个引用计数器，每当有一个地方引用它时，计数器就会加1；当引用失效时，计数器就减1，当计数器为0就是没有被使用的对象，但主流的Java虚拟机并没有选择用引用计数法来管理内存，因为<strong>无法解决对象之间相互循环引用的问题</strong>，就是两个对象相互引用，除此之外，两个对象并没有其他引用，这两个对象已经不可能被访问了，但他们的引用计数都不为0，所以无法被垃圾收集器回收。</p>
</li>
<li><p>可达性分析</p>
<p> 可达性分析法也被称之为<strong>根搜索法</strong>，将一系列的根对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，如果一个对象到根对象有引用链相连，该对象就是可达的，就不会被回收，如果是不可达的就会被判定是可以回收的。更准确的说，一个对象只要满足下述两个条件之一，就会被判断为可达的：</p>
<ul>
<li>对象是属于GC Roots中的对象：<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中的常量引用的对象</li>
<li>方法区中的类静态属性引用的对象</li>
<li>本地方法栈中本地方法的引用对象</li>
</ol>
</li>
<li>对象被一个可达的对象引用</li>
</ul>
</li>
</ol>
<p>可达性分析的优缺点：</p>
<ol>
<li><strong>优点</strong>：可以解决循环引用的问题，不需要占用额外的空间（这是引用计数法存在的问题）</li>
<li><strong>缺点</strong>：多线程场景下，其他线程可能会更新已经访问过的对象的引用</li>
</ol>
<h3 id="GC中Stop-the-world（STW）"><a href="#GC中Stop-the-world（STW）" class="headerlink" title="GC中Stop the world（STW）"></a>GC中Stop the world（STW）</h3><p>垃圾回收首先是要经过标记的，对象被标记后就会根据不同的区域采用不同的收集方法。垃圾回收并不会阻塞我们程序的线程，他是与当前程序并发执行的。所以问题就出在这里，当GC线程标记好了一个对象的时候，此时我们程序的线程又将该对象重新加入了“关系网”中，当执行二次标记的时候，该对象也没有重写finalize()方法，因此回收的时候就会回收这个不该回收的对象。 虚拟机的解决方法就是<strong>在一些特定指令位置设置一些“安全点”，当程序运行到这些“安全点”的时候就会暂停所有当前运行的线程（Stop The World 所以叫STW）</strong>，暂停后再找到“GC Roots”进行关系的组建，进而执行标记和清除。 </p>
<p>这些特定的指令（安全点）位置主要在：</p>
<ul>
<li>循环的末尾</li>
<li>方法临返回前 &#x2F; 调用方法的call指令后</li>
<li>可能抛异常的位置</li>
</ul>
<p>停顿类型就是STW，至于<strong>有GC和Full GC之分，主要是Full GC时STW的时间相对GC来说时间很长</strong>，因为Full GC针对整个堆以及永久代的，因此整个GC的范围大大增加；还有就是他的回收算法就是“标记–清除–整理”，这里也会损耗一定的时间。所以我们在优化JVM的时候，减少Full GC的次数也是经常用到的办法。</p>
<h3 id="有什么办法主动通知虚拟机进行垃圾回收？"><a href="#有什么办法主动通知虚拟机进行垃圾回收？" class="headerlink" title="有什么办法主动通知虚拟机进行垃圾回收？"></a>有什么办法主动通知虚拟机进行垃圾回收？</h3><p>可以通过调用system.gc() 方法通知虚拟机进行垃圾回收，但Java虚拟机规范并不能保证一定会执行。</p>
<h3 id="JVM中的永久代中会发生垃圾回收吗？元空间会发生垃圾回收吗？"><a href="#JVM中的永久代中会发生垃圾回收吗？元空间会发生垃圾回收吗？" class="headerlink" title="JVM中的永久代中会发生垃圾回收吗？元空间会发生垃圾回收吗？"></a>JVM中的永久代中会发生垃圾回收吗？元空间会发生垃圾回收吗？</h3><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h3 id="什么是类加载"><a href="#什么是类加载" class="headerlink" title="什么是类加载"></a>什么是类加载</h3><p>当需要某个类的时候，jvm会加载.class文件，并创建对应的class对象，将class文件加载到虚拟机的内存，这个过程被称为类的加载</p>
<p>类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。简言之：把类(class)装载进内存</p>
<h3 id="Java类加载的时机"><a href="#Java类加载的时机" class="headerlink" title="Java类加载的时机"></a>Java类加载的时机</h3><p>1、隐式加载：new创建类的实例</p>
<p>2、显示加载：loaderClass、forName</p>
<blockquote>
<p>forName和loaderClass区别？</p>
<ul>
<li>Class.forName()得到的class是已经初始化完成的</li>
<li>ClassLoader.loadClass()得到的class是还没有链接的</li>
</ul>
</blockquote>
<p>3、访问类的静态变量，或者为静态变量赋值</p>
<p>4、调用类的静态方法</p>
<p>5、使用反射创建某个类或者接口的Class对象</p>
<p>6、初始化某个类的子类</p>
<p>7、直接使用java.exe命令来运行某个类</p>
<h3 id="简述类的生命周期"><a href="#简述类的生命周期" class="headerlink" title="简述类的生命周期"></a>简述类的生命周期</h3><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，生命周期包括：</p>
<ul>
<li>加载</li>
<li>链接<ul>
<li>验证、准备、解析</li>
</ul>
</li>
<li>初始化</li>
<li>使用</li>
<li>卸载</li>
</ul>
<h3 id="Java类加载的过程"><a href="#Java类加载的过程" class="headerlink" title="Java类加载的过程"></a>Java类加载的过程</h3><p>当需要某个类的时候，jvm会将class文件加载到虚拟机的内存，并创建对应的class对象，这个过程被称为类的加载。</p>
<ul>
<li>加载：ClassLoader将类的字节码载入方法区，并在堆中创建一个class对象。如果此类的父类没有加载，先加载父类</li>
<li>链接<ul>
<li>验证：验证类是否符合 Class 规范，合法性、安全性检查</li>
<li>准备：为 static 变量分配空间，设置默认值<ul>
<li>static int i &#x3D; 5这里只是将i赋值为0，初始化的阶段再把i赋值为5</li>
<li>不包含final修饰的static，因为final在编译的时候就已经分配了（不管是基本类型还是引用类型）</li>
</ul>
</li>
<li>解析：将常量池的符号引用解析为直接引用（类A里用了类B，符号引用就是只知道有类B这样一个符号，直接引用知道B的地址）</li>
</ul>
</li>
<li>初始化：为 static 变量赋值，如果该类有父类就对父类进行初始化</li>
</ul>
<h3 id="类加载器有哪些"><a href="#类加载器有哪些" class="headerlink" title="类加载器有哪些"></a>类加载器有哪些</h3><ul>
<li>启动类加载器（Bootstrap ClassLoader）：由C++语言实现，是虚拟机自身的一部分，主要加载<code>JAVA_HOME/jre/lib</code>目录下的类，都是些核心类，也可通过在控制台输入指令，使得类被启动类加器加载</li>
<li>扩展类加载器（Extension ClassLoader）：由Java语言实现，独立于虚拟机外部，负责加载<code>JAVA_HOME/jre/lib/ext</code>目录下的类库。</li>
<li>应用程序类加载器（Application ClassLoader）：由Java语言实现，独立于虚拟机外部，负责加载用户路径上所指定的类库，如果程序中没有自己定义过的类加载器，一般情况这个是程序中的默认类加载器</li>
<li>自定义类加载器：加载自定义类</li>
</ul>
<h3 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h3><p>如果一个类收到了类加载的请求，它并不会自己先去加载，而是把这个请求委托给上级加载器去执行，如果上级加载器还有上级加载器，则进一步向上委托，依次递归，请求最后到达顶层的启动类加载器，如果上级能够完成类的加载任务，就会成功返回，如果上级加载器无法完成任务，下级加载器才会尝试自己去加载。</p>
<p>通俗理解：每个下级都很懒，遇到类加载的活都给上级干，直到上级说我也做不来的时候，下级才会想办法自己去加载。</p>
<p>其源码实现方式就是：自底向上检查类是否被加载，然后再自顶向下尝试加载类</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.png" srcset="/img/loading.gif" lazyload alt="image-20220304125301954"></p>
<h3 id="双亲委派模式的优点-x2F-目的"><a href="#双亲委派模式的优点-x2F-目的" class="headerlink" title="双亲委派模式的优点&#x2F;目的"></a>双亲委派模式的优点&#x2F;目的</h3><ul>
<li>让类的加载有优先次序，保证核心类优先加载，避免类的重复加载</li>
<li>让上级类加载器中的类对下级共享，反之不行，保证核心类不会被篡改</li>
</ul>
<p>例如，你自己编写了一个java.lang.Object类，也不会被加载，因为根据双亲委派机制，会由启动类加载器进行加载，会先加载位于rt.jar中的java.lang.Object类，并且其他子类加载器不会再去加载ava.lang.Object类。</p>
<h3 id="类加载器中的父类加载器和子类加载器是继承关系吗？"><a href="#类加载器中的父类加载器和子类加载器是继承关系吗？" class="headerlink" title="类加载器中的父类加载器和子类加载器是继承关系吗？"></a>类加载器中的父类加载器和子类加载器是继承关系吗？</h3><p>在双亲委派模型中，类加载器之间的父子关系一般不是以继承关系实现的，而是组合的关系来复用父加载器的代码的</p>
<blockquote>
<p>注意:</p>
<p>这里的双亲，翻译为上级似乎更为合适，因为它们并没有继承关系，只是级别不一样</p>
<p>我们一般理解的双亲都是父母，这里的双亲更多地表达的是“父母这一辈”的人而已，并不是说真的有一个 Mother ClassLoader 和一个 Father ClassLoader 。另外，类加载器之间的“父子”关系也不是通过继承来体现的，是由“优先级”来决定。</p>
<p>官方 API 文档的描述: The Java platform uses a delegation model for loading classes. The basic idea is that every class loader has a “parent” class loader. When loading a class, a class loader first “delegates” the search for the class to its parent class loader before attempting to find the class itself.</p>
</blockquote>
<h3 id="双亲委派机制的弊端是什么呢？"><a href="#双亲委派机制的弊端是什么呢？" class="headerlink" title="双亲委派机制的弊端是什么呢？"></a>双亲委派机制的弊端是什么呢？</h3><p>父类加载器的优先级是大于子类加载器的，只有父类加载器无法加载，子类加载器才会去尝试加载，这在大多数情况是没有问题的，因为越上层加载的类通常是基础类（像Object类），一般情况这些基础类都是被用户代码所调用的API</p>
<p>但基础类要是想调用用户的代码，那就会出问题了，因为第三方的类不能被启动类加载器加载。</p>
<h3 id="如何破坏双亲委派机制？"><a href="#如何破坏双亲委派机制？" class="headerlink" title="如何破坏双亲委派机制？"></a>如何破坏双亲委派机制？</h3><p>这个需要先去了解双亲委派是怎么实现的，看下java.lang.ClassLoader的loadClass()源码就知道了，这里就不展开写了，想破环双亲委派就自定义一个类加载器，重写其中的loadClass()方法即可。如果不想破坏双亲委派，那么重写findClass()方法。</p>
<h3 id="有哪些打破双亲委派机制的例子"><a href="#有哪些打破双亲委派机制的例子" class="headerlink" title="有哪些打破双亲委派机制的例子"></a>有哪些打破双亲委派机制的例子</h3><ul>
<li>在双亲委派出现之前，双亲委派模型是在JDK1.2引入的，在此之前就有自定义类加载器了，这些自然是没遵循双亲委派机制的</li>
<li>JIDI服务及前面提到的JDBC服务，如何解决这个问题呢？Java设计团队引入了上下文类加载器，<strong>通过上下文类加载器可以使得父类加载器请求子类加载器去完成类的加载动作</strong>。</li>
<li>tomcat等web服务器，因为一个web容器可以部署多个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，但不同版本的类库中的全限定名很可能是一样的，如果采取双亲委派机制，这里就无法加载多个相同的类，解决方法就是，破坏双亲委派原则，提供隔离的机制，为每个web容器提供一个单独的类加载器</li>
<li>用户对程序动态性的追求导致的，比如代码热替换、模块热部署等，已经成为Java模块化标准的OSGi，实现模块化热部署的关键是它自定义的类加载，每个程序模块都有自己的类加载器，当需要更换一个程序模块时，会把程序模块和类加载器一起替换掉实现代码的热替换</li>
</ul>
<h3 id="NoClassDefFoundError-和-ClassNotFoundException-有什么区别？略"><a href="#NoClassDefFoundError-和-ClassNotFoundException-有什么区别？略" class="headerlink" title="NoClassDefFoundError 和 ClassNotFoundException 有什么区别？略"></a>NoClassDefFoundError 和 ClassNotFoundException 有什么区别？<font color=red>略</font></h3><p>1、ClassNotFoundException：当应用程序运行的过程中尝试使用<strong>类加载器去加载Class文件的时候，如果没有在classpath中查找到指定的类</strong>，就会抛出ClassNotFoundException。一般情况下，当我们使用Class.forName()或者ClassLoader.loadClass()以及使用ClassLoader.findSystemClass()在运行时加载类的时候，如果类没有被找到，那么就会导致JVM抛出ClassNotFoundException。</p>
<p>2、NoClassDefFoundError：当JVM在加载一个类的时候，如果这个<strong>类在编译时是可用的，但是在运行时找不到这个类的定义</strong>的时候，JVM就会抛出一个NoClassDefFoundError错误。比如当我们在new一个类的实例的时候，如果在运行时类找不到，则会抛出一个NoClassDefFoundError的错误。</p>
<h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><p>虚拟机性能监控的一些命令</p>
<ul>
<li>jsp：JVM Process Status Tool，显示指定系统内所有的HotSpot虚拟机进程</li>
<li>jstat：JVM Statistics Monitoring Tool，用于收集HopSpot虚拟机各方面的运行数据，例如虚拟机进程中的类装载、内存、垃圾收集等数据</li>
<li>jinfo：Configuration Info for Java，显示虚拟机配置信息</li>
<li>jmap：Memory Map for Java，生成虚拟机的内存转储快照（headdump），还可以查询Java堆、永久代的详细信息等</li>
<li>jhat：JVM Heap Dump Browser，用于分析heapdump文件，它会建立一个HTTP&#x2F;HTML服务器，让用户在浏览器上查看分析结果</li>
<li>jstack：Stack Trace for Java，显示虚拟机的线程快照，查看各个线程的调用堆栈，可以定位线程出现长时间停顿的原因</li>
</ul>
<h3 id="JVM如何调优"><a href="#JVM如何调优" class="headerlink" title="JVM如何调优"></a>JVM如何调优</h3><p>本来这个地方只是想列几个常用的JVM参数就完了，毕竟大多数项目并不需要JVM调优，千万别项目中出了问题就想JVM调优，这绝对是本末倒置的做法。不过虽然项目中大概率用不到，但是面试会问啊，所以还是简单介绍下。</p>
<p>正常的情况下项目出问题或者系统优化应该先从应用层面开始，然后往底层过度，首先查查是不是代码写的太垃圾了，逻辑上有没有可优化的地方等等，然后再看看数据库有没有可优化的地方，在然后可以考虑JVM层面的优化，最后，可以考虑底层操作系统层面的优化。前两者基本就解决了大部分问题。</p>
<h3 id="JVM调优的目标"><a href="#JVM调优的目标" class="headerlink" title="JVM调优的目标"></a>JVM调优的目标</h3><p>大多数时候，JVM的调优最主要的目标是<strong>停顿时间和吞吐量</strong>，停顿时间一般是由垃圾收集引起的，可以简单理解为系统对请求的响应速度，吞吐量是指用户程序运行时间占用户程序运行时间和垃圾收集总时间的比值，可以简单理解为系统在特定时间内的最大工作量。还有一个指标是<strong>内存占用</strong>，程序正常运行所需要的内存，自然是越小越好。</p>
<p>JVM优化得目标就是系统以较小的内存资源获得较低的停顿时间和较高的吞吐量，这当然不现实了，又想马儿跑，还想马儿不吃草，所以还是要根据具体场景具体分析。</p>
<h3 id="JVM调优策略"><a href="#JVM调优策略" class="headerlink" title="JVM调优策略"></a>JVM调优策略</h3><p>JVM调优的具体策略基本都是围绕着两部分展开的：内存和垃圾回收器</p>
<ul>
<li>调整内存大小，如果内存太小，那么GC会非常频繁的，停顿时间自然就长了</li>
<li>调整新生代和老年代的比重等，比如IO密集型的，就可以把新生代加大些，因为大多数对象在新生代就会消亡</li>
<li>调整晋升老年代的年龄，比如老年代频繁GC，可以考虑增大老年代的比重，也可以提高晋升老年代的年龄</li>
<li>大对象分配的标准，因为大对象是直接进入老年代的，如果大对象的标准不合适，也会出现问题</li>
<li>选择合适的垃圾回收器及垃圾回收器的各种参数，比如如果是CPU是单核的，就选Serial就可以了等等</li>
<li>上面这只是简单举例，类似的情况还有很多，简单来说就是围绕着内存和垃圾回收器具体情况具体分析</li>
</ul>
<h3 id="JVM调优参数"><a href="#JVM调优参数" class="headerlink" title="JVM调优参数"></a>JVM调优参数</h3><p>前面说了调优策略主要是围绕着内存和垃圾回收器，那么可调的参数大多也是围绕这两个。</p>
<p>内存部分参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-Xms</td>
<td>初始堆大小</td>
</tr>
<tr>
<td>-Xmx</td>
<td>最大堆大小</td>
</tr>
<tr>
<td>-Xmn</td>
<td>新生代大小</td>
</tr>
<tr>
<td>-Xss</td>
<td>设置每个线程的堆栈大小</td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>设置新生代与年老代的比值</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>设置新生代中Eden区与Survivor区的大小比值</td>
</tr>
<tr>
<td>-XX:PermSize&#x2F;-XX:MetaspaceSize</td>
<td>初始化持久代&#x2F;元空间大小</td>
</tr>
<tr>
<td>-XX:MaxPermSize&#x2F;-XX:MaxMetaspaceSize</td>
<td>设置持久代&#x2F;元空间最大值</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold</td>
<td>设置进入老年代的年龄</td>
</tr>
</tbody></table>
<p>垃圾回收器相关参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:+UseG1GC</td>
<td>使用G1垃圾回收器</td>
</tr>
<tr>
<td>-XX:ParallelGCThreads</td>
<td>并行收集器的线程数</td>
</tr>
<tr>
<td>-XX:GCTimeRatio</td>
<td>设置垃圾回收时间占程序运行时间的百分比</td>
</tr>
<tr>
<td>-XX:MaxGCPauseMillis</td>
<td>设置目标停顿时间</td>
</tr>
</tbody></table>
<h3 id="JVM的调优步骤"><a href="#JVM的调优步骤" class="headerlink" title="JVM的调优步骤"></a>JVM的调优步骤</h3><p>JVM调优肯定不是乱调的，也应先确定瓶颈及调优目标，如下：</p>
<ul>
<li>分析GC日志及通过虚拟机监控的命令查看系统运行情况，找出哪里出了问题</li>
<li>确定调优的目标</li>
<li>确定调优策略及调整相关参数，这是个不断对比分析和调整的过程，很难一步到位的</li>
</ul>
<h3 id="JVM调优案例"><a href="#JVM调优案例" class="headerlink" title="JVM调优案例"></a>JVM调优案例</h3><p>前面简单介绍了JVM调优的方法和策略，下面从网上找了一些调优的案例，大家可以参考一下</p>
<ol>
<li>数据分析平台系统频繁 Full GC</li>
</ol>
<p>平台主要对用户在 App 中行为进行定时分析统计，并支持报表导出，使用 CMS GC 算法。数据分析师在使用中发现系统页面打开经常卡顿，通过 jstat 命令发现系统每次 Young GC 后大约有10% 的存活对象进入老年代。原来是因为 Survivor 区空间设置过小，每次 Young GC 后存活对象在 Survivor 区域放不下，提前进入老年代。</p>
<p>通过调大 Survivor 区，使得 Survivor 区可以容纳 Young GC 后存活对象，对象在 Survivor 区经历多次Young GC 达到年龄阈值才进入老年代。调整之后每次 Young GC 后进入老年代的存活对象稳定运行时仅几百 Kb，Full GC 频率大大降低。</p>
<ol start="2">
<li>业务对接网关 OOM</li>
</ol>
<p>网关主要消费 Kafka 数据，进行数据处理计算然后转发到另外的 Kafka 队列，系统运行几个小时候出现OOM，重启系统几个小时之后又 OOM。</p>
<p>通过 jmap 导出堆内存，在 eclipse MAT 工具分析才找出原因：代码中将某个业务 Kafka 的 topic 数据进行日志异步打印，该业务数据量较大，大量对象堆积在内存中等待被打印，导致 OOM。</p>
<ol start="3">
<li>鉴权系统频繁长时间 Full GC</li>
</ol>
<p>系统对外提供各种账号鉴权服务，使用时发现系统经常服务不可用，通过 Zabbix 的监控平台监控发现系统频繁发生长时间 Full GC，且触发时老年代的堆内存通常并没有占满，发现原来是业务代码中调用了System.gc()。</p>
<ol start="4">
<li>网站流量浏览量暴增后，网站反应页面响很慢。</li>
</ol>
<p>（1）问题推测：在测试环境测速度比较快，但是一到生产就变慢，所以推测可能是因为垃圾收集导致的业务线程停顿。</p>
<p>（2）定位：为了确认推测的正确性，在线上通过jstat -gc 指令 看到JVM进行GC 次数频率非常高，GC所占用的时间非常长，所以基本推断就是因为GC频率非常高，所以导致业务线程经常停顿，从而造成网页反应很慢。</p>
<p>（3）解决方案：因为网页访问量很高，所以对象创建速度非常快，导致堆内存容易填满从而频繁GC，所以这里问题在于新生代内存太小，所以这里可以增加JVM内存就行了，所以初步从原来的2G内存增加到16G内存。</p>
<p>（4）第二个问题：增加内存后的确平常的请求比较快了，但是又出现了另外一个问题，就是不定期的会间断性的卡顿，而且单次卡顿的时间要比之前要长很多。</p>
<p>（5）问题推测：联想到是之前的优化加大了内存，所以推测可能是因为内存加大了，从而导致单次GC的时间变长从而导致间接性的卡顿。</p>
<p>（6）定位：还是通过jstat -gc 指令 查看到 的确FGC（FULL GC）次数并不是很高，但是花费在FGC上的时间是非常高的,根据GC日志 查看到单次FGC的时间有达到几十秒的。</p>
<p>（7）解决方案： 因为JVM默认使用的是PS+PO的组合，PS+PO垃圾标记和收集阶段都是STW，所以内存加大了之后，需要进行垃圾回收的时间就变长了，所以这里要想避免单次GC时间过长，所以需要更换并发类的收集器，因为当前的JDK版本为1.7，所以最后选择G1垃圾收集器，根据之前垃圾收集情况设置了一个预期的停顿的时间，上线后网站再也没有了卡顿问题。</p>
<ol start="5">
<li>后台导出数据引发的OOM</li>
</ol>
<p>问题描述：公司的后台系统，偶发性的引发OOM异常，堆内存溢出。</p>
<p>（1）因为是偶发性的，所以第一次简单的认为就是堆内存不足导致，所以单方面的加大了堆内存从4G调整到8G。</p>
<p>（2）但是问题依然没有解决，只能从堆内存信息下手，通过开启了-XX:+HeapDumpOnOutOfMemoryError参数获得堆内存的dump文件。</p>
<p>（3）VisualVM 对 堆dump文件进行分析，通过VisualVM查看到占用内存最大的对象是String对象，本来想跟踪着String对象找到其引用的地方，但dump文件太大，跟踪进去的时候总是卡死，而String对象占用比较多也比较正常，最开始也没有认定就是这里的问题，于是就从线程信息里面找突破点。</p>
<p>（4）通过线程进行分析，先找到了几个正在运行的业务线程，然后逐一跟进业务线程看了下代码，发现有个引起我注意的方法，导出订单信息。</p>
<p>（5）因为订单信息导出这个方法可能会有几万的数据量，首先要从数据库里面查询出来订单信息，然后把订单信息生成excel，这个过程会产生大量的String对象。</p>
<p>（6）为了验证自己的猜想，于是准备登录后台去测试下，结果在测试的过程中发现到处订单的按钮前端居然没有做点击后按钮置灰交互事件，结果按钮可以一直点，因为导出订单数据本来就非常慢，使用的人员可能发现点击后很久后页面都没反应，结果就一直点，结果就大量的请求进入到后台，堆内存产生了大量的订单对象和EXCEL对象，而且方法执行非常慢，导致这一段时间内这些对象都无法被回收，所以最终导致内存溢出。</p>
<p>（7）知道了问题就容易解决了，最终没有调整任何JVM参数，只是在前端的导出订单按钮上加上了置灰状态，等后端响应之后按钮才可以进行点击，然后减少了查询订单信息的非必要字段来减少生成对象的体积，然后问题就解决了。</p>
<ol start="6">
<li>CPU经常100% 问题定位思路。</li>
</ol>
<p>问题分析：CPU高一定是某个程序长期占用了CPU资源。</p>
<p>（1）所以先需要找出那个进行占用CPU高。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">top</span> 列出系统各个进程的资源占用情况。<br></code></pre></td></tr></table></figure>

<p>（2）然后根据找到对应进行里哪个线程占用CPU高。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">top</span> -Hp 进程ID 列出对应进程里面的线程占用资源情况<br></code></pre></td></tr></table></figure>

<p>（3）找到对应线程ID后，再打印出对应线程的堆栈信息</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">printf</span> <span class="hljs-string">&quot;%x\n&quot;</span> PID 把线程ID转换为<span class="hljs-number">16</span>进制。<br><span class="hljs-attribute">jstack</span> PID 打印出进程的所有线程信息，从打印出来的线程信息中找到上一步转换为<span class="hljs-number">16</span>进制的线程ID对应的线程信息。<br></code></pre></td></tr></table></figure>

<p>（4）最后根据线程的堆栈信息定位到具体业务方法,从代码逻辑中找到问题所在。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">查看是否有线程长时间的watting 或blocked如果线程长期处于watting状态下， 关注watting <span class="hljs-keyword">on</span> xxxxxx，说明线程在等待这把锁，然后根据锁的地址找到持有锁的线程。<br></code></pre></td></tr></table></figure>



<ol start="7">
<li>内存飚高问题定位思路。</li>
</ol>
<p>分析： 内存飚高如果是发生在java进程上，一般是因为创建了大量对象所导致，持续飚高说明垃圾回收跟不上对象创建的速度，或者内存泄露导致对象无法回收。</p>
<p>（1）先观察垃圾回收的情况</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">jstat</span> -gc PID <span class="hljs-number">1000</span> 查看GC次数，时间等信息，每隔一秒打印一次。<br><span class="hljs-attribute">jmap</span> -histo PID | head -<span class="hljs-number">20</span> 查看堆内存占用空间最大的前<span class="hljs-number">20</span>个对象类型,可初步查看是哪个对象占用了内存。<br></code></pre></td></tr></table></figure>

<p>如果每次GC次数频繁，而且每次回收的内存空间也正常，那说明是因为对象创建速度快导致内存一直占用很高；如果每次回收的内存非常少，那么很可能是因为内存泄露导致内存一直无法被回收。</p>
<p>（2）导出堆内存文件快照</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">jmap -<span class="hljs-keyword">dump</span>:live,format=b,<span class="hljs-keyword">file</span>=<span class="hljs-regexp">/home/my</span>heapdump.hprof PID        <span class="hljs-keyword">dump</span>堆内存信息到文件。<br></code></pre></td></tr></table></figure>

<p>（3）使用visualVM对dump文件进行离线分析，找到占用内存高的对象，再找到创建该对象的业务代码位置，从代码和业务场景中定位具体问题。</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="多线程、互斥与同步"><a href="#多线程、互斥与同步" class="headerlink" title="多线程、互斥与同步"></a>多线程、互斥与同步</h2><h3 id="什么是进程？是什么线程？进程和线程的关系？（区别）"><a href="#什么是进程？是什么线程？进程和线程的关系？（区别）" class="headerlink" title="什么是进程？是什么线程？进程和线程的关系？（区别）"></a>什么是进程？是什么线程？进程和线程的关系？（区别）</h3><p>线程是处理器<strong>任务调度和执行</strong>的基本单位</p>
<p>进程是操作系统<strong>资源分配</strong>的基本单位。</p>
<blockquote>
<p><strong>进程就可以视为程序的一个实例</strong>。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</p>
</blockquote>
<p>进程是程序的一次执行过程，是系统运行的基本单位。线程是一个比进程更小的执行单位，一个进程可以包含多个线程，真正执行任务的是线程</p>
<p>从Java虚拟机的角度来理解：Java虚拟机的运行时数据区包含堆、方法区、虚拟机栈、本地方法栈、程序计数器。</p>
<p>各个进程之间是相互独立的，每个进程会包含多个线程，每个进程所包含的多个线程并不是相互独立的，这个线程会<strong>共享进程的堆和方法区</strong>，但这些线程不会共享虚拟机栈、本地方法栈、程序计数器。即每个进程所包含的多个线程共享进程的堆和方法区，并且具备私有的虚拟机栈、本地方法栈、程序计数器，如图所示，假设某个进程包含三个线程。</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java/JUC/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB.png" srcset="/img/loading.gif" lazyload alt="image-20220514233844593"></p>
<p>由上面可知以下进程和线程在以下几个方面的区别：</p>
<ul>
<li>内存分配：进程和进程之间的地址空间和资源是相互独立的，同一个进程里的线程会共享线程的地址空间和资源（堆和方法区）。</li>
<li>资源开销：每个进程具备各自的数据空间，进程之间的切换会有较大的开销。属于同一进程的线程会共享堆和方法区，同时具备私有的虚拟机栈、本地方法栈、程序计数器，线程之间的切换资源开销较小。</li>
<li>通信复杂程度：进程间通信较为复杂，同一台计算机的进程通信称为 IPC，不同计算机之间的进程通信，需要通过网络；线程通信相对简单，因为它们共享进程内的内存（比如多个线程可以访问同一个共享变量）</li>
</ul>
<h3 id="并行和并发的区别？"><a href="#并行和并发的区别？" class="headerlink" title="并行和并发的区别？"></a>并行和并发的区别？</h3><p>并发(concurrent)：一个单核CPU处理多个任务，在不同的时间轮流执行不同线程中的指令。并发</p>
<blockquote>
<p>虽然叫并发，但实际是串行执行，CPU的时间片切换非常快，给人一种同时运行的感觉。微观串行，宏观并行<br>（操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于cpu 在线程间（时间片很短）的切换非常快，给人的感觉是同时运行的 。）</p>
</blockquote>
<p>并行(concurrent)：系统有一个以上CPU（或者说是核）时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行</p>
<blockquote>
<p>并行中也可能存在并发，比如说2核cpu, 同时执行4个线程. 理论上同时可以有2个线程是并行执行的. 此时还是存在并发， 因为2个cpu也会同时切换不同的线程执行任务罢了</p>
</blockquote>
<p>并发，一个CPU看起来“同时”做多件事。</p>
<p>并行，多个CPU真的在同时做多件事。</p>
<h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>以调用方角度来讲，如果</p>
<ul>
<li>需要等待结果返回，才能继续运行就是<strong>同步</strong></li>
<li>不需要等待结果返回，就能继续运行就是<strong>异步</strong></li>
</ul>
<p>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如 果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停…</p>
<h3 id="多线程的优缺点（为什么使用多线程、多线程会引发什么问题）"><a href="#多线程的优缺点（为什么使用多线程、多线程会引发什么问题）" class="headerlink" title="多线程的优缺点（为什么使用多线程、多线程会引发什么问题）"></a>多线程的优缺点（为什么使用多线程、多线程会引发什么问题）</h3><p>优点：当一个线程进入等待状态或者阻塞时，CPU可以先去执行其他线程，提高CPU的利用率。</p>
<p>缺点：</p>
<ul>
<li>上下文切换：频繁的上下文切换会影响多线程的执行速度。</li>
<li>死锁</li>
<li>资源限制：在进行并发编程时，程序的执行速度受限于计算机的硬件或软件资源。并发编程中程序执行变快的原因是将程序中串行执行的部分变成并发执行，如果因为资源限制，并发执行的部分仍在串行执行，程序执行将会变得更慢，因为程序并发需要上下文切换和资源调度。</li>
</ul>
<p>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活</p>
<p>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的</p>
<ul>
<li><p>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分（阿姆达尔定律）</p>
</li>
<li><p>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</p>
</li>
</ul>
<p>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有【非阻塞 IO】和【异步 IO】优化</p>
<h3 id="线程的上下文切换（Thread-Context-Switch）"><a href="#线程的上下文切换（Thread-Context-Switch）" class="headerlink" title="线程的上下文切换（Thread Context Switch）"></a>线程的上下文切换（Thread Context Switch）</h3><p>所谓的上下文切换其实也就是<strong>线程切换</strong>，即cpu 不再执行当前的线程，转而执行另一个线程的代码。一般会是因为以下几种情况：分给线程的 cpu 时间片用完；垃圾回收；有更高优先级的线程需要运行；线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</p>
<p>当线程切换发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是<strong>程序计数器</strong>（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p>
<ul>
<li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li>
<li><strong>线程切换频繁发生会影响性能</strong></li>
</ul>
<p>即便是单核的处理器也会支持多线程，处理器会给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给每个线程的执行时间，一般来说时间片非常的短，所以处理器会不停地切换线程。CPU会通过时间片分配算法来循环执行任务，当前任务执行完一个时间片后会切换到下一个任务，但切换前会保存上一个任务的状态，因为下次切换回这个任务时还要加载这个任务的状态继续执行，从任务保存到再加载的过程就是一次上下文切换。</p>
<h3 id="什么是线程互斥？什么是线程同步？他们是如何实现的？"><a href="#什么是线程互斥？什么是线程同步？他们是如何实现的？" class="headerlink" title="什么是线程互斥？什么是线程同步？他们是如何实现的？"></a>什么是线程互斥？什么是线程同步？他们是如何实现的？</h3><p>线程的互斥：指某一个资源只能<strong>被一个访问者访问</strong>，具有唯一性和排他性。但访问者对资源访问的顺序是<strong>乱序</strong>的。</p>
<blockquote>
<p>一段代码块内如果存在对<strong>共享资源的多线程读写操作</strong>，称这段代码块为<strong>临界区</strong>，由于代码的执行序列不同而导致结果无法预测，称之为发生了<strong>竞态条件</strong>，为了避免临界区的竞态条件发生，要让他们互斥</p>
</blockquote>
<p>线程互斥的实现方法：</p>
<ul>
<li>阻塞式的解决方案：synchronized，Lock</li>
<li>非阻塞式的解决方案：原子变量</li>
</ul>
<p>线程的同步：指<strong>在互斥的基础上</strong>使得访问者对资源进行<strong>有序</strong>访问。</p>
<p>线程同步的实现方法：</p>
<ul>
<li>同步方法、同步代码块</li>
<li>wait() 和notify()</li>
<li>使用volatile实现线程同步</li>
<li>使用重入锁实现线程同步</li>
<li>使用局部变量实现线程同步</li>
<li>使用阻塞队列实现线程同步</li>
</ul>
<h3 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h3><p>（1）成员变量和静态变量</p>
<ul>
<li>如果它们没有共享，则线程安全</li>
<li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况<ul>
<li>如果只有读操作，则线程安全</li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li>
</ul>
</li>
</ul>
<p>（2）局部变量</p>
<ul>
<li><p><strong>基本数据类型</strong>的局部变量是线程安全的，每个线程的栈帧内存中局部变量会被创建多份，不会共享</p>
</li>
<li><p>局部变量<strong>引用的对象</strong>会被共享，如果执行了读写操作，则<strong>线程不安全</strong>。如果没被共享或者被共享但没读写，也可能是线程安全的</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadUnsafe</span> &#123;<br>    ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <span class="hljs-comment">// list是成员变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>        <span class="hljs-comment">// &#123; 临界区, 会产生竞态条件</span><br>            method2();<br>            method3();<br>        <span class="hljs-comment">// &#125; 临界区</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//注意此处方法定义为private</span><br>        list.add(<span class="hljs-string">&quot;666&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//注意此处方法定义为private</span><br>        list.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  碰到上面这种<strong>共享的成员变量</strong>情况，可以改成线程内<strong>私有的局部变量</strong>，则会在堆中创建每个线程自己对应的对象，不会存在线程安全问题。</p>
<p>  如下代码中，将成员变量 list 修改为方法1的局部变量，那么就不会有上述问题了。list 是局部变量，每个线程调用时会创建其不同实例，没有共享。而 method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象。method3 的参数分析与 method2 相同</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafe</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <span class="hljs-comment">//改为局部变量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            method2(list);<br>            method3(list);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;   <span class="hljs-comment">//局部变量传进来，</span><br>        list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;   <span class="hljs-comment">//注意此处方法定义为private</span><br>        list.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>（3）方法修饰符保护引用暴露</p>
<p>如果把上个例子的method2或method3访问修饰权限改为public，就可以有子类去继承ThreadSafe并覆盖method2或method3，那就可能存在线程安全问题，因为父类方法管不了子类覆盖方法的内容，子类对象单独调用method2或method3和父类调用method1的是同一个list，存在线程安全问题。</p>
<p>因此，得到的启发是，<strong>方法的访问修饰符是很有意义的，一定程度上能够保护线程安全，<code>private</code>修饰符限制了子类方法不能覆盖父类方法</strong>（一个类的private方法会隐式的被指定为final方法）。对于public修饰的公共方法如果不想让子类覆盖，加上<code>final</code>修饰符。</p>
<h3 id="常见的线程安全类"><a href="#常见的线程安全类" class="headerlink" title="常见的线程安全类"></a>常见的线程安全类</h3><p>String、Integer、StringBuﬀer、Random、Vector （List的线程安全实现类）、Hashtable （Hash的线程安全实现类）、java.util.concurrent 包下的类</p>
<p>这里说它们是线程安全的是指，多个线程调用它们<strong>同一个实例的某一个方法时</strong>，是线程安全的。因为它们的每个方法是原子的（都被加上了synchronized）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//不会有线程安全问题</span><br><span class="hljs-type">Hashtable</span> <span class="hljs-variable">table</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>	table.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>&#125;).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>	table.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>&#125;).start();<br></code></pre></td></tr></table></figure>

<p>但注意它们<strong>多个方法的组合不是原子的</strong>，所以可能会出现线程安全问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 可能有线程安全问题，线程1刚get完判断为null，随即线程2进入时间片，get判断为null，put了value2后，线程1得到时间片，其实已经不是null了，但它仍然会put value1</span><br><span class="hljs-type">Hashtable</span> <span class="hljs-variable">table</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>();<br><span class="hljs-keyword">if</span>( table.get(<span class="hljs-string">&quot;key&quot;</span>) == <span class="hljs-literal">null</span>) &#123;<br>	table.put(<span class="hljs-string">&quot;key&quot;</span>, value);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>String、Integer 等都是<strong>不可变类</strong>，因为其内部的状态不可以改变，因此它们的方法都是线程安全的。虽然他们有replace，substring 等方法可以”改变值“，那么这些方法又是如何保证线程安全的呢？这是因为这些方法的返回值都<strong>创建了一个新的对象</strong>，而不是直接改变String、Integer对象本身。</p>
<h3 id="线程死锁是如何产生的，如何避免"><a href="#线程死锁是如何产生的，如何避免" class="headerlink" title="线程死锁是如何产生的，如何避免"></a>线程死锁是如何产生的，如何避免</h3><p>死锁：由于两个或两个以上的线程相互竞争对方的资源，而同时不释放自己的资源，导致所有线程同时被阻塞。</p>
<p>死锁产生的条件：</p>
<ul>
<li>互斥条件：一个资源在同一时刻只由一个线程占用。</li>
<li>请求与保持条件：一个线程在请求被占资源时发生阻塞，并对已获得的资源保持不放。</li>
<li>循环等待条件：发生死锁时，所有的线程会形成一个死循环，一直阻塞。</li>
<li>不剥夺条件：线程已获得的资源在未使用完不能被其他线程剥夺，只能由自己使用完释放资源。</li>
</ul>
<p>避免死锁的方法主要是破坏死锁产生的条件。</p>
<ul>
<li><p>破坏互斥条件：这个条件无法进行破坏，锁的作用就是使他们互斥。</p>
</li>
<li><p>破坏请求与保持条件：一次性申请所有的资源。</p>
</li>
<li><p>破坏循环等待条件：按<strong>顺序</strong>来申请资源。不过也可能<strong>会导致饥饿</strong>问题</p>
</li>
<li><p>破坏不剥夺条件：线程一段时间申请不到所需资源时，主动放弃所持有的资源。</p>
<p>​</p>
</li>
</ul>
<h3 id="Java中的死锁、活锁、饥饿有什么区别？"><a href="#Java中的死锁、活锁、饥饿有什么区别？" class="headerlink" title="Java中的死锁、活锁、饥饿有什么区别？"></a>Java中的死锁、活锁、饥饿有什么区别？</h3><p>活锁：两个线程<strong>互相改变对方的结束条件</strong>，谁也无法结束。例如线程1一直–，减到0才退出，线程2一直++，加到20才退出，互相改变对方的结束条件，谁也无法结束</p>
<p>避免活锁：在线程执行时，中途给予<strong>不同的间隔时间</strong>即可</p>
<p>活锁和死锁的区别：活锁是在不断地尝试、死锁是在一直等待。活锁有可能自行解开、死锁无法自行解开。</p>
<p>饥饿：线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束。以打印机打印文件为例，当有多个线程需要打印文件，系统按照短文件优先的策略进行打印，但当短文件的打印任务一直不间断地出现，那长文件的打印任务会被一直推迟，导致饥饿。</p>
<p>产生饥饿的原因：高优先级的线程占用了低优先级线程的CPU时间，线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</p>
<p>死锁、饥饿的区别：饥饿可自行解开，死锁不行。</p>
<h3 id="Java内存的可见性问题"><a href="#Java内存的可见性问题" class="headerlink" title="Java内存的可见性问题"></a>Java内存的可见性问题</h3><p>Java内存模型规定，线程对共享变量的操作必须在自己的本地内存中进行，不能直接在主内存中操作共享变量。这会导致内存不可见的问题。如下图，一开始run是true，t1读到的也是true，但是t1是把他读到了自己线程的本地内存（高速缓存）里，这就导致主线程对run的修改对t1来说是不可见的</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%BB%E5%AD%98%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98.png" srcset="/img/loading.gif" lazyload alt="image-20220121221529370"></p>
<p>通过synchronized 关键字（重量级锁，性能低）和 volatile 关键字就可以解决（volatile 变量都是<strong>直接操作主存</strong>）。</p>
<h2 id="线程的创建、调度和状态"><a href="#线程的创建、调度和状态" class="headerlink" title="线程的创建、调度和状态"></a>线程的创建、调度和状态</h2><h3 id="创建线程一共有哪几种方法？"><a href="#创建线程一共有哪几种方法？" class="headerlink" title="创建线程一共有哪几种方法？"></a>创建线程一共有哪几种方法？</h3><p>继承 Thread 类创建线程</p>
<p>实现 Runnable 接口创建线程</p>
<p>使用Callable 和FutureTask 创建线程</p>
<p>使用线程池例如用Executor 框架</p>
<p>方法一：继承Thread 类创建线程，重写run方法，主函数里调用实例的start方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadDemo</span> <span class="hljs-variable">threadDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadDemo</span>();<br>        threadDemo.start();<br>        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-number">17</span>:<span class="hljs-number">52</span>:<span class="hljs-number">22.974</span> [main] <span class="hljs-symbol">DEBUG</span> <span class="hljs-symbol">Code01_CreateThread</span>.<span class="hljs-symbol">ThreadDemo</span> - running...<br><span class="hljs-number">17</span>:<span class="hljs-number">52</span>:<span class="hljs-number">22.974</span> [<span class="hljs-symbol">Thread</span><span class="hljs-number">-0</span>] <span class="hljs-symbol">DEBUG</span> <span class="hljs-symbol">Code01_CreateThread</span>.<span class="hljs-symbol">ThreadDemo</span> - running...<br></code></pre></td></tr></table></figure>

<p>或者用匿名内部类的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CreateThread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;Thread-0&quot;</span>) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>            &#125;<br>        &#125;;<br>        myThread.start();<br>        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此方法缺点：Java不支持多继承，如果继承了Thread类，那么就不能再继承其他类。任务与代码没有分离，当多个线程执行一样的任务时需要多份任务代码</p>
<p>方法二：实现Runnable 接口创建线程</p>
<p>Runnable接口写的是线程里实现的任务，需要重写run方法。Thread的构造方法第一个参数就是Runnable 类型的参数，传到最后就是调用Runnable 的run方法。第二个参数是线程名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>            log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable, <span class="hljs-string">&quot;Thread-0&quot;</span>);<br>    thread.start();<br>    log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">17:54:34.180 [main] <span class="hljs-built_in">DEBUG</span> Code01_CreateThread.RunnableTest - running<br>17:54:34.180 [Thread-0] <span class="hljs-built_in">DEBUG</span> Code01_CreateThread.RunnableDemo - running<span class="hljs-built_in">..</span>.<br></code></pre></td></tr></table></figure>

<p>使用lamda表达式简写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; log.debug(<span class="hljs-string">&quot;running...&quot;</span>); <span class="hljs-comment">//任务有多行语句也可以加上大括号</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br>    thread.start();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>进一步简写，将任务对象也用lambda 形式，写到线程的第一个参数里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; log.debug(<span class="hljs-string">&quot;running...&quot;</span>), <span class="hljs-string">&quot;Thread-0&quot;</span>);<br>    thread.start();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>方法二的优点：把线程和任务分开了，用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</p>
<p>方法三：使用Callable 和FutureTask 创建线程</p>
<ol>
<li>创建Callable接口的实现类CallableDemo ，重写call() 方法。</li>
<li>以类CallableDemo 的实例化对象作为参数创建FutureTask 对象。</li>
<li>以FutureTask 对象作为参数，创建Thread 对象。</li>
<li>调用Thread 对象的start() 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CreateThread3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-comment">// 创建任务对象</span><br>        FutureTask&lt;Integer&gt; futuretask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;);<br>        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br><br>        <span class="hljs-comment">// 创建线程对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futuretask, <span class="hljs-string">&quot;myThread&quot;</span>);<br>        thread.start();<br><br>        <span class="hljs-comment">// 主线程阻塞，同步等待 task 执行完毕的结果</span><br>        log.debug(<span class="hljs-string">&quot;阻塞了&#123;&#125;s&quot;</span>,futuretask.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">18:04:07.643 [main] <span class="hljs-built_in">DEBUG</span> Code01_CreateThread.CreateThread3 - running<span class="hljs-built_in">..</span>.<br>18:04:07.645 [myThread] <span class="hljs-built_in">DEBUG</span> Code01_CreateThread.CreateThread3 - running<span class="hljs-built_in">..</span>.<br>18:04:09.660 [main] <span class="hljs-built_in">DEBUG</span> Code01_CreateThread.CreateThread3 - 阻塞了2s<br></code></pre></td></tr></table></figure>

<p>方法三的优点：可以获得返回值</p>
<p>方法四：使用线程池例如用Executor 框架</p>
<p>使用线程池例如用Executor框架： Executors 可提供四种线程池，分别为：</p>
<ul>
<li><p>newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>
</li>
<li><p>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p>
</li>
<li><p>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p>
</li>
<li><p>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。</p>
</li>
</ul>
<h3 id="runnable-和-callable-有什么区别？"><a href="#runnable-和-callable-有什么区别？" class="headerlink" title="runnable 和 callable 有什么区别？"></a>runnable 和 callable 有什么区别？</h3><p>相同点：</p>
<ul>
<li>两者都是接口</li>
<li>两者都需要调用Thread.start 启动线程</li>
</ul>
<p>不同点：</p>
<ul>
<li>callable的核心是call() 方法，允许返回值， runnable 的核心是run() 方法，没有返回值</li>
<li>call() 方法可以抛出异常，但是run() 方法不行</li>
<li>callable 和runnable 都可以应用于executors ， thread 类只支持runnable</li>
</ul>
<h3 id="线程的run-和start-有什么区别？"><a href="#线程的run-和start-有什么区别？" class="headerlink" title="线程的run()和start()有什么区别？"></a>线程的run()和start()有什么区别？</h3><p>线程是通过Thread 对象所对应的方法run() 来<strong>完成</strong>其操作的，而线程的<strong>启动</strong>是通过start() 方法执行的。</p>
<p>run() 方法可以重复调用， start() 方法只能调用一次</p>
<h3 id="为什么调用start-方法时会执行run-方法，而不直接执行run-方法？"><a href="#为什么调用start-方法时会执行run-方法，而不直接执行run-方法？" class="headerlink" title="为什么调用start()方法时会执行run()方法，而不直接执行run()方法？"></a>为什么调用start()方法时会执行run()方法，而不直接执行run()方法？</h3><p>通过调用Thread类的 start() 方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run() 方法，这里方法run() 称为线程体，它包含了要执行的这个线程的内容， run() 方法运行结束，此线程随即终止。start() 方法启动线程才真正实现了多线程运行</p>
<p>run() 方法只是类的一个普通方法而已，如果直接调用 run 方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run() 方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。</p>
<p>调用start() 方法可以开启一个线程，而run() 方法只是thread类中的一个普通方法，直接调用run() 方法还是在主线程中执行的。</p>
<h3 id="线程的sleep-方法和yield-方法有什么不同？"><a href="#线程的sleep-方法和yield-方法有什么不同？" class="headerlink" title="线程的sleep()方法和yield()方法有什么不同？"></a>线程的sleep()方法和yield()方法有什么不同？</h3><p>sleep() 方法会使得当前线程暂停指定的毫秒数，让当前线程从 <strong>Running 进入 Timed Waiting （阻塞）状态</strong>。调用sleep方法会抛出异常InterruptedException。 处于阻塞状态的线程，CPU不会给其分配时间片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SleepTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;finish...&quot;</span>);<br>        &#125;);<br>        thread.start();<br>        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">21:22:44.896 [Thread-0] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - running<span class="hljs-built_in">..</span>.<br>21:22:44.896 [main] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - running<span class="hljs-built_in">..</span>.<br>21:22:46.904 [Thread-0] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - finish<span class="hljs-built_in">..</span>.<br></code></pre></td></tr></table></figure>

<p>yield()方法 <strong>提示</strong>调度器当前线程愿意放弃当前的CPU资源，调度器如果接受这个提示会执行其他线程，当前线程从 <strong>Running 进入  Runnable（就绪）状态</strong>。但如果CPU太闲，也会不接受这个提示，依然执行当前线程。</p>
<p>所以sleep() 一定会完成给定的休眠时间， yield() 不一定能完成。</p>
<p>sleep() 需要抛出InterruptedException，而yield() 方法无需抛出异常。</p>
<h3 id="为什么Thread类的sleep-和yield-方法是静态的？"><a href="#为什么Thread类的sleep-和yield-方法是静态的？" class="headerlink" title="为什么Thread类的sleep()和yield()方法是静态的？"></a>为什么Thread类的sleep()和yield()方法是静态的？</h3><p>sleep() 和yield() 都是需要正在执行的线程调用的，那些本来就阻塞或者等待的线程调用这个方法是无意义的，所以这两个方法是静态的。其他Thread的静态方法同理</p>
<h3 id="sleep-方法和wait-方法的区别？"><a href="#sleep-方法和wait-方法的区别？" class="headerlink" title="sleep()方法和wait()方法的区别？"></a>sleep()方法和wait()方法的区别？</h3><p>相同点：</p>
<ul>
<li>wait() 方法和sleep() 方法都可以使得线程进入到阻塞状态。</li>
<li>wait() 和sleep() 方法都是可中断方法，被中断后都会收到中断异常。</li>
</ul>
<p>不同点：</p>
<ul>
<li>wait() 是Object的方法， sleep() 是Thread的方法。</li>
<li>wait() 必须在同步方法中进行（即加了锁的对象），sleep() 方法不需要。</li>
<li>线程在同步方法中执行sleep() 方法，不会释放monitor的锁，而wait() 方法会释放monitor的锁。</li>
<li>sleep() 方法在短暂的休眠之后会主动退出阻塞，而wait() 方法在没有指定wait时间的情况下需要被其他线程中断才可以退出阻塞。</li>
</ul>
<h3 id="为什么wait-、notify-、notifyAll-被定义在Object类中而不是在Thread类中？"><a href="#为什么wait-、notify-、notifyAll-被定义在Object类中而不是在Thread类中？" class="headerlink" title="为什么wait()、notify()、notifyAll()被定义在Object类中而不是在Thread类中？"></a>为什么wait()、notify()、notifyAll()被定义在Object类中而不是在Thread类中？</h3><p>因为这些方法在操作同步线程时，都必须要标识他们操作线程的锁，只有同一个锁上的被等待线程，可以被同一个锁上的notify() 或notifyAll() 唤醒，不可以对不同锁中的线程进行唤醒，也就是说等待和唤醒必须是同一锁。而锁可以是任意对象，所以可以被任意对象调用的方法是定义在Object 类中。</p>
<p>如果把wait() 、notify() 、notifyAll() 定义在Thread类中，则会出现一些难以解决的问题，例如如何让一个线程可以持有多把锁？如何确定线程等待的是哪把锁？既然是当前线程去等待某个对象的锁，则应通过操作对象来实现而不是操作线程，而Object类是所有对象的父类，所以将这三种方法定义在Object类中最合适。</p>
<h3 id="为什么wait-，notify-和notifyAll-必须在同步方法或者同步块中被调用？"><a href="#为什么wait-，notify-和notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="为什么wait()，notify()和notifyAll()必须在同步方法或者同步块中被调用？"></a>为什么wait()，notify()和notifyAll()必须在同步方法或者同步块中被调用？</h3><p>因为wait() 暂停的是持有锁的对象， notify() 或notifyAll() 唤醒的是等待锁的对象。所以wait() 、notify() 、notifyAll() 都需要线程持有锁的对象，进而需要在同步方法或者同步块中被调用。</p>
<h3 id="wait-方法一般在循环块中使用还是if块中使用？"><a href="#wait-方法一般在循环块中使用还是if块中使用？" class="headerlink" title="wait()方法一般在循环块中使用还是if块中使用？"></a>wait()方法一般在循环块中使用还是if块中使用？</h3><p>在JDK官方文档中明确要求了要在循环中使用，否则可能出现虚假唤醒的可能</p>
<h3 id="线程通信的方法有哪些？"><a href="#线程通信的方法有哪些？" class="headerlink" title="线程通信的方法有哪些？"></a>线程通信的方法有哪些？</h3><p>syncrhoized 加锁的线程的Object 类的 wait() &#x2F; notify() &#x2F; notifyAll()</p>
<p>ReentrantLock 类加锁的线程的Condition 类的await() &#x2F; signal() &#x2F; signalAll()</p>
<p>通过管道进行线程间通信：1）字节流；2）字符流 ，就是一个线程发送数据到输出管道，另一个线程从输入管道读数据。</p>
<h3 id="如何停止一个正在运行的线程？"><a href="#如何停止一个正在运行的线程？" class="headerlink" title="如何停止一个正在运行的线程？"></a>如何停止一个正在运行的线程？</h3><ul>
<li><p>interrupt() 用于打断线程，每个线程会有一个标志位<code>isInterrupted()</code>，用于记录打断的状态，默认是false</p>
<ul>
<li>如果是打断正处于sleep，wait，join 的线程（这几个方法都会让线程进入阻塞状态），会清空打断状态，打断状态为false</li>
<li>打断正常运行的线程，不会清空打断标记，打断标记为true，<strong>但打断的线程不会停止</strong>，会继续执行。如果要让线程在被打断后停下来，需要<strong>使用打断标记来判断，break掉循环</strong>，这是一种更优雅的处理方式。<font color=red>模式之两阶段终止</font></li>
</ul>
</li>
<li><p>使用volatile boolean 标志位停止线程：在线程中设置一个 boolean 标志位，同时用volatile修饰保证可见性，在线程里不断地读取这个值，其他地方可以修改这个boolean 值。</p>
</li>
</ul>
<h3 id="如何唤醒一个阻塞的线程？"><a href="#如何唤醒一个阻塞的线程？" class="headerlink" title="如何唤醒一个阻塞的线程？"></a>如何唤醒一个阻塞的线程？</h3><p>如果线程是由于wait() 、sleep() 、join() 、yield() 等方法进入阻塞状态的，是可以进行唤醒的。如果线程是IO阻塞是无法进行唤醒的，因为IO是操作系统层面的，Java代码无法直接接触操作系统。</p>
<ul>
<li><p>join()：与sleep() 方法一样，是一个可中断的方法，在一个线程中调用另一个线程的join()方法，会使得当前的线程挂起，直到执行join() 方法的线程结束。例如在B线程中调用A线程的join() 方法，B线程进入阻塞状态，直到A线程结束或者到达指定的时间（ join(）的参数）</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(...);<br>thread.join();   <span class="hljs-comment">//主线程里调用该方法，即等待thread线程执行结束才执行主线程</span><br><br>thread.join(<span class="hljs-number">1000</span>);<span class="hljs-comment">//最多等待1000ms，就会继续执行主线程，thread没执行完也不管</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>wait() ：可用notify() 或notifyAll() 方法唤醒。</p>
</li>
<li><p>sleep() ：调用该方法使得线程在指定时间内进入阻塞状态，等到指定时间过去，线程再次获取到CPU时间片进而被唤醒。</p>
</li>
<li><p>yield() ：使得当前线程放弃CPU时间片，但随时可能再次得到CPU时间片进而激活。</p>
</li>
<li><p>LockSupport.park()&#x2F;LockSupport.unpark(Thread t1)：暂停和恢复线程的运行</p>
</li>
</ul>
<h3 id="Java中守护线程和用户线程的区别？"><a href="#Java中守护线程和用户线程的区别？" class="headerlink" title="Java中守护线程和用户线程的区别？"></a>Java中守护线程和用户线程的区别？</h3><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守<br>护线程运行结束了，即使守护线程的代码没有执行完，Java 进程（Java虚拟机）也会强制结束。</p>
<p>用户线程：平时使用到的线程均为用户线程。</p>
<p>守护线程：用来服务用户线程的线程，例如垃圾回收线程。</p>
<p>任何线程都可以设置为守护线程和用户线程，通过方法<code>Thread.setDaemon(boolon)</code> 设置， true 则是将该线程设置为守护线程， false 则是将该线程设置为用户线程（默认为false）。同时， <code>Thread.setDaemon()</code> 必须在<code>Thread.start()</code> 之前调用，否则运行时会抛出异常。</p>
<h3 id="其他线程调度相关方法"><a href="#其他线程调度相关方法" class="headerlink" title="其他线程调度相关方法"></a>其他线程调度相关方法</h3><ul>
<li><p>setPriority()：线程优先级设置方法会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它。如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p>
  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">thread1.setPriority(Thread.MAX_PRIORITY); <span class="hljs-regexp">//</span>设置为优先级最高<br></code></pre></td></tr></table></figure>
</li>
<li><p>还有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁</p>
<ul>
<li>stop() –  停止线程运行</li>
<li>suspend() –  挂起（暂停）线程运行</li>
<li>resume() –  恢复线程运行</li>
</ul>
</li>
</ul>
<h3 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h3><table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NEW</td>
<td>初始状态，注意此时还未调用start() 方法</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>调用了 start() 方法之后进入运行状态，包含就绪和运行中两种状态</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞状态</td>
</tr>
<tr>
<td>WAITING</td>
<td>等待状态</td>
</tr>
<tr>
<td>TIME_WAITING</td>
<td>超时等待状态，和等待状态不同的是，它可以在制定的时间自行返回</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态，线程运行结束</td>
</tr>
</tbody></table>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java/JUC/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" srcset="/img/loading.gif" lazyload alt="image-20220517223851983"></p>
<h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><h3 id="什么是synchronized关键字？"><a href="#什么是synchronized关键字？" class="headerlink" title="什么是synchronized关键字？"></a>什么是synchronized关键字？</h3><p>synchronized 实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切<br>换所打断。保证线程同步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>			...<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="同步方法和同步方法块哪个效果更好？"><a href="#同步方法和同步方法块哪个效果更好？" class="headerlink" title="同步方法和同步方法块哪个效果更好？"></a>同步方法和同步方法块哪个效果更好？</h3><p>同步块更好些，因为它锁定的范围更灵活些，只在需要锁住的代码块锁住相应的对象，而同步方法会锁住整个对象。</p>
<h3 id="synchronized关键字的使用方式"><a href="#synchronized关键字的使用方式" class="headerlink" title="synchronized关键字的使用方式"></a>synchronized关键字的使用方式</h3><p>synchronized主要有三种使用方式：修饰普通同步方法、修饰静态同步方法、修饰同步方法块。底层原理都是给一个对象上锁</p>
<p>（1）修饰普通同步方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>	<span class="hljs-comment">//在方法上加上synchronized关键字</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>	<br>	&#125;<br>	<span class="hljs-comment">//等价于给对象加锁</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>		<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 例子</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">newRoom</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span>&#123;<br>        value++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> &#123;<br>        value--;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Room</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Room</span>();  <span class="hljs-comment">// 必须是给同一个对象枷锁</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>            room.increment();<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5000</span>; j++) &#123;<br>            room.decrement();<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>    t1.start();<br>    t2.start();<br>    t1.join();<br>    t2.join();<br>    log.debug(<span class="hljs-string">&quot;counter:&#123;&#125;&quot;</span>,room.get());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用synchronized修饰普通同步方法必须是调用同一个实例化对象</p>
<p>如果是给两个对象加锁，就不能保证线程安全，那这种情况应该如何解决呢？因为每次创建的实例对象都是不同的，而类对象却只有一个，如果synchronized关键字作用于类对象，即用synchronized修饰静态方法</p>
<p>（2）修饰静态同步方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>	<span class="hljs-comment">//在静态方法上加上synchronized关键字</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>	<br>	&#125;<br>	<span class="hljs-comment">//等价于给类对象加锁</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">synchronized</span>(Demo.class) &#123;<br>		<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 例子</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Room2</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span>&#123;<br>        value++;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> &#123;<br>        value--;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Room2</span> <span class="hljs-variable">room1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Room2</span>();<br>        <span class="hljs-type">Room2</span> <span class="hljs-variable">room2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Room2</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                room1.increment();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                room2.decrement();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        log.debug(<span class="hljs-string">&quot;counter:&#123;&#125;&quot;</span>,Room2.get());<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>（3）修饰同步代码块</p>
<p>如果某些情况下，整个方法体比较大，需要同步的代码只是一小部分，如果直接对整个方法体进行同步，会使得代码性能变差，这时只需要对一小部分代码进行同步即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 上面还有其他操作。。。</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            value++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 上面还有其他操作。。。</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            value--;<br>        &#125;<br>    &#125;<br>	...<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="synchronized关键字三大特性是什么？"><a href="#synchronized关键字三大特性是什么？" class="headerlink" title="synchronized关键字三大特性是什么？"></a>synchronized关键字三大特性是什么？</h3><p>原子性：一个或多个操作要么全部执行成功，要么全部执行失败。synchronized关键字可以保证只有一个线程拿到锁，访问共享资源。</p>
<p>可见性：当一个线程对共享变量进行修改后，其他线程可以立刻看到。执行synchronized时，会对应执行 lock 、unlock原子操作，保证可见性。</p>
<p>有序性：程序的执行顺序会按照代码的先后顺序执行。</p>
<h3 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h3><p>（1）对象头</p>
<p>在HotSpot虚拟机中，Java对象在内存中的布局大致可以分为三部分：对象头、实例数据和填充对齐。因为synchronized用的锁是存在对象头里的，这里我们需要重点了解对象头。如果对象头是数组类型，则对象头由Mark Word、Class MetadataAddress和Array length组成，如果对象头非数组类型，对象头则由Mark Word和Class MetadataAddress组成。在32位虚拟机中，数组类型的Java对象头的组成如下表：</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
<th>长度</th>
</tr>
</thead>
<tbody><tr>
<td>Mark Word</td>
<td>存储对象的hashCode、分代年龄和锁标记位</td>
<td>32bit</td>
</tr>
<tr>
<td>Class MetadataAddress</td>
<td>存储到对象类型数据的指针</td>
<td>32bit</td>
</tr>
<tr>
<td>Array length</td>
<td>数组的长度</td>
<td>32bit</td>
</tr>
</tbody></table>
<p>这里我们需要重点掌握的是Mark Word，在运行期间，Mark Word中存储的数据会随着锁标志位的变化而变化，在32位虚拟机中，不同锁状态下的组成如下：</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java/JUC/%E4%B8%8D%E5%90%8C%E9%94%81%E7%8A%B6%E6%80%81%E7%9A%84MarkWord.png" srcset="/img/loading.gif" lazyload alt="image-20220518154904184"></p>
<p>锁的状态由Java对象头的Mark Word最后两位决定，有无锁、偏向锁、轻量级锁、重量级锁等</p>
<p>（2）重量级锁 Monitor</p>
<p>Monitor，又被称为锁&#x2F;管程，这里实际上指的是重量级锁（Monitor是由操作系统提供的），每个 Java 对象都可以关联一个 Monitor 。Monitor里有三个结构：Owner、EntryList、WaitSet</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81%E5%8E%9F%E7%90%86.png" srcset="/img/loading.gif" lazyload alt="image-20220116202736471"></p>
<p>一个对象obj创建时候是无锁的，对象头的mark word里存储着hashcode、分代年龄等信息。</p>
<p>刚开始 Monitor 中 Owner 为 null，当 Thread-2 执行 synchronized(obj) ，会先查询synchronized中所指定的对象(obj)<strong>是否绑定了Monitor</strong>。如果<strong>没有绑定</strong>，则会先去与Monitor绑定（将对象头中的<strong>Mark Word</strong>置为Monitor指针），并且将Owner设为当前线程（Thread-2），Owner里只能有一个线程。在 Thread-2 上锁的过程中，如果 Thread-1，Thread-3 也来执行 synchronized(obj)，就会放入EntryList，进入阻塞状态(blocked)。当Monitor的Owner将临界区中代码执行完毕后，Owner便会被清空，此时EntryList中处于<strong>阻塞</strong>状态的线程会被<strong>叫醒并竞争</strong>，此时的竞争是<strong>非公平的</strong>（既不是先到先得）</p>
<p>每个对象都会绑定一个<strong>唯一的Monitor</strong>，如果synchronized中所指定的对象(obj)<strong>不同</strong>，则会绑定<strong>不同</strong>的Monitor。</p>
<p>（3）锁自旋</p>
<p><strong>重量级锁竞争</strong>的时候，还可以使用自旋来进行优化，即先不加入Monitor的阻塞队列EntryList中，自己循环几次看看，能不能等到owner释放锁。</p>
<p>如果当前线程2自旋成功（即在自旋的时候持锁的线程1释放了锁），那么当前线程2就可以不用进行上下文切换（持锁线程1执行完synchronized同步块后，释放锁，Owner为空，唤醒阻塞队列来竞争，胜出的线程得到cpu执行权的过程）就获得了锁</p>
<p>自旋重试失败的情况，自旋了一定次数还是没有等到持锁的线程1释放锁，线程2就会加入Monitor的阻塞队列(EntryList)</p>
<p>优化的点：<strong>不用将线程加入到阻塞队列，减少cpu切换</strong>，注意<strong>不是优化轻量级锁，而是优化重量级锁</strong>。自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</p>
<p>（4）轻量级锁</p>
<p><strong>轻量级锁使用场景：</strong>当一个对象被<strong>多个线程</strong>所访问，但访问的时间是<strong>错开的（不存在竞争）</strong>，此时就可以使用<strong>轻量级锁</strong>来优化。如果有竞争，还是升级为重量级锁。轻量级锁对使用者是透明的，语法仍然是 Synchronized。</p>
<p>轻量级锁加锁步骤：</p>
<ul>
<li>每个线程的每个栈帧都会包含一个锁记录（Lock Record）对象（这是JVM层面的，不是Java对象），内部可以存储加锁对象的mark word（不再一开始就使用Monitor）</li>
<li>让锁记录中的Object reference指向锁对象（Object），并尝试用cas去替换Object中的mark word，将此mark word放入lock record中保存</li>
<li>如果cas替换成功，则将Object的对象头替换为<strong>锁记录的地址</strong>和<strong>状态 00（轻量级锁状态）</strong>，并由该线程给对象加锁</li>
<li>如果cas替换失败，有两种情况 :<ul>
<li>如果是其它线程已经持有了该Object的轻量级锁（对象头中已经存储了别的线程的锁记录地址 00），那么表示有竞争，将进入<strong>锁膨胀</strong>阶段。（比如Thread-1想加轻量级锁失败，因为Thread-0持有该对象的轻量级锁，这时进入锁膨胀，会为对象申请Monitor锁（重量级锁），让Object指向重量级锁地址 10，然后Thread-1自己进入Monitor 的EntryList 变成BLOCKED状态）</li>
<li>如果是自己的线程前面已经对这个对象加了轻量级锁（同一个线程调用不同的方法，但都是对这个对象加锁），则发生<strong>锁重入</strong>，会再添加一条 Lock Record 作为重入锁的计数。线程中有多少个锁记录，就能表明该线程对这个对象加了几次锁（锁重入计数）</li>
</ul>
</li>
</ul>
<p>（5）偏向锁</p>
<p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然执行CAS替换操作，这样是会使性能降低的。</p>
<p>Java6 引入了<strong>偏向锁</strong>对性能进行优化：在<strong>第一次</strong>cas时会将<strong>线程的ID</strong>写入对象的Mark Word中。此后发现这个线程ID就是自己的，就表示没有竞争，就不需要再次cas，以后只要不发生竞争，这个对象就归该线程所有。即<strong>偏向锁用于优化轻量级锁重入</strong></p>
<p>当有其他线程也使用偏向锁对象时，便会将偏向锁升级为轻量级锁（前提是两个线程没有锁竞争，即一个线程执行完了，另一个线程还没执行，否则就升级为重量级锁）</p>
<h3 id="synchroized关键字的底层原理"><a href="#synchroized关键字的底层原理" class="headerlink" title="synchroized关键字的底层原理"></a>synchroized关键字的底层原理</h3><p>Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，代码块同步使用的是monitorenter 和 monitorexit 指令实现的，而方法同步是通过Access flags后面的标识来确定该方法是否为同步方法。</p>
<h3 id="Jdk1-6为什么要对-synchronized-进行优化？"><a href="#Jdk1-6为什么要对-synchronized-进行优化？" class="headerlink" title="Jdk1.6为什么要对 synchronized 进行优化？"></a>Jdk1.6为什么要对 synchronized 进行优化？</h3><p>因为Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，而Monitor是依靠底层操作系统的Mutex Lock来实现的，操作系统实现线程之间的切换需要从用户态转换到内核态，这个切换成本比较高，对性能影响较大</p>
<h3 id="jDK1-6对-synchronized-做了哪些优化？"><a href="#jDK1-6对-synchronized-做了哪些优化？" class="headerlink" title="jDK1.6对 synchronized 做了哪些优化？"></a>jDK1.6对 synchronized 做了哪些优化？</h3><p>在JDK1.6中，为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁，锁的状态变成了四种，无锁状态，偏向锁状态、轻量级锁状态和重量级锁状态。锁的状态会随着竞争激烈逐渐升级，但通常情况下，锁的状态只能升级不能降级</p>
<p>synchronized锁原来只有重量级锁(Monitor)，但这玩意儿是操作系统层的，比较浪费性能。因此从Jdk1.6开始使用偏向锁和轻量级锁优化性能，在不同场景使用不同的锁。锁只有升级，没有降级</p>
<ul>
<li>只有一个线程进入临界区 –&gt; 偏向锁（对象头的Mark Word记录线程ID进行比对）</li>
<li>多个线程交替（没有竞争）进入临界区 –&gt; 轻量级锁（用CAS将对象头原本的Mark Word拷贝到线程栈帧的Lock Record中，在对象头放锁记录的地址和锁状态）</li>
<li>多个线程同时（有竞争）进入临界区 –&gt; 重量级锁（每个对象绑定唯一的Monitor，其他线程竞争时会有<strong>锁自旋优化</strong>，自旋失败则进入Monitor中的Entrylist放置等待）</li>
</ul>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><h3 id="volatile的作用是什么？"><a href="#volatile的作用是什么？" class="headerlink" title="volatile的作用是什么？"></a>volatile的作用是什么？</h3><p>volatile 是一个轻量级的synchronized ，一般作用于变量，在多处理器开发的过程中保证了内存的可见性。相比于synchronized 关键字， volatile 关键字的执行成本更低，效率更高。</p>
<h3 id="volatile的特性有哪些？"><a href="#volatile的特性有哪些？" class="headerlink" title="volatile的特性有哪些？"></a>volatile的特性有哪些？</h3><p>并发编程的三大特性为可见性、有序性和原子性。volatile 只可以保证可见性和有序性。</p>
<p>可见性： volatile 可以保证不同线程对共享变量进行操作时的可见性。即当一个线程修改了共享变量时，另一个线程可以读取到共享变量被修改后的值。</p>
<p>有序性： volatile 会通过禁止指令重排序进而保证有序性。</p>
<p>原子性：对于单个的volatile 修饰的变量的读写是可以保证原子性的，但对于i++ 这种复合操作并不能保证原子性。这句话的意思基本上就是说volatile 不具备原子性了。</p>
<h3 id="为什么代码会重排序？会引发什么问题？"><a href="#为什么代码会重排序？会引发什么问题？" class="headerlink" title="为什么代码会重排序？会引发什么问题？"></a>为什么代码会重排序？会引发什么问题？</h3><p>指令重排在单线程下可以提高代码的性能，但在多线程下重排序会破坏多线程程序的语义。</p>
<h3 id="as-if-serial规则和happens-before规则的区别？"><a href="#as-if-serial规则和happens-before规则的区别？" class="headerlink" title="as-if-serial规则和happens-before规则的区别？"></a>as-if-serial规则和happens-before规则的区别？</h3><p>区别：</p>
<ul>
<li>as-if-serial定义：无论编译器和处理器如何进行重排序，单线程程序的执行结果不会改变。</li>
<li>happens-before定义：一个操作happens-before另一个操作，表示第一个的操作结果对第二个操作可见，并且第一个操作的执行顺序也在第二个操作之前。但这并不意味着Java虚拟机必须按照这个顺序来执行程序。如果重排序的后的执行结果与按happens-before关系执行的结果一致，Java虚拟机也会允许重排序的发生。</li>
<li>happens-before关系保证了同步的多线程程序的执行结果不被改变，as-if-serial保证了单线程内程序的执行结果不被改变。</li>
</ul>
<p>相同点：happens-before和as-if-serial的作用都是在不改变程序执行结果的前提下，提高程序执行的并行度。</p>
<h3 id="voliatile的实现原理？"><a href="#voliatile的实现原理？" class="headerlink" title="voliatile的实现原理？"></a>voliatile的实现原理？</h3><p>volatile 具备可见性和有序性两大特性，所以volatile 的实现原理也是围绕如何实现可见性和有序性展开的。</p>
<ul>
<li><p>volatile实现内存可见性原理：</p>
<p>  导致内存不可见的主要原因就是Java内存模型中的本地内存和主内存之间的值不一致，volatile 的读&#x2F;写实现了缓存一致性：处理器读数据时，一旦发现自己缓存对应的内存地址被修改，就会将当前处理器的缓存设为无效状态。此时，如果处理器需要获取这个数据需重新从主内存将其读取到本地内存。当处理器写数据时，如果发现操作的是共享变量，会通知其他处理器将该变量的缓存设为无效状态。</p>
</li>
<li><p>volatile实现有序性原理：</p>
<p>  编译器在生成字节码时会通过插入内存屏障来禁止指令重排序，它是一种CPU指令，它的作用是对该指令前和指令后的一些操作产生一定的约束，保证一些操作按顺序执行</p>
</li>
</ul>
<p>但是volatile不能解决指令交错问题 (不能解决原子性)，可以使用<code>synchronized</code>来解决原子性</p>
<h3 id="volatile、synchronized的区别？"><a href="#volatile、synchronized的区别？" class="headerlink" title="volatile、synchronized的区别？"></a>volatile、synchronized的区别？</h3><ul>
<li><p>volatile 主要是保证内存的可见性，即变量在寄存器中的内存是不确定的，需要从主存中读取。以及通过内存屏障保证有序性，但不能保证数据的原子性</p>
</li>
<li><p>synchronized 主要是解决多个线程访问资源的同步性。synchronized 可以保证可见性、有序性、原子性。</p>
</li>
<li><p>volatile 作用于变量， synchronized 作用于代码块或者方法。</p>
</li>
<li><p>volatile 不会造成线程的阻塞， synchronized 会造成线程的阻塞。</p>
</li>
</ul>
<h2 id="CAS-与-Atomic-原子类"><a href="#CAS-与-Atomic-原子类" class="headerlink" title="CAS 与 Atomic 原子类"></a>CAS 与 Atomic 原子类</h2><h3 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS?"></a>什么是CAS?</h3><p>CAS即CompareAndSwap，翻译成中文即比较并替换。Java中可以通过CAS操作来保证原子性，原子性就是不可被中断的一些列操作或者一个操作，简单来说就是一系列操作，要么全部完成，要么失败，不能被中断。</p>
<p>CAS主要包含三个参数（V，A，E）, V 表示要更新的变量（内存值）、E 表示预期值（旧值）、N 表示新值。算法流程是首先比较A和E的值，如果相等，将N值赋值给A，如果不相等说明有其他线程对该变量做了更新。这个参数有的地方也会用（V，A，B）表示，其中A表示预期值，B表示新值。</p>
<p>当多个线程同时操作一个共享变量时，只有一个线程可以对变量进行成功更新，其他线程均会失败，但是失败并不会被挂起，进行再次尝试，也就是自旋。Java中的自旋锁就是利用CAS来实现的。</p>
<p>获取共享变量时，为了<strong>保证该变量的可见性</strong>，需要使用 volatile 修饰。<strong>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</strong></p>
<h3 id="CAS存在的问题"><a href="#CAS存在的问题" class="headerlink" title="CAS存在的问题"></a>CAS存在的问题</h3><ul>
<li><p>ABA问题</p>
<p>  在CAS的算法流程中，首先要先比较V的值和E的值，如果相等则进行更新。ABA问题是指，E表示的这个旧值本来是A，然后变成了B，后来又变成了A，但这时有线程来更新，发现E表示的值是A，则直接进行更新了，这样肯定是不对的，但又该怎么解决呢？</p>
<p>  ABA的问题的解决方式：ABA的解决方法也很简单，就是利用版本号。给变量加上一个版本号，每次变量更新的时候就把版本号加1，这样即使E的值从A—&gt;B—&gt;A，版本号也发生了变化，这样就解决了CAS出现的ABA问题。基于CAS的乐观锁也是这个实现原理。</p>
</li>
<li><p>循环时间过长导致开销太大</p>
<p>  CAS自旋时间过长会给CPU带来非常大的开销</p>
</li>
<li><p>只能保证一个共享变量的原子操作</p>
<p>  在操作一个共享变量时，可以通过CAS的方式保证操作的原子性，但如果对多个共享变量进行操作时，CAS则无法保证操作的原子性，这时候就需要用锁了。</p>
</li>
</ul>
<h3 id="CAS的特点"><a href="#CAS的特点" class="headerlink" title="CAS的特点"></a>CAS的特点</h3><ul>
<li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。<strong>只是基于乐观锁的思想，其实是没有加锁的。</strong></li>
<li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li>
<li>CAS 体现的是<strong>无锁并发、无阻塞并发</strong><ul>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li>
<li>但如果竞争激烈(写操作多)，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
</li>
</ul>
<p>在并发量不是很大时比有锁要提高效率：</p>
<ul>
<li>使用CAS+重试即无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized会让线程在没有获得锁的时候，发生上下文切换，进入阻塞，这部分时间损耗的较多。</li>
<li>无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，因此CAS适合线程数少于CPU核心数的情况，否则没有额外CPU支持，CAS并不能发挥作用（像上面例子中创建1000个线程其实并不能体现CAS的高效）</li>
</ul>
<h3 id="Atomic-原子类"><a href="#Atomic-原子类" class="headerlink" title="Atomic 原子类"></a>Atomic 原子类</h3><p>JUC包中的4种原子类：</p>
<ul>
<li>基本类型：使用原子的方式更新基本类型</li>
<li>数组类型：使用原子的方式更新数组里的某个元素</li>
<li>引用类型：<ul>
<li>AtomicReference ：引用类型原子类，存在ABA问题</li>
<li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的ABA问题。</li>
</ul>
</li>
<li>原子更新字段类</li>
</ul>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="什么是ThreadLocal？有哪些应用场景？"><a href="#什么是ThreadLocal？有哪些应用场景？" class="headerlink" title="什么是ThreadLocal？有哪些应用场景？"></a>什么是ThreadLocal？有哪些应用场景？</h3><p>ThreadLocal 是 JDK java.lang 包下的一个类， ThreadLocal 为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量，并且不会和其他线程的局部变量冲突，实现了线程间的数据隔离。同时实现了线程内的资源共享</p>
<p>ThreadLocal 的应用场景主要有以下几个方面：</p>
<ul>
<li>保存线程上下文信息，在需要的地方可以获取</li>
<li>线程间数据隔离</li>
<li>数据库连接</li>
</ul>
<h3 id="ThreadLocal原理？"><a href="#ThreadLocal原理？" class="headerlink" title="ThreadLocal原理？"></a>ThreadLocal原理？</h3><p>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象，  ThreadLocalMap 中保存着所有的 ThreadLocal ，而ThreadLocal 本身只是一个引用本身并不保存值，值都是保存在ThreadLocalMap中的，其中ThreadLocal 为ThreadLocalMap 中的key 。</p>
<p>ThreadLocalMap 的一些特点</p>
<ul>
<li>key 的 hash 值统一分配</li>
<li>初始容量 16，扩容因子 2&#x2F;3，扩容容量翻倍</li>
<li>key 索引冲突后用开放寻址法解决冲突</li>
</ul>
<p>对于ThreadLocal对象，有几个重要的方法：</p>
<ul>
<li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</li>
<li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</li>
<li>调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li>
</ul>
<p><strong>内存释放时机</strong></p>
<ul>
<li>被动 GC 释放 key<ul>
<li>仅是让 key 的内存释放，关联 value 的内存并不会释放</li>
</ul>
</li>
<li>懒惰被动释放 value<ul>
<li>get key 时，发现是 null key，则释放其 value 内存</li>
<li>set key 时，会使用启发式扫描，清除临近的 null key 的 value 内存，启发次数与元素个数，是否发现 null key 有关</li>
</ul>
</li>
<li>主动 remove 释放 key，value<ul>
<li>会同时释放 key，value 的内存，也会清除临近的 null key 的 value 内存</li>
<li>推荐使用它，因为一般使用 ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收</li>
</ul>
</li>
</ul>
<h3 id="为什么ThreadLocal会发生内存泄漏呢？"><a href="#为什么ThreadLocal会发生内存泄漏呢？" class="headerlink" title="为什么ThreadLocal会发生内存泄漏呢？"></a>为什么ThreadLocal会发生内存泄漏呢？</h3><p>因为ThreadLocal 中的key 是弱引用，而value 是强引用。当ThreadLocal 没有被强引用时，在进行垃圾回收时， key 会被清理掉，而value 不会被清理掉，这时如果不做任何处理， value 将永远不会被回收，产生内存泄漏。</p>
<h3 id="如何解决ThreadLocal的内存泄漏？"><a href="#如何解决ThreadLocal的内存泄漏？" class="headerlink" title="如何解决ThreadLocal的内存泄漏？"></a>如何解决ThreadLocal的内存泄漏？</h3><p>ThreadLocal 在设计的时候已经考虑到了这种情况，在调用set() 、get() 、remove() 等方法时就会清理掉key 为null 的记录，所以在使用完ThreadLocal 后最好手动调用remove() 方法。</p>
<h3 id="为什么要将key设计成ThreadLocal的弱引用？"><a href="#为什么要将key设计成ThreadLocal的弱引用？" class="headerlink" title="为什么要将key设计成ThreadLocal的弱引用？"></a>为什么要将key设计成ThreadLocal的弱引用？</h3><p>Thread 可能需要长时间运行（如线程池中的线程），如果 key 不再使用，需要在内存不足（GC）时释放其占用的内存</p>
<p>如果ThreadLocal 的key 是强引用，同样会发生内存泄漏的。如果ThreadLocal 的key 是强引用，引用的ThreadLocal 的对象被回收了，但是ThreadLocalMap 还持有ThreadLocal 的强引用，如果没有手动删除， ThreadLocal 不会被回收，发生内存泄漏。</p>
<p>如果是弱引用的话，引用的ThreadLocal 的对象被回收了，即使没有手动删除， ThreadLocal 也会被回收。value 也会在ThreadLocalMap 调用 set() 、get() 、remove() 的时候会被清除。所以两种方案比较下来，还是ThreadLoacl 的key 为弱引用好一些。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="什么是线程池？为什么使用线程池？"><a href="#什么是线程池？为什么使用线程池？" class="headerlink" title="什么是线程池？为什么使用线程池？"></a>什么是线程池？为什么使用线程池？</h3><p>线程池是一种多线程处理形式，处理过程中将任务提交到线程池，任务的执行交给线程池来管理。</p>
<p>为什么使用线程池？</p>
<ul>
<li>降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度，当任务到达时，任务可以不需要等到线程创建就立即执行。</li>
<li>提高线程的可管理性，线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以统一分配。</li>
</ul>
<h3 id="创建线程池的几种方法"><a href="#创建线程池的几种方法" class="headerlink" title="创建线程池的几种方法"></a>创建线程池的几种方法</h3><p>线程池的常用创建方式主要有两种，通过new ThreadPoolExecutor方法创建和通过Executors工厂方法创建。</p>
<ul>
<li><p>new ThreadPoolExecutor 方法创建</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure></li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>核心线程数，定义了最小可以同时运行的线程数量</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>最大线程数，线程池里的线程分为两种：核心线程和救急线程，maximumPoolSize - corePoolSize &#x3D; 救急线程数</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>救急线程空闲时的最大生存时间。超过时间会销毁救急线程</td>
</tr>
<tr>
<td>unit</td>
<td>救急线程的时间单位</td>
</tr>
<tr>
<td>workQueue</td>
<td>存放任务的阻塞队列。新来的任务会先判断当前运行的线程数是否到达核心线程数，如果到达的话，任务就会先放到阻塞队列。</td>
</tr>
<tr>
<td>threadFactory</td>
<td>线程工厂：可以给线程取个好名字，取名时要取清晰，区别于非线程池方法创建的线程</td>
</tr>
<tr>
<td>handler</td>
<td>拒绝策略，阻塞队列满了，线程池使用什么样的拒绝策略拒绝新任务</td>
</tr>
</tbody></table>
<ul>
<li><p>Executors工厂方法创建，在工具类 Executors 提供了一些静态的工厂方法（底层其实还是调用ThreadPoolExecutor 方法创建，只不过封装了一些固定参数）</p>
<ul>
<li><p>newSingleThreadExecutor ：创建一个单线程的线程池。</p>
</li>
<li><p>newFixedThreadPool ：创建固定大小的线程池。</p>
</li>
<li><p>newCachedThreadPool ：创建一个可缓存的线程池。</p>
</li>
<li><p>newScheduledThreadPool ：创建一个大小无限的线程池。</p>
</li>
</ul>
</li>
</ul>
<h3 id="线程池的执行流程"><a href="#线程池的执行流程" class="headerlink" title="线程池的执行流程"></a>线程池的执行流程</h3><p>当一个任务传给线程池以后，</p>
<ul>
<li>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新的核心线程来执行任务。</li>
<li>当线程数达到 <code>corePoolSize</code> 并且没有线程空闲，这时再加入任务，新加的任务会被加入<code>workQueue</code> 队列排队，直到有空闲的线程。</li>
<li>如果阻塞队列选择了有界阻塞队列并且阻塞队列满了，使用非核心线程（救急线程）来执行任务。救急线程用完以后，超过生存时间（keepAliveTime）后会被释放。<strong>如果不是有界队列，则不会创建救急线程，都是核心线程</strong></li>
<li>任务总数大于了 最大线程数<code>maximumPoolSize</code>与阻塞队列容量的最大值<code>workQueue.capacity</code>，使用拒接策略</li>
</ul>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F.png" srcset="/img/loading.gif" lazyload alt="image-20220126222039262"></p>
<h3 id="ThreadPoolExecutor的饱和策略（拒绝策略）"><a href="#ThreadPoolExecutor的饱和策略（拒绝策略）" class="headerlink" title="ThreadPoolExecutor的饱和策略（拒绝策略）"></a>ThreadPoolExecutor的饱和策略（拒绝策略）</h3><p>当同时运行的线程数量达到最大线程数量并且阻塞队列也已经放满了任务时， ThreadPoolExecutor 会指定一些饱和策略。主要有以下四种类型：</p>
<ul>
<li>AbortPolicy 策略：该策略会直接抛出异常拒绝新任务</li>
<li>CallerRunsPolicy 策略：当线程池无法处理当前任务时，会将该任务交由提交任务的线程来执行。</li>
<li>DiscardPolicy 策略：直接丢弃新任务。</li>
<li>DiscardOleddestPolicy 策略：丢弃最早的未处理的任务请求。</li>
</ul>
<h3 id="execute-方法和submit-方法的区别"><a href="#execute-方法和submit-方法的区别" class="headerlink" title="execute()方法和submit()方法的区别"></a>execute()方法和submit()方法的区别</h3><p>execute() 和submit() 的区别主要有两点：</p>
<p>execute() 方法只能执行Runnable 类型的任务。submit() 方法可以执行Runnable 和Callable 类型的任务。</p>
<p>submit() 方法可以返回持有计算结果的Future 对象，同时还可以抛出异常，而execute() 方法不可以。</p>
<p>换句话说就是， execute() 方法用于提交不需要返回值的任务， submit() 方法用于需要提交返回值的任务。</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS的全称是 AbstractQueuedSynchronizer ，是一个用来构建锁和同步器的框架，像ReentrantLock，Semaphore，FutureTask都是基于AQS实现的。</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><p>多线程中编程题经常考察</p>
<h3 id="用Java实现死锁，并给出避免死锁的解决方案"><a href="#用Java实现死锁，并给出避免死锁的解决方案" class="headerlink" title="用Java实现死锁，并给出避免死锁的解决方案"></a>用Java实现死锁，并给出避免死锁的解决方案</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j(topic = &quot;info&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLockTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span> (A)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;t1尝试获得锁B&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (B)&#123;<br><br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span> (B)&#123;  <span class="hljs-comment">// 避免死锁：synchronized (A)</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;t2尝试获得锁A&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (A)&#123;   <span class="hljs-comment">// 避免死锁：synchronized (B)</span><br><br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">16:43:02.129 [t2] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - t2尝试获得锁A<br>16:43:03.123 [t1] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - t1尝试获得锁B<br></code></pre></td></tr></table></figure>

<p>避免死锁：顺序加锁</p>
<p>t2线程也是先获取锁A再获取锁B，两个线程可以轮流获取锁A和锁B。</p>
<h3 id="三个线程T1、T2、T3，如何让他们按顺序执行？"><a href="#三个线程T1、T2、T3，如何让他们按顺序执行？" class="headerlink" title="三个线程T1、T2、T3，如何让他们按顺序执行？"></a>三个线程T1、T2、T3，如何让他们按顺序执行？</h3><p>这是一道面试中常考的并发编程的代码题，与它相似的问题有：</p>
<ul>
<li>三个线程T1、T2、T3轮流打印ABC，打印n次，如ABCABCABCABC…….</li>
<li>两个线程交替打印1-100的奇偶数</li>
<li>N个线程循环打印1-100</li>
</ul>
<p>其实这类问题本质上都是线程通信问题，思路基本上都是一个线程执行完毕，阻塞该线程，唤醒其他线<br>程，按顺序执行下一个线程</p>
<p>wait&#x2F;notify</p>
<p>三个线程T1、T2、T3轮流打印ABC，打印n次，如ABCABCABCABC…….</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CrossOutputABC_WaitNotify1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">WaitNotify_ABC</span> <span class="hljs-variable">waitNotify_abc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitNotify_ABC</span>();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            waitNotify_abc.print(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>        &#125;, <span class="hljs-string">&quot;A&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            waitNotify_abc.print(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br>        &#125;, <span class="hljs-string">&quot;B&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            waitNotify_abc.print(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>);<br>        &#125;, <span class="hljs-string">&quot;C&quot;</span>).start();<br><br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNotify_ABC</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> num;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String content, <span class="hljs-type">int</span> targetNum, <span class="hljs-type">int</span> loopNumber)</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                <span class="hljs-keyword">while</span> (num%<span class="hljs-number">3</span> != targetNum)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        lock.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                num++;<br>                System.out.print(content);<br>                lock.notifyAll();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>两个线程交替打印1-100的奇偶数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CrossOutputOddEven_WaitNotify</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Wait_Notify_Odd_Even</span> <span class="hljs-variable">oddEven</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Wait_Notify_Odd_Even</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            oddEven.printOddEven(<span class="hljs-number">100</span>);<br>        &#125;,<span class="hljs-string">&quot;Odd&quot;</span>).start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            oddEven.printOddEven(<span class="hljs-number">100</span>);<br>        &#125;,<span class="hljs-string">&quot;Even&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wait_Notify_Odd_Even</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> count;<br>    Wait_Notify_Odd_Even(<span class="hljs-type">int</span> count)&#123;<br>        <span class="hljs-built_in">this</span>.count = count;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printOddEven</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">while</span>(count &lt; num)&#123;<br>            <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.print(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>);<br>                    System.out.println(++count);<br>                    lock.notifyAll();<br>                    lock.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br><span class="hljs-comment">//        lock.notifyAll();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>N个线程循环打印1-100，假设N&#x3D;4</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CrossOutputNThread_WaitNotify</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">WaitNotify_NThread</span> <span class="hljs-variable">nThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitNotify_NThread</span>();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            nThread.print(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>);<br>        &#125;, <span class="hljs-string">&quot;线程1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            nThread.print(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>);<br>        &#125;, <span class="hljs-string">&quot;线程2&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            nThread.print(<span class="hljs-number">2</span>, <span class="hljs-number">100</span>);<br>        &#125;, <span class="hljs-string">&quot;线程3&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            nThread.print(<span class="hljs-number">3</span>, <span class="hljs-number">100</span>);<br>        &#125;, <span class="hljs-string">&quot;线程4&quot;</span>).start();<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNotify_NThread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> num;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> targetNum, <span class="hljs-type">int</span> maxnum)</span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                <span class="hljs-keyword">while</span> (num%<span class="hljs-number">4</span> != targetNum)&#123;<br>                    <span class="hljs-keyword">if</span>(num &gt;= maxnum) <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        lock.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(num &gt;= maxnum) <span class="hljs-keyword">break</span>;<br>                num++;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+num);<br>                lock.notifyAll();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="SQL语句基础知识"><a href="#SQL语句基础知识" class="headerlink" title="SQL语句基础知识"></a>SQL语句基础知识</h2><h3 id="SQL关键字执行顺序"><a href="#SQL关键字执行顺序" class="headerlink" title="SQL关键字执行顺序"></a>SQL关键字执行顺序</h3><p>关键字语法顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT...<br></code></pre></td></tr></table></figure>

<p>SELECT 语句的执行顺序:</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">FROM</span> -&gt; <span class="hljs-keyword">WHERE</span> -&gt; <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> -&gt; <span class="hljs-keyword">HAVING</span> -&gt; <span class="hljs-keyword">SELECT</span> 的字段 -&gt; <span class="hljs-keyword">DISTINCT</span> -&gt; <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> -&gt; <span class="hljs-keyword">LIMIT</span><br></code></pre></td></tr></table></figure>



<h2 id="数据库基础知识"><a href="#数据库基础知识" class="headerlink" title="数据库基础知识"></a>数据库基础知识</h2><h3 id="MySQL常用的存储引擎有什么？它们有什么区别？"><a href="#MySQL常用的存储引擎有什么？它们有什么区别？" class="headerlink" title="MySQL常用的存储引擎有什么？它们有什么区别？"></a>MySQL常用的存储引擎有什么？它们有什么区别？</h3><p>InnoDB是MySQL的默认存储引擎，支持事务、行锁和外键等操作。MyISAM是MySQL5.1版本前的默认存储引擎，MyISAM的并发性比较差，不支持事务和外键等操作，默认的锁的粒度为表级锁。</p>
<table>
<thead>
<tr>
<th></th>
<th>InnoDB</th>
<th>MyISAM</th>
</tr>
</thead>
<tbody><tr>
<td>外键</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>事务</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>锁</td>
<td>支持表锁和行锁</td>
<td>支持表锁</td>
</tr>
<tr>
<td>可恢复性</td>
<td>根据事务日志进行恢复</td>
<td>无事务日志</td>
</tr>
<tr>
<td>表结构</td>
<td>数据和索引是集中存储的，.ibd和.frm</td>
<td>数据和索引是分开存储的，数据.MYD ，索引.MYI</td>
</tr>
<tr>
<td>查询性能</td>
<td>一般情况较差</td>
<td>相对好一点</td>
</tr>
<tr>
<td>索引</td>
<td>聚簇索引</td>
<td>非聚簇索引</td>
</tr>
</tbody></table>
<h3 id="数据库的三大范式"><a href="#数据库的三大范式" class="headerlink" title="数据库的三大范式"></a>数据库的三大范式</h3><p>第一范式：确保每列保持原子性，数据表中的所有字段值都是不可分解的原子值。</p>
<p>第二范式：确保表中的每列都和主键相关</p>
<p>第三范式：确保每列都和主键列直接相关而不是间接相关</p>
<h3 id="MySQL的数据类型有哪些"><a href="#MySQL的数据类型有哪些" class="headerlink" title="MySQL的数据类型有哪些"></a>MySQL的数据类型有哪些</h3><ul>
<li>整数：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT分别占用8、16、24、32、64位存储空间</li>
<li>浮点数：FLOAT、DOUBLE及DECIMAL为浮点数类型</li>
<li>字符串：字符串常用的主要有CHAR和VARCHAR，VARCHAR主要用于存储可变长字符串，相比于定长的<br>  CHAR更节省空间。</li>
<li>日期：比较常用的有year、time、date、datetime、timestamp等</li>
</ul>
<h3 id="一条SQL查询语句是如何执行的（MySQL的基础架构）"><a href="#一条SQL查询语句是如何执行的（MySQL的基础架构）" class="headerlink" title="一条SQL查询语句是如何执行的（MySQL的基础架构）"></a>一条SQL查询语句是如何执行的（MySQL的基础架构）</h3><p>MySQL可以分为Server层和存储引擎层两部分。</p>
<p>Server层包括连接器、查询缓存、分析器、优化器、执行器等。查询语句执行过程也是按照此顺序</p>
<p>存储引擎层负责数据的存储和提取</p>
<h3 id="一条SQL更新语句是如何执行的（redo-log和-binlog）"><a href="#一条SQL更新语句是如何执行的（redo-log和-binlog）" class="headerlink" title="一条SQL更新语句是如何执行的（redo log和 binlog）"></a>一条SQL更新语句是如何执行的（redo log和 binlog）</h3><p>读取行 –&gt;  执行计算 –&gt;  更新数据并写入 redo log (prepare) –&gt;  生成binlog并写入磁盘 –&gt;  提交事务并将redo log 改为commit</p>
<p><strong>为什么建表时，加 not null default ‘’ 或 default 0</strong></p>
<p>答：不想让表中出现null值。</p>
<p><strong>为什么不想要 null 的值</strong></p>
<p>答:（1）不好比较。null是一种特殊值，比较时只能用专门的is null 和 is not null来比较。碰到运算符，通常返回null。</p>
<p>​     （2）效率不高。影响提高索引效果。因此，我们往往在建表时 not null default ‘’ 或 default 0</p>
<p><strong>带AUTO_INCREMENT约束的字段值是从1开始的吗？</strong><br>在MySQL中，默认AUTO_INCREMENT的初始值是1，每新增一条记录，字段值自动加1。设置自增属性（AUTO_INCREMENT）的时候，还可以指定第一条插入记录的自增字段的值，这样新插入的记录的自增字段值从初始值开始递增，如在表中插入第一条记录，同时指定id值为5，则以后插入的记录的id值就会从6开始往上增加。添加主键约束时，往往需要设置字段自动增加属性。</p>
<p><strong>并不是每个表都可以任意选择存储引擎？</strong><br>外键约束（FOREIGN KEY）不能跨引擎使用。</p>
<p>MySQL支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，需要注意的是：外键约束是用来保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不能创建外键约束的。所以说，存储引擎的选择也不完全是随意的。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h3><p>索引是对数据库表的一列或者多列的值进行排序一种结构，使用索引可以快速访问数据表中的特定信息。</p>
<p>索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p>
<h3 id="索引的优缺点？"><a href="#索引的优缺点？" class="headerlink" title="索引的优缺点？"></a>索引的优缺点？</h3><p>优点：</p>
<ul>
<li>大大加快数据检索的速度。</li>
<li>将随机I&#x2F;O变成顺序I&#x2F;O（因为B+树的叶子节点是连接在一起的）</li>
<li>加速表与表之间的连接</li>
</ul>
<p>缺点：</p>
<ul>
<li>从空间角度考虑，建立索引需要占用物理空间</li>
<li>从时间角度 考虑，创建和维护索引都需要花费时间，例如对数据进行增删改的时候都需要维护索引。</li>
</ul>
<p>但是，<strong>使用索引一定能提高查询性能吗?</strong></p>
<p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p>
<h3 id="索引的底层数据结构及其区别"><a href="#索引的底层数据结构及其区别" class="headerlink" title="索引的底层数据结构及其区别"></a>索引的底层数据结构及其区别</h3><p>索引的数据结构主要有B+树和哈希表，对应的索引分别为B+树索引和哈希索引。InnoDB引擎的索引类型有B+树索引和哈希索引，<strong>默认的索引类型为B+树索引</strong>。</p>
<p><strong>B+树索引：</strong>在B+树中，所有的记录节点都是按照键值大小的顺序放在叶子节点上，如下图。</p>
<p>从上图可以看出 ，因为B+树具有有序性，并且所有的数据都存放在叶子节点，所以查找的效率非常高，并且支持排序和范围查找。</p>
<p>B+树的索引又可以分为主索引和辅助索引。其中主索引为聚簇索引，辅助索引为非聚簇索引。聚簇索引是以主键作为B+ 树索引的键值所构成的B+树索引，聚簇索引的叶子节点存储着完整的数据记录；非聚簇索引是以非主键的列作为B+树索引的键值所构成的B+树索引，非聚簇索引的叶子节点存储着主键值。所以使用非聚簇索引进行查询时，会先找到主键值，然后到根据聚簇索引找到主键对应的数据域。上图中叶子节点存储的是数据记录，为聚簇索引的结构图，非聚簇索引的结构图如下：</p>
<p><strong>哈希表：</strong>对于每一行数据，存储引擎会对索引列通过哈希算法进行哈希计算得到哈希码，并且哈希算法要尽量保证不同的列值计算出的哈希码值是不同的，将哈希码的值作为哈希表的key值，将指向数据行的指针作为哈希表的value值。这样查找一个数据的时间复杂度就是O(1)，一般多用于精确查找。</p>
<p>区别：</p>
<p>因为两者数据结构上的差异导致它们的使用场景也不同，哈希索引一般多用于精确的等值查找，B+索引则多用于除了精确的等值查找外的其他查找。在大多数情况下，会选择使用B+树索引。</p>
<p>哈希索引不支持范围查找和排序查询（因为哈希表是无序的），这是哈希表最大的问题。同时哈希表中会存在哈希冲突，所以哈希索引的性能是不稳定的，而B+树索引的性能是相对稳定的，因为每次查询都是从根节点到叶子节点。此外哈希索引也不支持模糊查询及多列索引的最左前缀匹配。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h3><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<h3 id="事务的特征？"><a href="#事务的特征？" class="headerlink" title="事务的特征？"></a>事务的特征？</h3><p>ACID：</p>
<ul>
<li>原子性（Atomicity）：一个事务不可再分割，要么都执行要么都不执行</li>
<li>一致性（Consistency）：一个事务执行会使数据从一个一致状态切换到另外一个一致状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。</li>
<li>隔离性（Isolation）：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</li>
<li>持久性（Durability）：事务一旦提交，它对于数据库中的数据改变是永久性的。该修改即使出现系统故障也将一直保持</li>
</ul>
<h3 id="事务并发带来的问题？"><a href="#事务并发带来的问题？" class="headerlink" title="事务并发带来的问题？"></a>事务并发带来的问题？</h3><ul>
<li>脏读：一个事务读取了其他事务<strong>更新但没有提交</strong>的数据。事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据</li>
<li>不可重复读：一个事务多次<strong>读取同一数据时，结果不一样</strong>。事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果不一致。</li>
<li>幻读：一个事务读取了其他事务<strong>插入或删除但没有提交</strong>的数据。事务A读到了3条数据，事务B又插入了一条，事务A读到了4条，然后B又回滚了，事务A读到3条</li>
</ul>
<h3 id="事务的隔离级别？"><a href="#事务的隔离级别？" class="headerlink" title="事务的隔离级别？"></a>事务的隔离级别？</h3><ul>
<li>读未提交：允许事务读取未被其它事务提交的变更</li>
<li>读已提交：只允许事务读取已经被其它事务提交的变更，只能避免<strong>脏读</strong>。Oracle默认隔离级别</li>
<li>可重复读：确保事务多次从一个字段中读取相同的值，哪怕别人改数据的事务已经提交，在本事务中也不去读，可以避免<strong>脏读</strong>和<strong>不可重复读</strong>。<strong>mysql 默认隔离级别</strong></li>
<li>串行化：事务持续期间，禁止其他事务对该表执行插入、更新和删除操作，所有并发问题都可以避免，但性能低下</li>
</ul>
<p>一般选二三个，安全性高一点的选可重复读，性能要求高一点选读已提交</p>
<h3 id="隔离级别是如何实现的？"><a href="#隔离级别是如何实现的？" class="headerlink" title="隔离级别是如何实现的？"></a>隔离级别是如何实现的？</h3><p>事务的隔离机制主要是依靠锁机制和MVCC（多版本并发控制）实现的，读已提交和可重复读可以通过MVCC实现，串行化可以通过锁机制实现。</p>
<h3 id="什么是MVCC？"><a href="#什么是MVCC？" class="headerlink" title="什么是MVCC？"></a>什么是MVCC？</h3><p>MVCC(multiple version concurrent control)是一种控制并发的方法，主要用来提高数据库的并发性能。在了解MVCC时应该先了解当前读和快照读。</p>
<p>当前读：读取的是数据库的最新版本，并且在读取时要保证其他事务不会修该当前记录，所以会对读取的记录加锁。</p>
<p>快照读：不加锁读取操作即为快照读，使用MVCC来读取快照中的数据，避免加锁带来的性能损耗。</p>
<p>可以看到MVCC的作用就是在不加锁的情况下，解决数据库读写冲突问题，并且解决脏读、幻读、不可重复读等问题，但是不能解决丢失修改问题。</p>
<h2 id="数据库的锁"><a href="#数据库的锁" class="headerlink" title="数据库的锁"></a>数据库的锁</h2><h2 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h2><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h3 id="计算机网络的各层协议及作用？"><a href="#计算机网络的各层协议及作用？" class="headerlink" title="计算机网络的各层协议及作用？"></a>计算机网络的各层协议及作用？</h3><p>计算机网络体系可以大致分为一下三种，OSI七层模型、TCP&#x2F;IP四层模型和五层模型。</p>
<ul>
<li>OSI七层模型：大而全，但是比较复杂、而且是先有了理论模型，没有实际应用。</li>
<li>TCP&#x2F;IP四层模型：是由实际应用发展总结出来的，从实质上讲，TCP&#x2F;IP只有最上面三层，最下面一层没有什么具体内容，TCP&#x2F;IP参考模型没有真正描述这一层的实现。</li>
<li>五层模型：五层模型只出现在计算机网络教学过程中，这是对七层模型和四层模型的一个折中，既简洁又能将概念阐述清楚。（面试时候答这个就行）</li>
</ul>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Computer%20Network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E6%A8%A1%E5%9E%8B%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="面经-计算机网络体系模型图"></p>
<p>七层网络体系结构各层的主要功能：</p>
<ul>
<li>应用层：为应用程序提供交互服务。在互联网中的应用层协议很多，如域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议等。</li>
<li>表示层：主要负责数据格式的转换，如加密解密、转换翻译、压缩解压缩等。</li>
<li>会话层：负责在网络中的两节点之间建立、维持和终止通信，如服务器验证用户登录便是由会话层完成的。</li>
<li>运输层：有时也译为传输层，向主机进程提供通用的数据传输服务。该层主要有以下两种协议：<ul>
<li>TCP：提供面向连接的、可靠的数据传输服务；</li>
<li>UDP：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性。</li>
</ul>
</li>
<li>网络层：选择合适的路由和交换结点，确保数据及时传送。主要包括IP协议。</li>
<li>数据链路层：数据链路层通常简称为链路层。将网络层传下来的IP数据包组装成帧，并再相邻节点的链路上传送帧。</li>
<li>物理层：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和通信手段的差异。</li>
</ul>
<h3 id="什么是网络协议，为什么要对网络协议分层"><a href="#什么是网络协议，为什么要对网络协议分层" class="headerlink" title="什么是网络协议，为什么要对网络协议分层"></a>什么是网络协议，为什么要对网络协议分层</h3><p>网络协议是计算机在通信过程中要遵循的一些约定好的规则。</p>
<p>网络分层的原因：易于实现和维护，因为各层之间是独立的，层与层之间不会收到影响。有利于标准化的制定</p>
<h3 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h3><p>URI(Uniform Resource Identifier)：中文全称为统一资源标志符，主要作用是唯一标识一个资源。</p>
<p>URL(Uniform Resource Location)：中文全称为统一资源定位符，主要作用是提供资源的路径。</p>
<p>有个经典的比喻是URI像是身份证，可以唯一标识一个人，而URL更像一个住址，可以通过URL找到这个<br>人。</p>
<h3 id="在浏览器中输⼊url地址到显示主⻚的过程"><a href="#在浏览器中输⼊url地址到显示主⻚的过程" class="headerlink" title="在浏览器中输⼊url地址到显示主⻚的过程"></a>在浏览器中输⼊url地址到显示主⻚的过程</h3><ol>
<li><p>对输入到浏览器的url进行DNS解析，将域名转换为IP地址。</p>
<p> 浏览器搜索自己的DNS缓存（维护一张域名与IP的对应表）；若没有，则搜索操作系统的DNS缓存（维护一张域名与IP的对应表）；若没有，则搜索操作系统的hosts文件（维护一张域名与IP的对应表）。若都没有，则找 tcp&#x2F;ip 参数中设置的首选 dns 服务器，即本地 dns 服务器（递归查询），本地域名服务器查询自己的dns缓存，如果没有，则进行迭代查询。将本地dns服务器将IP返回给操作系统，同时缓存IP。</p>
</li>
<li><p>和目的服务器建立TCP连接</p>
<p> 发起 tcp 的三次握手，建立 tcp 连接。浏览器会以一个随机端口（1024-65535）向服务端的 web 程序 80 端口发起 tcp 的连接。</p>
</li>
<li><p>向目的服务器发送HTTP请求</p>
</li>
<li><p>服务器处理请求并返回HTTP报文，客户端得到 html 代码。</p>
</li>
<li><p>浏览器解析html 代码，并请求 html 中的资源</p>
</li>
<li><p>浏览器对页面进行渲染，并呈现给用户</p>
</li>
</ol>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Computer%20Network/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt="浏览器输入url过程"></p>
<h3 id="DNS的工作流程"><a href="#DNS的工作流程" class="headerlink" title="DNS的工作流程"></a>DNS的工作流程</h3><p>DNS的定义：DNS的全称是domain name system，即域名系统。DNS是因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的去访问互联网而不用去记住能够被机器直接读取的IP地址。比如大家访问百度，更多地肯定是访问<a target="_blank" rel="noopener" href="http://www.baidu.com,而不是访问112.80.248.74,因为这几乎无规则的ip地址实在太难记了.dns要做的就是将www.baidu.com解析成112.80.248.74./">www.baidu.com，而不是访问112.80.248.74，因为这几乎无规则的IP地址实在太难记了。DNS要做的就是将www.baidu.com解析成112.80.248.74。</a></p>
<h3 id="DNS是集群式的工作方式还是单点式的，为什么？"><a href="#DNS是集群式的工作方式还是单点式的，为什么？" class="headerlink" title="DNS是集群式的工作方式还是单点式的，为什么？"></a>DNS是集群式的工作方式还是单点式的，为什么？</h3><p>答案是集群式的，很容易想到的一个方案就是只用一个DNS服务器，包含了所有域名和IP地址的映射。尽管这种设计方式看起来很简单，但是缺点显而易见，如果这个唯一的DNS服务器出了故障，那么就全完了，因特网就几乎崩了。为了避免这种情况出现，DNS系统采用的是分布式的层次数据数据库模式，还有缓存的机制也能解决这种问题。</p>
<h3 id="DNS的工作流程-1"><a href="#DNS的工作流程-1" class="headerlink" title="DNS的工作流程"></a>DNS的工作流程</h3><p>主机向本地域名服务器的查询一般是采用递归查询（自己帮你去查），而本地域名服务器向根域名的查询一般是采用迭代查询（告诉你去哪查，你自己去）。</p>
<p>递归查询主机向本地域名发送查询请求报文，而本地域名服务器不知道该域名对应的IP地址时，本地域名服务器会继续向根域名服务器发送查询请求报文，不是通知主机自己向根域名发送查询请求报文。</p>
<p>迭代查询是，本地域名服务器向根域名发出查询请求报文后，根域名不会继续向顶级域名服务器发送查询请求报文，而是通知本地域名服务器自己去向顶级域名发送查询请求报文。</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/DNS.png" srcset="/img/loading.gif" lazyload alt="DNS"></p>
<ol>
<li>在浏览器中输入<a target="_blank" rel="noopener" href="http://www.baidu.com域名,操作系统会先检查自己本地的hosts文件是否有这个域名的/">www.baidu.com域名，操作系统会先检查自己本地的hosts文件是否有这个域名的</a><br>映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</li>
<li>如果hosts文件中没有，则查询本地DNS解析器<strong>缓存</strong>，如果有，则完成地址解析。</li>
<li>如果本地DNS解析器缓存中没有，则去查找本地DNS服务器，如果查到，完成解析。</li>
<li>如果没有，则本地服务器会向根域名服务器发起查询请求。根域名服务器会告诉本地域名服务器去<br>查询哪个顶级域名服务器（TLD DNS）。</li>
<li>本地域名服务器向顶级域名服务器发起查询请求，顶级域名服务器会告诉本地域名服务器去查找哪<br>个权威域名服务器。</li>
<li>本地域名服务器向权威域名服务器发起查询请求，权威域名服务器告诉本地域名服务器<a target="_blank" rel="noopener" href="http://www.baid/">www.baid</a><br>u.com所对应的IP地址。</li>
<li>本地域名服务器告诉主机<a target="_blank" rel="noopener" href="http://www.baidu.com所对应的ip地址./">www.baidu.com所对应的IP地址。</a></li>
</ol>
<h3 id="TCP和UDP的区别？"><a href="#TCP和UDP的区别？" class="headerlink" title="TCP和UDP的区别？"></a>TCP和UDP的区别？</h3><table>
<thead>
<tr>
<th></th>
<th>UDP</th>
<th>TCP</th>
</tr>
</thead>
<tbody><tr>
<td>是否连接（最大区别）</td>
<td>无连接</td>
<td>面向连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td>不可靠传输，不使用流量控制和拥塞控制</td>
<td>可靠传输，使用流量控制和拥塞控制</td>
</tr>
<tr>
<td>是否有序</td>
<td>无序</td>
<td>有序，消息在传输过程中可能会乱序，TCP 会重新排序</td>
</tr>
<tr>
<td>传输速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>连接对象个数</td>
<td>支持一对一，一对多，多对一和多对多交互通信</td>
<td>只能是一对一通信</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向报文</td>
<td>面向字节流</td>
</tr>
<tr>
<td>首部开销</td>
<td>首部开销小，仅8字节</td>
<td>首部最小20字节，最大60字节</td>
</tr>
<tr>
<td>适用场景</td>
<td>适用于面向无连接，实时应用（IP电话、视频会议、直播等）</td>
<td>适用于面向连接，要求可靠传输的应用，例如文件、邮件传输</td>
</tr>
</tbody></table>
<p>总结：</p>
<p>TCP 用于在传输层有必要实现<strong>可靠</strong>传输的情况，UDP 用于对<strong>高速传输和实时性</strong>有较高要求的通信。TCP和 UDP 应该根据应用目的按需使用。</p>
<h3 id="UDP-和-TCP-对应的应用场景是什么？"><a href="#UDP-和-TCP-对应的应用场景是什么？" class="headerlink" title="UDP 和 TCP 对应的应用场景是什么？"></a>UDP 和 TCP 对应的应用场景是什么？</h3><p>TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：FTP文件传输、HTTP &#x2F; HTTPS超文本传输协议、SMTP电子邮件协议、TELNET远程终端接入</p>
<p>UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：包总量较少的通信，如 DNS域名转换 、SNMP（简单网络管理协议，用于网络设备的管理）等、视频、音频等多媒体通信、广播通信</p>
<h3 id="TCP和UDP的首部都包含什么"><a href="#TCP和UDP的首部都包含什么" class="headerlink" title="TCP和UDP的首部都包含什么"></a>TCP和UDP的首部都包含什么</h3><p>TCP首部：前20个字节是固定的，后面有4n个字节是根据需而增加的选项，所以TCP首部最小长度为20字节，最大60字节</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Computer%20Network/TCP%E9%A6%96%E9%83%A8.png" srcset="/img/loading.gif" lazyload alt="image-20220427175815106"></p>
<p>UDP首部：UDP的首部只有8个字节，源端口号、目的端口号、长度和校验和各两个字节。</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Computer%20Network/UDP%E9%A6%96%E9%83%A8.png" srcset="/img/loading.gif" lazyload alt="image-20220427175944012"></p>
<h3 id="TCP协议如何保证可靠传输"><a href="#TCP协议如何保证可靠传输" class="headerlink" title="TCP协议如何保证可靠传输"></a>TCP协议如何保证可靠传输</h3><p>主要有校验和、序列号、超时重传、流量控制及拥塞避免等几种方法。</p>
<p>校验和：在发送端和接收端分别计算数据的校验和，如果两者不一致，则说明数据在传输过程中出现了差错，TCP将丢弃和不确认此报文段。</p>
<p>序列号&#x2F;确认应答：TCP会对每一个发送的字节进行编号，接收方接到数据后，会对发送方发送确认应答（ACK报文），并且这个ACK报文中带有相应的确认编号，告诉发送方，下一次发送的数据从编号多少开始发。</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Computer%20Network/TCP%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93-%E5%BA%8F%E5%88%97%E5%8F%B7.png" srcset="/img/loading.gif" lazyload alt="image-20220506164148913"></p>
<p>超时重传：超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。最大超时时间是动态计算的。</p>
<p>流量控制：如果主机A 一直向主机B发送数据，不考虑主机B的接受能力，则可能导致主机B的接受缓冲区满了而无法再接受数据，从而会导致大量的数据丢包，引发重传机制。而在重传的过程中，若主机B的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效率。所以引入流量控制机制，主机B通过告诉主机A自己接收缓冲区的大小，来使主机A控制发送的数据量。流量控制与TCP协议报头中的窗口大小有关。窗口的大小就是接收端接收数据缓冲区的剩余大小。接收端会在收到数据包后发送ACK报文时，将自己的窗口大小填入ACK中，发送方会根据ACK报文中的窗口大小进而控制发送速度。如果窗口大小为零，发送方会停止发送数据。</p>
<p>滑动窗口：滑动窗口既提高了报文传输的效率，也避免了发送方发送过多的数据而导致接收方无法正常处理的异常。</p>
<p>拥塞控制：在数据传输过程中，可能由于网络状态的问题，造成网络拥堵，此时引入拥塞控制机制，在保证TCP可靠性的同时，提高性能。</p>
<h3 id="详细讲一下TCP的滑动窗口？"><a href="#详细讲一下TCP的滑动窗口？" class="headerlink" title="详细讲一下TCP的滑动窗口？"></a>详细讲一下TCP的滑动窗口？</h3><h3 id="详细讲一下拥塞控制？"><a href="#详细讲一下拥塞控制？" class="headerlink" title="详细讲一下拥塞控制？"></a>详细讲一下拥塞控制？</h3><h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>如果TCP连接已经建立，在通信过程中，客户端突然故障，那么服务端不会一直等下去，过一段时间就关闭连接了。具体原理是TCP有一个保活机制，主要用在服务器端，用于检测已建立TCP链接的客户端的状态，防止因客户端崩溃或者客户端网络不可达，而服务器端一直保持该TCP链接，占用服务器端的大量资源（因为Linux系统中可以创建的总TCP链接数是有限制的）。</p>
<p>保活机制原理：设置TCP保活机制的保活时间keepIdle，即在TCP链接超过该时间没有任何数据交互时，发送保活探测报文；设置保活探测报文的发送时间间隔keepInterval；设置保活探测报文的总发送次数keepCount。如果在keepCount次的保活探测报文均没有收到客户端的回应，则服务器端即关闭与客户端的TCP链接。</p>
<h3 id="详细介绍一下-TCP-的三次握手机制？"><a href="#详细介绍一下-TCP-的三次握手机制？" class="headerlink" title="详细介绍一下 TCP 的三次握手机制？"></a>详细介绍一下 TCP 的三次握手机制？</h3><p>TCP报文首部由多个部分组成，只列出此处相关的：</p>
<ul>
<li>Sequence number ：序号，seq，TCP连接中传送的字节流中的每个字节都按顺序编号，序号是发送数据包中的第一个字节的序列号。发送方和接收方都有自己的顺序号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；</li>
<li>Acknowledge number：确认号，ack，响应前面的seq，是期望收到对方下一个报文的第一个数据字节的序号，通常期望下次发出的序列号为seq+1。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；</li>
</ul>
<p>然后有一些TCP标志位，TCP标志位的值代表了当前请求的目的。标志位一共有6种，分别是：</p>
<ul>
<li>SYN(synchronous)： 发送&#x2F;同步标志，用来建立连接，和下面的第二个标志位ACK搭配使用。连接开始时，SYN&#x3D;1，ACK&#x3D;0，代表连接开始但是未获得响应。当连接被响应的时候，标志位会发生变化，其中ACK会置为1，代表确认收到连接请求，此时的标志位变成了 SYN&#x3D;1，ACK&#x3D;1。</li>
<li>ACK(acknowledgement)：确认标志，表示确认收到请求。</li>
<li>PSH(push) ：表示推送操作，就是指数据包到达接收端以后，不对其进行队列处理，而是尽可能的将数据交给应用程序处理；</li>
<li>FIN(finish)：结束标志，用于结束一个TCP会话；</li>
<li>RST(reset)：重置复位标志，用于复位对应的TCP连接。</li>
<li>URG(urgent)：紧急标志，用于保证TCP连接不被中断，并且督促中间层设备尽快处理。</li>
</ul>
<p>三次握手的本质就是确定发送端和接收端具备收发信息的能力，在能流畅描述三次握手的流程及其中的字段含义作用的同时还需要记住<strong>每次握手时接收端和发送端的状态</strong>。这个比较容易忽略</p>
<p>TCP三次握手机制：</p>
<ul>
<li>开始时客户端和服务端的状态都是CLOSED；</li>
<li>第一次握手：客户端向服务端发起建立连接请求，客户端会随机生成一个起始序列号x，客户端向服务端发送的字段中包含标志位SYN&#x3D;1，序列号seq&#x3D;x。TCP规定，SYN报文段（SYN&#x3D;1的报文段）不能携带数据，但需要消耗掉一个序号。第一次握手前客户端的状态为CLOSE，第一次握手后客户端的状态为SYN-SENT（同步已发送）。此时服务端的状态为LISTEN</li>
<li>第二次握手：服务端在收到客户端发来的报文后，如果同意建立连接，会随机生成一个服务端的起始序列号y，然后给客户端回复一段报文，其中包括标志位SYN&#x3D;1（表示要和客户端建立一个连接），ACK&#x3D;1（表示确认序号有效），序列号seq&#x3D;y，确认号ack&#x3D;x+1。TCP规定，这个报文（SYN+ACK）也不能携带数据，但是同样要消耗一个序号。第二次握手前服务端的状态为LISTEN，第二次握手后服务端的状态为SYN-RCVD（同步收到），此时客户端的状态为SYN-SENT（同步已发送）。</li>
<li>第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含标志位ACK&#x3D;1，序列号seq&#x3D;x+1（因为第一次握手时SYN消耗了一个序号，所以这次是x+1），确认号ack&#x3D;y+1。第三次握手前客户端的状态为SYN-SENT（同步已发送），第三次握手后客户端和服务端的状态都为ESTABLISHED（已建立连接）。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号（可以认为不占用序号）。</li>
<li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li>
</ul>
<p>理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Computer%20Network/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="TCP三次握手示意图"></p>
<h3 id="为什么需要三次握手，而不是两次？"><a href="#为什么需要三次握手，而不是两次？" class="headerlink" title="为什么需要三次握手，而不是两次？"></a>为什么需要三次握手，而不是两次？</h3><p>不可以，主要从以下两方面考虑（假设客户端是首先发起连接请求）：</p>
<ol>
<li>假设建立TCP连接仅需要两次握手，如果服务端接收到了一个早已失效的来自客户端的连接请求报文，会向客户端发送确认报文同意建立TCP连接。但其实客户端并不想向服务端发送数据，那个只是之前失效的请求报文，所以此次TCP连接没有意义并且浪费了资源。</li>
<li>假设建立TCP连接仅需要两次握手，那么如果第二次握手时，服务端返回给客户端的确认报文丢失了，客户端这边认为服务端没有和他建立连接，而服务端却以为已经和客户端建立了连接，并且可能向服务端已经开始向客户端发送数据，但客户端并不会接收这些数据，浪费了资源。如果是三次握手，不会出现双方连接还未完全建立成功就开始发送数据的情况。</li>
</ol>
<p>总结：</p>
<ul>
<li><p>三次握手才能让双方均确认自己和对方的发送和接收能力都正常。</p>
<ul>
<li>第一次握手：服务端确认 客户端发、服务端收 正常。</li>
<li>第二次握手：客户端确认 客户端发收、服务端发收 正常，客户端认为连接已建立。</li>
<li>第三次握手：服务端确认 客户端发收、服务端发收 正常，此时双方均建立连接，可以正常通信。</li>
</ul>
</li>
<li><p>三次握手是保证可靠数据传输的原因之一，告知对方自己的初始序号值，并确认收到对方的初始序号值</p>
<p>   TCP 报文段中维护了序号字段和确认序号字段，通过这两个字段双方都可以知道在自己发出的数据中，哪些是已经被对方确认接收的。这两个字段的值会在初始序号值得基础递增，如果是两次握手，只有发起方的初始序号可以得到确认，而另一方的初始序号则得不到确认。</p>
</li>
</ul>
<h3 id="为什么要三次握手，而不是四次？"><a href="#为什么要三次握手，而不是四次？" class="headerlink" title="为什么要三次握手，而不是四次？"></a>为什么要三次握手，而不是四次？</h3><p>因为三次握手已经可以确认双方的发送接收能力正常，双方都知道彼此已经准备好，而且也可以完成对双方初始序号值的确认，也就无需再第四次握手了。</p>
<h3 id="什么是-SYN洪泛攻击？如何防范？"><a href="#什么是-SYN洪泛攻击？如何防范？" class="headerlink" title="什么是 SYN洪泛攻击？如何防范？"></a>什么是 SYN洪泛攻击？如何防范？</h3><blockquote>
<p>SYN洪泛攻击属于 DOS 攻击的一种，它利用 TCP 协议缺陷，通过发送大量的半连接请求，耗费 CPU 和内存资源。</p>
<p>在三次握手过程中，服务器发送 [SYN+ACK] 包（第二个包）之后、收到客户端的 [ACK] 包（第三个包）之前的 TCP 连接称为半连接（half-open connect），此时服务器处于 SYN_RECV （等待客户端响应）状态。如果接收到客户端的 [ACK] ，则 TCP 连接成功，如果未接受到，则会不断重发请求直至成功。</p>
</blockquote>
<p>SYN 攻击的攻击者在短时间内伪造大量不存在的 IP 地址，向服务器不断地发送 [SYN] 包，服务器回复 [SYN+ACK] 包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时。</p>
<p>这些伪造的 [SYN] 包将长时间占用未连接队列，影响了正常的 SYN，导致目标系统运行缓慢、网络堵塞甚至系统瘫痪。</p>
<p>检测：当在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次SYN 攻击。</p>
<p>防范:</p>
<ul>
<li>通过防火墙、路由器等过滤网关防护。</li>
<li>通过加固 TCP&#x2F;IP 协议栈防范，如增加最大半连接数，缩短超时时间。</li>
<li>SYN cookies技术。SYN Cookies 是对 TCP 服务器端的三次握手做一些修改，专门用来防范 SYN洪泛攻击的一种手段。</li>
</ul>
<h3 id="三次握手连接阶段，最后一次ACK包丢失，会发生什么？"><a href="#三次握手连接阶段，最后一次ACK包丢失，会发生什么？" class="headerlink" title="三次握手连接阶段，最后一次ACK包丢失，会发生什么？"></a>三次握手连接阶段，最后一次ACK包丢失，会发生什么？</h3><ul>
<li>服务端：<ul>
<li>第三次的ACK在网络中丢失，那么服务端状态为SYN_RECV，并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便客户端重新发送ACK包。</li>
<li>如果重发指定次数之后，仍然未收到 客户端的ACK应答，那么一段时间后，服务端自动关闭这个连接。</li>
</ul>
</li>
<li>客户端：<ul>
<li>客户端认为这个连接已经建立，如果客户端向服务端发送数据，服务端将以RST包（Reset，标示复位，用于异常的关闭连接）响应。此时，客户端知道第三次握手失败。</li>
</ul>
</li>
</ul>
<h3 id="TCP的四次挥手？"><a href="#TCP的四次挥手？" class="headerlink" title="TCP的四次挥手？"></a>TCP的四次挥手？</h3><p>假设客户端首先发起的断开连接请求</p>
<p>第一次挥手：客户端向服务端发送的数据完成后，向服务端发送连接释放报文，报文包含标志位FIN&#x3D;1，序列号seq&#x3D;u。客户端主动关闭连接，同时等待服务端的确认。此时客户端只能接收数据，不能向服务端发送数据。</p>
<p>第二次挥手：服务端收到客户端的释放连接报文后，向客户端发送确认报文，包含标志位ACK&#x3D;1，序列号seq&#x3D;v，确认号ack&#x3D;u+1。这时 客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据。</p>
<p>第三次挥手：服务端发送完剩余数据后向客户端发送连接释放报文，报文包含标志位FIN&#x3D;1，标志位ACK&#x3D;1，序列号seq&#x3D;w，确认号ack&#x3D;u+1（与第二次挥手相同，因为这段时间客户端没有发送数据）。</p>
<p>第四次挥手：客户端收到服务端发送的释放连接请求，向服务端发送确认报文，包含标志位ACK&#x3D;1，序列号seq&#x3D;u+1，确认号ack&#x3D;w+1。此时，客户端就进入了 TIME-WAIT 状态。注意此时客户端的TCP 连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，才进入 CLOSED 状态。而服务端只要收到客户端发出的确认，就立即进入 CLOSED 状态。可以看到，服务端结束 TCP 连接的时间要比客户端早一些。</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Computer%20Network/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="TCP四次挥手"></p>
<h3 id="为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手？</h3><p>因为需要确保通信双方都能通知对方释放连接，假设客户端发送完数据向服务端发送释放连接请求，当客服端并不知道，服务端是否已经发送完数据，所以此次断开的是客户端到服务端的单向连接，服务端返回给客户端确认报文后，服务端还能继续单向给客户端发送数据。当服务端发送完数据后还需要向客户端发送释放连接请求，客户端返回确认报文，TCP连接彻底关闭。所以断开TCP连接需要客户端和服务端分别通知对方并分别收到确认报文，一共需要四次。</p>
<h3 id="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"><a href="#为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？" class="headerlink" title="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"></a>为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</h3><p>MSL的意思是报文的最长寿命，可以从两方面考虑：</p>
<ol>
<li>确保 ACK 报文能够到达服务端，从而使服务端正常关闭连接。</li>
</ol>
<p>  第四次挥手时，客户端第四次挥手的 ACK 报文不一定会到达服务端。服务端会超时重传 FIN&#x2F;ACK报文，此时如果客户端已经断开了连接，那么就无法响应服务端的二次请求，这样服务端迟迟收不到 FIN&#x2F;ACK 报文的确认，就无法正常断开连接。<br>  MSL 是报文段在网络上存活的最长时间。客户端等待 2MSL 时间，即「客户端 ACK 报文 1MSL 超时 + 服务端 FIN 报文 1MSL 传输」，就能够收到服务端重传的 FIN&#x2F;ACK 报文，然后客户端重传一次 ACK 报文，并重新启动 2MSL 计时器。如此保证服务端能够正常关闭。如果服务端重发的 FIN 没有成功地在 2MSL 时间里传给客户端，服务端则会继续超时重试直到断开连接。</p>
<ol start="2">
<li>防止已失效的连接请求报文段出现在之后的连接中。</li>
</ol>
<p>  TCP 要求在 2MSL 内不使用相同的序列号。客户端在发送完最后一个 ACK 报文段后，再经过时间2MSL，就可以保证本连接持续的时间内产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。或者即使收到这些过时的报文，也可以不处理它。</p>
<h3 id="HTTP-与-HTTPS-的区别？"><a href="#HTTP-与-HTTPS-的区别？" class="headerlink" title="HTTP 与 HTTPS 的区别？"></a>HTTP 与 HTTPS 的区别？</h3><p>HTTPS，超文本传输安全协议，简单讲是HTTP的安全版。目前主流的网站基本上开始默认采用HTTPS作为通信方式</p>
<table>
<thead>
<tr>
<th></th>
<th>HTTP</th>
<th>HTTPS</th>
</tr>
</thead>
<tbody><tr>
<td>端口</td>
<td>80</td>
<td>443</td>
</tr>
<tr>
<td>安全性</td>
<td>无加密，安全性较差</td>
<td>有加密机制，安全性较高</td>
</tr>
<tr>
<td>资源消耗</td>
<td>较少</td>
<td>由于加密处理，资源消耗更多</td>
</tr>
<tr>
<td>是否需要证书</td>
<td>不需要</td>
<td>需要</td>
</tr>
<tr>
<td>协议</td>
<td>运行在TCP协议之上</td>
<td>运行在SSL协议之上，SSL运行在TCP协议之上</td>
</tr>
</tbody></table>
<h3 id="HTTPS-的优缺点"><a href="#HTTPS-的优缺点" class="headerlink" title="HTTPS 的优缺点?"></a>HTTPS 的优缺点?</h3><p>优点：</p>
<ul>
<li>安全性：使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li>
<li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li>
<li>SEO方面：谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</li>
</ul>
<p>缺点：</p>
<ul>
<li>在相同网络环境中，HTTPS 相比 HTTP 无论是响应时间还是耗电量都有大幅度上升。</li>
<li>HTTPS 的安全是有范围的，在黑客攻击、服务器劫持等情况下几乎起不到作用。</li>
<li>在现有的证书机制下，中间人攻击依然有可能发生。</li>
<li>HTTPS 需要更多的服务器资源，也会导致成本的升高。</li>
</ul>
<h3 id="什么是对称加密与非对称加密？"><a href="#什么是对称加密与非对称加密？" class="headerlink" title="什么是对称加密与非对称加密？"></a>什么是对称加密与非对称加密？</h3><ul>
<li>对称加密</li>
</ul>
<p>对称加密指加密和解密使用同一密钥，优点是运算速度快，缺点是没办法保证安全将密钥传输给另一方。常见的对称加密算法有DES、AES等等。</p>
<ul>
<li>非对称加密</li>
</ul>
<p>非对称加密指的是加密和解密使用不同的密钥，一把公开的公钥，一把私有的私钥，这两个密钥是成对出现的。公钥加密的信息只有私钥才能解密，私钥加密的信息只有公钥才能解密。<strong>私钥由服务器自己保存，公钥发送给客户端</strong>。客户端拿到公钥后可以对请求进行加密后发送给服务端，这时候就算中间被截获，没有私钥也无法解密发送的内容，这样确保了<strong>客户端发送到服务端数据的安全</strong>。通过一组公钥私钥，已经可以保证单个方向传输的安全性，那用两组公钥私钥，就能保证双向传输都安全。优点是解决了对称加密中存在的问题。缺点是运算速度较慢。常见的非对称加密算法有RSA、DSA、ECC等等。</p>
<p>两组公钥私钥，非对称加密的工作流程：</p>
<ol>
<li>某网站拥有用于非对称加密的公钥A1、私钥A2；浏览器拥有用于非对称加密的公钥B1、私钥B2。</li>
<li>浏览器向网站服务器请求，服务器把公钥A1明文传输给浏览器。</li>
<li>浏览器把公钥B1明文传输给服务器。</li>
<li>之后浏览器向服务器传输的所有东西都用公钥A1加密，服务器收到后用私钥A2解密。由于只有服务器拥有私钥A2进行解密，所以能保证这条数据的安全。</li>
<li>服务器向浏览器传输的所有东西都用公钥B1加密，浏览器收到后用私钥B2解密。同上也可以保证这条数据的安全。</li>
</ol>
<p>可见确实可行。抛开这里面仍有的漏洞不谈（下文会讲），HTTPS的加密却没使用这种方案，为什么？最主要的原因是非对称加密算法非常耗时，特别是加密解密一些较大数据的时候有些力不从心。而对称加密快很多。那我们能不能运用非对称加密的特性解决前面提到的对称加密的问题？</p>
<h3 id="HTTPS的加密过程"><a href="#HTTPS的加密过程" class="headerlink" title="HTTPS的加密过程"></a>HTTPS的加密过程</h3><p>上面提到了对称加密和非对称加密的优缺点，HTTPS加密使用的对称加密和非对称加密的混合加密算法。具体做法就是<strong>使用非对称加密</strong>来<strong>传输对称密钥</strong>来保证安全性，使用对称加密来保证通信的效率。</p>
<p>非对称加密耗时，我们考虑是否可以采用非对称加密+对称加密结合的方式，而且要尽量减少非对称加密的次数。非对称加密、解密各只需一次的方法：</p>
<ol>
<li>某网站拥有用于非对称加密的公钥A1、私钥A2。</li>
<li>浏览器向网站服务器请求，服务器把公钥A1明文给传输浏览器。</li>
<li>浏览器随机生成一个用于对称加密的密钥X，用公钥A1加密后传给服务器。</li>
<li>服务器拿到后用私钥A2解密得到密钥X。</li>
<li>这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都用密钥X加密解密即可。</li>
</ol>
<p>HTTPS基本就是采用了这种方案。但还是有漏洞的。</p>
<p>中间人攻击：浏览器生成的对称密钥X被公钥A1加密，只有服务器才能用私钥A2进行解密。然而中间人却完全不需要拿到私钥A2就能劫持信息。过程为：</p>
<ol>
<li>某网站拥有用于非对称加密的公钥A1、私钥A2。</li>
<li>浏览器向网站服务器请求，服务器把公钥A1明文传输给浏览器。</li>
<li>中间人劫持到公钥A1，保存下来，把数据包中的公钥A1替换成自己伪造的公钥B1（它当然也拥有公钥B1对应的私钥B2）。</li>
<li>浏览器随机生成一个用于对称加密的密钥X，用公钥B1（<strong>浏览器不知道公钥被替换了</strong>）加密后传给服务器。</li>
<li>中间人劫持后用私钥B2解密得到密钥X，再用公钥A1加密后传给服务器。</li>
<li>服务器拿到后用私钥A2解密得到密钥X。</li>
</ol>
<p>这样在双方都不会发现异常的情况下，中间人得到了对称密钥X。根本原因是浏览器无法确认自己收到的公钥是不是网站自己的。那么下一步就是解决这个问题：如何证明浏览器收到的公钥一定是该网站的公钥？</p>
<p>现实生活中，如果想证明某身份证号一定是小明的，怎么办？看身份证。这里政府机构起到了“公信”的作用，身份证是由它颁发的，它本身的权威可以对一个人的身份信息作出证明。互联网中也有这么一个公信机构，CA 机构。网站在使用HTTPS前，需要向“<strong>CA机构</strong>”申请颁发一<strong>数字证书</strong>，数字证书里有<strong>证书持有者、证书持有者的公钥等信息</strong>。<strong>服务器把证书传输给浏览器，浏览器从证书里取公钥</strong>就可以了。</p>
<p>因此HTTPS的加密过程：</p>
<ol>
<li>客户端向服务端发送请求，然后连接到客户端的443端口。</li>
<li>服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。</li>
<li><strong>传送证书</strong><br> 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。</li>
<li><strong>客户端解析证书</strong><br> 这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值（密钥）。然后用证书对该随机值进行加密。</li>
<li><strong>传送加密信息</strong><br> 这部分传送的是用证书加密后的密钥（随机值），目的就是让服务端得到这个密钥（随机值），以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</li>
<li><strong>服务端加密信息</strong><br> 服务端用私钥解密，得到了客户端传过来的密钥（随机值），然后把内容通过该值进行对称加密。</li>
<li><strong>传输加密后的信息</strong><br> 这部分信息是服务端用密钥（随机值）对称加密后的信息，可以在客户端被还原。</li>
<li><strong>客户端解密信息</strong><br> 客户端用之前生成的密钥（随机值）解密服务端传过来的信息，于是获取了解密后的内容。</li>
</ol>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Computer%20Network/HTTPS%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt="image-20220504152610993"></p>
<p>上述流程存在的一个问题是客户端哪里来的数字认证机构的公钥，其实，在很多浏览器开发时，会内置常用数字证书认证机构的公钥。</p>
<h3 id="常见的状态码？"><a href="#常见的状态码？" class="headerlink" title="常见的状态码？"></a>常见的状态码？</h3><ul>
<li><p>1XX：信息性状态码</p>
<ul>
<li>100 Continue：表示正常，客户端可以继续发送请求</li>
<li>101 Switching Protocols：切换协议，服务器根据客户端的请求切换协议。</li>
</ul>
</li>
<li><p>2XX：成功状态码</p>
<ul>
<li>200 OK：请求成功</li>
<li>201 Created：已创建，表示成功请求并创建了新的资源</li>
<li>202 Accepted：已接受，已接受请求，但未处理完成。</li>
<li>204 No Content：无内容，服务器成功处理，但未返回内容。</li>
<li>205 Reset Content：重置内容，服务器处理成功，客户端应重置文档视图。</li>
<li>206 Partial Content：表示客户端进行了范围请求，响应报文应包含Content-Range指定范围的实体内容</li>
</ul>
</li>
<li><p>3XX：重定向状态码</p>
<ul>
<li>301 Moved Permanently：永久性重定向</li>
<li>302 Found：临时重定向</li>
<li>303 See Other：和301功能类似，但要求客户端采用get方法获取资源</li>
<li>304 Not Modified：所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。</li>
<li>305 Use Proxy：所请求的资源必须通过代理访问</li>
<li>307 Temporary Redirect： 临时重定向，与302类似，要求使用get请求重定向。</li>
</ul>
</li>
<li><p>4XX：客户端错误状态码</p>
<ul>
<li>400 Bad Request：客户端请求的语法错误，服务器无法理解。</li>
<li>401 Unauthorized：表示发送的请求需要有认证信息。</li>
<li>403 Forbidden：服务器理解用户的请求，但是拒绝执行该请求</li>
<li>404 Not Found：服务器无法根据客户端的请求找到资源。</li>
<li>405 Method Not Allowed：客户端请求中的方法被禁止</li>
<li>406 Not Acceptable：服务器无法根据客户端请求的内容特性完成请求</li>
<li>408 Request Time-out：服务器等待客户端发送的请求时间过长，超时</li>
</ul>
</li>
<li><p>5XX：服务端错误状态码</p>
<ul>
<li>500 Internal Server Error：服务器内部错误，无法完成请求</li>
<li>501 Not Implemented：服务器不支持请求的功能，无法完成请求</li>
</ul>
</li>
</ul>
<h3 id="状态码301和302的区别是什么？"><a href="#状态码301和302的区别是什么？" class="headerlink" title="状态码301和302的区别是什么？"></a>状态码301和302的区别是什么？</h3><p>共同点：301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）。<br>不同点：301表示旧地址A的资源已经被永久地移除了(这个资源不可访问了)，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO中302好于301。</p>
<h3 id="转发和重定向？"><a href="#转发和重定向？" class="headerlink" title="转发和重定向？"></a>转发和重定向？</h3><p>重定向的原因：</p>
<ol>
<li>网站调整（如改变网页目录结构）；</li>
<li>网页被移到一个新地址；</li>
<li>网页扩展名改变(如应用需要把.php改成.Html或.shtml)。</li>
</ol>
<p>重定向的典型场景，我把一个数据删除了，删除应该返回的东西是什么，肯定不是返回删除的东西，一般来说删除之后返回查询页面，会更加直观，那么这里就是重定向，我明明请求发送的是删除，但是重定向到了查询。具体的过程就是，浏览器发送的请求是删除，服务器返回的是一个建议，状态码是302，返回的建议里带上建议访问的目标，浏览器就会访问这个建议的URL。而且很显然的事情是我们并不能在服务器内部去做这些事情，你不能说把删除的代码里写上和查询有关的内容，删除和查询是独立的功能，要保证低耦合。所以重定向以低耦合的方式完成了页面的跳转，意义重大</p>
<p>再比如注册完了重定向到登陆页面，也是一样的道理。</p>
<h3 id="常见的HTTP方法"><a href="#常见的HTTP方法" class="headerlink" title="常见的HTTP方法"></a>常见的HTTP方法</h3><p>PUT：上传文件，向服务器添加数据，可以看作增</p>
<p>DELETE：删除文件</p>
<p>POST：传输数据，向服务器提交数据，对服务器数据进行更新。</p>
<p>GET：获取资源，查询服务器资源</p>
<p>下面的有空可以背背</p>
<p>HEAD：和GET方法类似，但只返回报文首部，不返回报文实体主体部分</p>
<p>PATCH：对资源进行部分修改</p>
<p>OPTIONS：查询指定的URL支持的方法</p>
<p>CONNECT：要求用隧道协议连接代理</p>
<p>TRACE：服务器会将通信路径返回给客户端</p>
<h3 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h3><ul>
<li><p>作用</p>
<p>  GET用于获取资源，POST用于传输实体主体</p>
</li>
<li><p>参数位置</p>
<p>  GET的参数放在URL中，POST的参数存储在实体主体中，并且GET方法提交请求的URL中的数据最多是2048字节，POST请求没有大小限制。</p>
</li>
<li><p>安全性</p>
<p>  GET方法因为参数放在URL中，安全性相对于POST较差一些</p>
</li>
<li><p>幂等性</p>
<p>  GET方法是具有幂等性的，而POST方法不具有幂等性。这里幂等性指客户端连续发出多次请求，收到的结果都是一样的.</p>
</li>
</ul>
<h3 id="HTTP请求报文和响应报文的格式？"><a href="#HTTP请求报文和响应报文的格式？" class="headerlink" title="HTTP请求报文和响应报文的格式？"></a>HTTP请求报文和响应报文的格式？</h3><p>请求报文格式：</p>
<ol>
<li>请求行（请求方法+URI协议+版本）</li>
<li>请求头部</li>
<li>空行</li>
<li>请求主体</li>
</ol>
<p>响应报文：</p>
<ol>
<li>状态行（版本+状态码+原因短语）</li>
<li>响应首部</li>
<li>空行</li>
<li>响应主体</li>
</ol>
<h3 id="HTTP-1-0、HTTP-1-1及HTTP-2-0的主要区别是什么"><a href="#HTTP-1-0、HTTP-1-1及HTTP-2-0的主要区别是什么" class="headerlink" title="HTTP 1.0、HTTP 1.1及HTTP 2.0的主要区别是什么"></a>HTTP 1.0、HTTP 1.1及HTTP 2.0的主要区别是什么</h3><p>HTTP 1.0和HTTP 1.1的区别：</p>
<ul>
<li><p>长连接</p>
<p>  HTTP 1.1支持长连接和请求的流水线操作。长连接是指不在需要每次请求都重新建立一次连接，HTTP 1.0默认使用短连接，每次请求都要重新建立一次TCP连接，资源消耗较大。</p>
<p>  请求的流水线操作是指客户端在收到HTTP的响应报文之前可以先发送新的请求报文，不支持请求的流水线操作需要等到收到HTTP的响应报文后才能继续发送新的请求报文。</p>
</li>
<li><p>缓存处理</p>
<p>  在HTTP 1.0中主要使用header中的If-Modified-Since,Expires作为缓存判断的标准，HTTP 1.1引入了Entity tag，If-Unmodified-Since, If-Match等更多可供选择的缓存头来控制缓存策略。</p>
</li>
<li><p>错误状态码</p>
<p>  在HTTP 1.1新增了24个错误状态响应码</p>
</li>
<li><p>HOST域<br>  在HTTP 1.0 中认为每台服务器都会绑定唯一的IP地址，所以，请求中的URL并没有传递主机名。但后来一台服务器上可能存在多个虚拟机，它们共享一个IP地址，所以HTTP 1.1中请求消息和响应消息都应该支持Host域。</p>
</li>
<li><p>带宽优化及网络连接的使用</p>
<p>  在HTTP 1.0中会存在浪费带宽的现象，主要是因为不支持断点续传功能，客户端只是需要某个对象的一部分，服务端却将整个对象都传了过来。在HTTP 1.1中请求头引入了range头域，它支持只请求资源的某个部分，返回的状态码为206。</p>
</li>
</ul>
<p>HTTP 2.0的新特性</p>
<ul>
<li>新的二进制格式：HTTP 1.x的解析是基于文本，HTTP 2.0的解析采用二进制，实现方便，健壮性更好。</li>
<li>多路复用：每一个request对应一个id，一个连接上可以有多个request，每个连接的request可以随机混在一起，这样接收方可以根据request的id将request归属到各自不同的服务端请求里。</li>
<li>header压缩：在HTTP 1.x中，header携带大量信息，并且每次都需要重新发送，HTTP 2.0采用编码的方式减小了header的大小，同时通信双方各自缓存一份header fields表，避免了header的重复传输。</li>
<li>服务端推送：客户端在请求一个资源时，会把相关资源一起发给客户端，这样客户端就不需要再次发起请求。</li>
</ul>
<h3 id="Cookie、Session和Token的主要区别"><a href="#Cookie、Session和Token的主要区别" class="headerlink" title="Cookie、Session和Token的主要区别"></a>Cookie、Session和Token的主要区别</h3><p>HTTP协议是无状态的，即服务器无法判断用户身份。Session和Cookie可以用来进行身份辨认。</p>
<ul>
<li><p>Cookie</p>
<p>  Cookie是保存在客户端一个小数据块，其中包含了用户信息。当客户端向服务端发起请求，服务端会像客户端浏览器发送一个Cookie，客户端会把Cookie存起来，当下次客户端再次请求服务端时，会携带上这个Cookie，服务端会通过这个Cookie来确定身份。</p>
</li>
<li><p>Session</p>
<p>  Session是通过Cookie实现的，和Cookie不同的是，Session是存在服务端的。当客户端浏览器第一次访问服务器时，服务器会为浏览器创建一个sessionid，将sessionid放到Cookie中，存在客户端浏览器。比如浏览器访问的是购物网站，将一本《图解HTTP》放到了购物车，当浏览器再次访问服务器时，服务器会取出Cookie中的sessionid，并根据sessionid获取会话中的存储的信息，确认浏览器的身份是上次将《图解HTTP》放入到购物车那个用户。</p>
</li>
<li><p>Token（令牌）</p>
<p>  客户端在浏览器第一次访问服务端时，服务端生成的一串字符串作为Token发给客户端浏览器，下次浏览器在访问服务端时携带token即可无需验证用户名和密码，省下来大量的资源开销。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>存放位置</th>
<th>占用空间</th>
<th>安全性</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Cookie</td>
<td>客户端浏览器</td>
<td>小</td>
<td>较低</td>
<td>一般存放配置信息</td>
</tr>
<tr>
<td>Session</td>
<td>服务端</td>
<td>多</td>
<td>较高</td>
<td>存放较为重要的信息</td>
</tr>
</tbody></table>
<p>存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在Session 中保持一些常用变量信息，比如说 UserId 等。</p>
<p>有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</p>
<p>存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</p>
<h3 id="如何考虑分布式-Session-问题？"><a href="#如何考虑分布式-Session-问题？" class="headerlink" title="如何考虑分布式 Session 问题？"></a>如何考虑分布式 Session 问题？</h3><p>在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。</p>
<p>现有的方案是能用Cookie的用Cookie，不方便用cookie的用Session，单体的用Session肯定没有问题，但是Session放在分布式服务器里容易有问题，现在经常用nginx作为负载均衡的服务器，去分配来自众多用户（浏览器）的访问，</p>
<p>如果按照均衡的策略，将某个浏览器的请求发送给服务器1，建立了Session，结果下次这个浏览器请求经过nginx时，发现服务器1太忙了，分配给了其他服务器，那就得重新建立Session。</p>
<p>解决这个问题也有多种方案：</p>
<ul>
<li>一种是设置粘性Session，固定的ip永远都分给一个固定的服务器，但这并不能保证负载是均衡的，整体分布式性能不一定很好</li>
<li>一种是同步Session，建立了一个Session之后，所有分布式服务器同步复制一份Session，这样无论nginx将请求分配给哪个服务器，都可以有Session，但缺点也很明显，同步肯定损耗服务器性能，另外也让服务器之间耦合性增强，不那么独立</li>
<li>一种是共享Session，专门用一台服务器建立Session，其他分布式服务器都访问这个专门的服务器，不过也有问题，毕竟单体的服务器容易出问题。如果专门用来建立Session的服务器也用分布式的，那跟前面几种也差不多。现在更多的是把Session的数据都存到数据库里，至于是存到MySQL还是Redis看需求</li>
</ul>
<p>建议采用共享 Session的方案。</p>
<h3 id="如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="如果客户端禁止 cookie 能实现 session 还能用吗？"></a>如果客户端禁止 cookie 能实现 session 还能用吗？</h3><p>可以，Session的作用是在服务端来保持状态，通过sessionid来进行确认身份，但sessionid一般是通过Cookie来进行传递的。如果Cooike被禁用了，可以通过在URL中传递sessionid。</p>
<h3 id="Servlet是线程安全的吗"><a href="#Servlet是线程安全的吗" class="headerlink" title="Servlet是线程安全的吗"></a>Servlet是线程安全的吗</h3><p>Servlet不是线程安全的，多线程的读写会导致数据不同步的问题</p>
<h3 id="路由器和交换机的区别？"><a href="#路由器和交换机的区别？" class="headerlink" title="路由器和交换机的区别？"></a>路由器和交换机的区别？</h3><p>路由器，属于网络层，识别IP地址并根据IP地址转发数据包，维护数据表并基于数据表进行最佳路径选择</p>
<p>交换机，属于数据链路层，识别MAC地址并根据MAC地址转发数据帧</p>
<h3 id="说一下ping的过程"><a href="#说一下ping的过程" class="headerlink" title="说一下ping的过程"></a>说一下ping的过程</h3><p>ping是ICMP(网际控制报文协议)中的一个重要应用，ICMP是网络层的协议。ping的作用是测试两个主机的连通性。</p>
<p>ping的工作过程：</p>
<ol>
<li>向目的主机发送多个ICMP回送请求报文</li>
<li>根据目的主机返回的回送报文的时间和成功响应的次数估算出数据包往返时间及丢包率。</li>
</ol>
<h3 id="了解ARP协议吗"><a href="#了解ARP协议吗" class="headerlink" title="了解ARP协议吗?"></a>了解ARP协议吗?</h3><p>ARP协议属于网络层的协议，主要作用是实现从IP地址转换为MAC地址。在每个主机或者路由器中都建有一个ARP缓存表，表中有IP地址及IP地址对应的MAC地址。先来看一下什么时IP地址和MAC地址。</p>
<ul>
<li><p>IP地址：IP地址是指互联网协议地址，IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个<strong>逻辑地址</strong>，以此来<strong>屏蔽物理地址的差异</strong>。</p>
</li>
<li><p>MAC地址：MAC地址又称<strong>物理地址</strong>，由网络设备制造商生产时<strong>写在硬件内部，不可更改</strong>，并且每个以太网设备的MAC地址都是唯一的。</p>
</li>
</ul>
<p>数据在传输过程中，会先从高层传到底层，然后在通信链路上传输。TCP报文是传输层的，它在网络层会被封装成IP数据报，在数据链路层被封装成MAC帧，然后在通信链路中传输。<strong>在网络层及以上使用的是IP地址，在数据据链路层使用的是MAC地址。</strong></p>
<p>MAC帧在传送时的源地址和目的地址使用的都是MAC地址，在通信链路上的主机或路由器也都是根据MAC帧首部的MAC地址接收MAC帧。并且在数据链路层是看不到IP地址的，只有当数据传到网络层时去掉MAC帧的首部和尾部时才能在IP数据报的首部中找到源IP地址和目的地址。</p>
<p>网络层实现的是主机之间的通信，而链路层实现的是链路之间的通信，在数据传输过程中，IP数据报的源地址(IP1)和目的地址(IP2)是一直不变的，而MAC地址(硬件地址)却一直随着链路的改变而改变。</p>
<p>ARP的工作流程（面试时问ARP协议主要说这个就可以了）：</p>
<ol>
<li>在局域网内，主机A要向主机B发送IP数据报时，首先会在主机A的ARP缓存表中查找是否有IP地址及其对应的MAC地址，如果有，则将MAC地址写入到MAC帧的首部，并通过局域网将该MAC帧发送到MAC地址所在的主机B。</li>
<li>如果主机A的ARP缓存表中没有主机B的IP地址及所对应的MAC地址，主机A会在局域网内广播发送一个ARP请求分组。局域网内的所有主机都会收到这个ARP请求分组。</li>
<li>主机B在看到主机A发送的ARP请求分组中有自己的IP地址，会像主机A以单播的方式发送一个带有自己MAC地址的响应分组。</li>
<li>主机A收到主机B的ARP响应分组后，会在ARP缓存表中写入主机B的IP地址及其IP地址对应的MAC地址。</li>
<li>如果主机A和主机B不在同一个局域网内，即使知道主机B的MAC地址也是不能直接通信的，必须通过路由器转发到主机B的局域网才可以通过主机B的MAC地址找到主机B。并且主机A和主机B已经可以通信的情况下，主机A的ARP缓存表中寸的并不是主机B的IP地址及主机B的MAC地址，而是主机B的IP地址及该通信链路上的下一跳路由器的MAC地址。这就是上图中的源IP地址和目的IP地址一直不变，而MAC地址却随着链路的不同而改变。</li>
<li>如果主机A和主机B不在同一个局域网，参考上图中的主机H1和主机H2，这时主机H1需要先广播找到路由器R1的MAC地址，再由R1广播找到路由器R2的MAC地址，最后R2广播找到主机H2的MAC地址，建立起通信链路。</li>
</ol>
<h3 id="有了IP地址，为什么还要用MAC地址？"><a href="#有了IP地址，为什么还要用MAC地址？" class="headerlink" title="有了IP地址，为什么还要用MAC地址？"></a>有了IP地址，为什么还要用MAC地址？</h3><p>简单来说，标识网络中的一台计算机，比较常用的就是IP地址和MAC地址，但计算机的IP地址可由用户自行更改，管理起来相对困难，而MAC地址不可更改，所以一般会把IP地址和MAC地址组合起来使用。具体是如何组合使用的在上面的ARP协议中已经讲的很清楚了。</p>
<p>那只用MAC地址不用IP地址可不可以呢？其实也是不行的，因为在最早就是MAC地址先出现的，并且当时并不用IP地址，只用MAC地址，后来随着网络中的设备越来越多，整个路由过程越来越复杂，便出现了子网的概念。对于目的地址在其他子网的数据包，路由只需要将数据包送到那个子网即可，这个过程就是上面说的ARP协议。</p>
<p>那为什么要用IP地址呢？是因为IP地址是和地域相关的，对于同一个子网上的设备，IP地址的前缀都是一样的，这样路由器通过IP地 址的前缀就知道设备在在哪个子网上了，而只用MAC地址的话，路由器则需要记住每个MAC地址在哪个子网，这需要路由器有极大的存储空间，是无法实现的。</p>
<p>IP地址可以比作为地址，MAC地址为收件人，在一次通信过程中，两者是缺一不可的。</p>
<h1 id="系统设计题"><a href="#系统设计题" class="headerlink" title="系统设计题"></a>系统设计题</h1><p>需要注意的是，在面试过程中是比较紧张的，但遇到这种系统设计题，一定先不要急着回答，一定要先需要设计系统的一些使用场景。</p>
<h2 id="系统设计步骤"><a href="#系统设计步骤" class="headerlink" title="系统设计步骤"></a>系统设计步骤</h2><p>常见的系统设计题有设计一个秒杀系统、红包雨、URL短网址等，完成一个系统设计题大概需要分为四步：</p>
<ul>
<li>第一步：像面试官不断提问，搞清楚系统的使用场景<ul>
<li>系统的功能是什么</li>
<li>系统的目标群体是什么</li>
<li>系统的用户量有多大</li>
<li>希望每秒钟处理多少请求？</li>
<li>希望处理多少数据？</li>
<li>希望的读写比率？</li>
</ul>
</li>
<li>第二步：创造一个高层级的设计<ul>
<li>画出主要的组件和连接</li>
</ul>
</li>
<li>第三步：设计核心组件<ul>
<li>对每一个核心组件进行具体地分析。</li>
</ul>
</li>
<li>第四步：对系统进行优化<ul>
<li>找到系统的瓶颈所在，对其进行优化，例如可以考虑水平扩展、数据库分片等等。</li>
</ul>
</li>
</ul>
<h2 id="系统的一些性能指标"><a href="#系统的一些性能指标" class="headerlink" title="系统的一些性能指标"></a>系统的一些性能指标</h2><ul>
<li><p>响应时间：响应时间指从发出请求开始到收到最后响应数据所需的时间，响应时间是系统最重要的性能指标其<br>  直观地反映了系统的“快慢”。</p>
</li>
<li><p>并发数：并发数指系统能够同时处理请求的数目，这个数字反映了系统的负载特性。</p>
</li>
<li><p>吞吐量：吞吐量指单位时间内系统处理的请求数量，体现系统的整体处理能力。</p>
<ul>
<li>QPS（Query Per Second）：服务器每秒可以执行的查询次数</li>
<li>TPS（Transaction Per Second）：服务器每秒处理的事务数</li>
<li>并发数&#x3D;QPS*平均响应时间</li>
</ul>
</li>
<li><p>经常听到的一些系统活跃度的名词</p>
<ul>
<li><p>PV（Page View）：页面点击量或者浏览量，用户每次对网站中的每个页面访问均被记录一个PV，多次访问则会累计。</p>
</li>
<li><p>UV（Unique visitor）：独立访客，统计一天内访问网站的用户数，一个用户多次访问网站算一个用户</p>
</li>
<li><p>IP（Internet Protocol）：指一天内访问某站点的IP总数，以用户的IP地址作为统计的指标，相同IP多次访问某站点算一次</p>
<p>  IP和UV的区别：在同一个IP地址下，两个不同的账号访问同一个站点，UV算两次，IP算一次</p>
</li>
<li><p>DAU（Daily Active User）：日活跃用户数量。</p>
</li>
<li><p>MAU(monthly active users)：月活跃用户人数。</p>
</li>
</ul>
</li>
<li><p>常用软件的QPS</p>
<ul>
<li>Nginx：一般Nginx的QPS是比较大的，单机的可达到30万</li>
<li>MySQL：对于读操作可达几百k，对于写操作更低，大概只有100k</li>
<li>Redis：大概在几万左右，像set命令甚至可达10万</li>
<li>Tomcat：单机 Tomcat 的QPS 在 2万左右。</li>
<li>Memcached：大概在几十万左右</li>
</ul>
<p>  通过了解这些软件的QPS可以更清楚地找出系统的瓶颈所在。</p>
</li>
</ul>
<h1 id="智力题"><a href="#智力题" class="headerlink" title="智力题"></a>智力题</h1><p>恰好问到看过的题也不要马上答出来，还是要假装思考一下，因为你脱口而出会让面试官发现你做过，给你换一道题的</p>
<h3 id="只有两个无刻度的水桶，一个可以装6L水，一个可以装5L水，如何在桶里装入3L的水"><a href="#只有两个无刻度的水桶，一个可以装6L水，一个可以装5L水，如何在桶里装入3L的水" class="headerlink" title="只有两个无刻度的水桶，一个可以装6L水，一个可以装5L水，如何在桶里装入3L的水"></a>只有两个无刻度的水桶，一个可以装6L水，一个可以装5L水，如何在桶里装入3L的水</h3><p>利用两个水桶的已知容量倒来倒去</p>
<p>先将5L的桶装满，将5L的桶的水倒入6L的桶中。这时5L的桶是空的，6L的桶中有5L的水；再将5L的桶装满，倒入6L的桶中。这时5L的桶有4L的水，6L的桶是满的；将6L的桶中的水倒掉，5L的桶的水倒入6L的桶中。这时5L的桶是空的，6L的桶中有4L的水；将5L的桶装满，倒入6L的桶中。这时5L的桶还有3L的水，6L的桶是满的。</p>
<h3 id="25匹马，5个赛道，每次只能同时有5匹马跑，最少比赛几次选出最快的前3名？"><a href="#25匹马，5个赛道，每次只能同时有5匹马跑，最少比赛几次选出最快的前3名？" class="headerlink" title="25匹马，5个赛道，每次只能同时有5匹马跑，最少比赛几次选出最快的前3名？"></a>25匹马，5个赛道，每次只能同时有5匹马跑，最少比赛几次选出最快的前3名？</h3><p>前五次：将25匹马放到5个赛道比赛，找出每个赛道的第一名。假设A1、B1、C1、D1、E1分别为每组的第一名。</p>
<p>第六次：把每个赛道第1名拉出来比一下，假设A1&gt;B1&gt;C1&gt;D1&gt;E1，现在确定A1是第一名。但因为只取前三，所有确定比C1慢的全部淘汰，因此D、E组、C2-C5全部淘汰。现在还剩二三名不确定，A组里，A2、A3有机会，  B组里，B1、B2有机会， C1有机会。刚好剩下5匹</p>
<p>第七次：A2、A3、B1、B2、C1跑一下，结束。<strong>所以找出前3名最少需要7次</strong></p>
<p>如果是找前5名呢？</p>
<p>前5次一样。</p>
<p>第6次比赛：找出第一名，比较A1、B1、C1、D1、E1。假设是A1最快</p>
<p>第7次比赛：找出第二名和第三名，比较A2、A3、B1、B2、C1，假设A2和A3最快。</p>
<p>第8次比赛：找出第四名和第五名，比较A4、A5、B1、B2、C1，前两名分别是第四和第五名。</p>
<p>所以最少需要8次可决出。但是如果第7次比赛不是上面分析的，则8次找不出前5名。</p>
<p>应该这样分析：</p>
<p>第7次比赛：将上次第一名所在组的下一号马再和剩余的4匹1号马比赛，第一名是跑的第二快的马，由于只有4个名额，所以跑的最慢的马和所在组剩余的马全部被淘汰。<br>第8次比赛：将上次第一名所在组的下一号马、上次第二名所在组的下一号马和剩余的3匹马比赛，第一名是跑的第三快的马，由于只有3个名额，所以跑的最慢的两匹马和所在组剩余的马全部被淘汰。</p>
<p>在剩下的比赛中分别淘汰慢的，将排名稍后的加进来比赛，最多跑到第10次就可以选出最快的5匹马。如果在某一次比赛中排名前几的是同一组的且和已经选出的马加一起大于等于5，就可以提前决出前5名。</p>
<p>所以8-10次就可以选出最快的5匹马。</p>
<h3 id="1000瓶药水里面只有1瓶是有毒的，毒发时间为24个小时，问需要多少只老鼠才能在24小时后试出那瓶有毒。"><a href="#1000瓶药水里面只有1瓶是有毒的，毒发时间为24个小时，问需要多少只老鼠才能在24小时后试出那瓶有毒。" class="headerlink" title="1000瓶药水里面只有1瓶是有毒的，毒发时间为24个小时，问需要多少只老鼠才能在24小时后试出那瓶有毒。"></a>1000瓶药水里面只有1瓶是有毒的，毒发时间为24个小时，问需要多少只老鼠才能在24小时后试出那瓶有毒。</h3><blockquote>
<p> 这个问题不太容易想到可以先记住答案，需要老鼠的数量为log2 1000</p>
</blockquote>
<p>为了简化问题，可以先假设有只有8瓶药水，其中有一瓶有毒，根据公式需要log2 8 &#x3D; 3 个老鼠</p>
<p>先将瓶子进行编号为0-7号，用位数表示老鼠，如下图，</p>
<p><img src="C:/Users/wanyu/AppData/Roaming/Typora/typora-user-images/image-20220429225437763.png" srcset="/img/loading.gif" lazyload alt="image-20220429225437763"></p>
<p>将4、5、6、7号药水混合到一起喂给老鼠1，将2，3，6，7号药水混合喂给老鼠2，将1、3、5、7药水混合喂给老鼠3，观察老鼠是否中毒。</p>
<p>中毒的老鼠标号为1，未中毒的老鼠标号为0，将三只老鼠标号组合到一起即为有毒药水的标号。例如，第老鼠1中毒，老鼠2未中毒，老鼠3中毒。那么三只老鼠的二进制表示为101，即5号药水有毒。因为老鼠1中毒，说明4、5、6、7号药水中含有毒的药水。老鼠2未中毒，说明2、3、6、7无毒。老鼠3中毒，说明1、3、5、7中有一瓶有毒。所以有毒的为5号药水，其实和直接将二进制转化为十进制的结果是一样的。</p>
<p>回到正题，如果有1000瓶药水，则需要10只老鼠，因为10位二进制足以表示0-999。</p>
<h3 id="家里有两个孩子，一个是女孩，另一个也是女孩的概率是多少？"><a href="#家里有两个孩子，一个是女孩，另一个也是女孩的概率是多少？" class="headerlink" title="家里有两个孩子，一个是女孩，另一个也是女孩的概率是多少？"></a>家里有两个孩子，一个是女孩，另一个也是女孩的概率是多少？</h3><p>这个问题更像是脑筋急转弯，看怎么断句，（一个是女孩）（一个是女孩，另一个也是女孩）</p>
<p>已知家里有两个孩子Ａ和Ｂ，其中一个是女孩，关键问题就在其中一个是女陔这句话上。如果你理解为这个是指定了一个孩子为女孩，例如Ａ为女孩，那么Ｂ也是女孩的概率显然为二分之一。</p>
<p>如果你理解为Ａ或Ｂ有一个孩子是女孩，问另一个孩子也是女陔的概率，这就是三分之一了。因为两个孩子的性别只有男男、男女、女男、女女四种组合，男男被排除了，剩下三种组合均符合题意，所以是三分之一。</p>
<p>其实，题目本身应该是第二种理解的意思，告诉你了有一个是女孩并未明确说哪个是。但很多人看到题目就会先入为主，先指定了一个孩子为女孩，那另一个孩子为女孩的概率肯定是二分之一了，这是不正确的。</p>
<h3 id="烧一根不均匀的绳，从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子，问如何用烧绳的方法来计时一个小时十五分钟呢"><a href="#烧一根不均匀的绳，从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子，问如何用烧绳的方法来计时一个小时十五分钟呢" class="headerlink" title="烧一根不均匀的绳，从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子，问如何用烧绳的方法来计时一个小时十五分钟呢?"></a>烧一根不均匀的绳，从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子，问如何用烧绳的方法来计时一个小时十五分钟呢?</h3><p>这个问题的关键就是要知道绳子可以从两头烧</p>
<p>将绳子１从一段开始烧，同时将绳子２从两端烧，绳子２在 半小时后烧完。</p>
<p>这时开始计时，将绳子１的另一端点燃，从计时开始绳子１烧完后是15分钟</p>
<p>点燃绳子3的一端，绳子3烧完需要一个小时，加上刚才的15分钟正好是1小时15分钟</p>
<h3 id="一共12个一样的小球，-其中只有一个重量与其它不一样-未知轻重-，给你一个天平，找出那个不同重量的球？"><a href="#一共12个一样的小球，-其中只有一个重量与其它不一样-未知轻重-，给你一个天平，找出那个不同重量的球？" class="headerlink" title="一共12个一样的小球， 其中只有一个重量与其它不一样(未知轻重)，给你一个天平，找出那个不同重量的球？"></a>一共12个一样的小球， 其中只有一个重量与其它不一样(未知轻重)，给你一个天平，找出那个不同重量的球？</h3><p>这个问题的思想是采用分治的思想。</p>
<p>将12个小球分为三组（因为分成两组不能找到重量不一样的球在哪组），为A组、B组、C组</p>
<p>将三组球分别两两称重，找到重量和另外两组不同的那一组（只要有两组可以使天平平衡，重量不一致的球必然在第三组）。假设坏的球在C组</p>
<p>将C组的球分成两组C1和C2，每组两个球，这时从A组里找到两个正常的球，分别和C1和C2去称，天平不能平衡说明重量不一致的球就在哪组。假设在C1</p>
<p>将C1组的2个球分别和A组里正常的球去称，天平不平衡时就能找到重量与其他不一致的球。</p>
<h3 id="有10瓶药，每瓶有10粒药，其中有一瓶是变质的。好药每颗重1克，变质的药每颗比好药重0-1克。问怎样用天秤称一次找出变质的那瓶药？"><a href="#有10瓶药，每瓶有10粒药，其中有一瓶是变质的。好药每颗重1克，变质的药每颗比好药重0-1克。问怎样用天秤称一次找出变质的那瓶药？" class="headerlink" title="有10瓶药，每瓶有10粒药，其中有一瓶是变质的。好药每颗重1克，变质的药每颗比好药重0.1克。问怎样用天秤称一次找出变质的那瓶药？"></a>有10瓶药，每瓶有10粒药，其中有一瓶是变质的。好药每颗重1克，变质的药每颗比好药重0.1克。问怎样用天秤称一次找出变质的那瓶药？</h3><blockquote>
<p>那瓶变质的药是都变质了</p>
</blockquote>
<ol>
<li>将这10瓶药标好号1-10。</li>
<li>然后按照瓶子的标号取药，1号药瓶取1粒药，2号药瓶取2粒药，3号药瓶取3例药，以此类推，取<br>完10瓶药一起放到天平上去称。如果没有变质的药，重量应该是55克，这时多出几克，几号药瓶就<br>是变质的。例如55.3克，那么变质的药就是3号药瓶的。</li>
</ol>
<h3 id="你有两个罐子，50个红色弹球，50个蓝色弹球，如何将这100个球放入到两个罐子，随机选出一个罐子取出的球为红球的概率最大？"><a href="#你有两个罐子，50个红色弹球，50个蓝色弹球，如何将这100个球放入到两个罐子，随机选出一个罐子取出的球为红球的概率最大？" class="headerlink" title="你有两个罐子，50个红色弹球，50个蓝色弹球，如何将这100个球放入到两个罐子，随机选出一个罐子取出的球为红球的概率最大？"></a>你有两个罐子，50个红色弹球，50个蓝色弹球，如何将这100个球放入到两个罐子，随机选出一个罐子取出的球为红球的概率最大？</h3><p>将一个红球放到一个罐子中，另一个罐子放49个红球和50个蓝球</p>
<p>这样随便选出一个罐子取出红球的概率是1&#x2F;2 * 1 + 1&#x2F;2 * 49 &#x2F;（49+50），接近0.75。</p>
<h3 id="你现在有一根金条，有一个工人为你工作了七天，他们的工资是金条的七分之一，并且需要当天结清，你只能对金条切割两次，请问需要怎么做"><a href="#你现在有一根金条，有一个工人为你工作了七天，他们的工资是金条的七分之一，并且需要当天结清，你只能对金条切割两次，请问需要怎么做" class="headerlink" title="你现在有一根金条，有一个工人为你工作了七天，他们的工资是金条的七分之一，并且需要当天结清，你只能对金条切割两次，请问需要怎么做"></a>你现在有一根金条，有一个工人为你工作了七天，他们的工资是金条的七分之一，并且需要当天结清，你只能对金条切割两次，请问需要怎么做</h3><blockquote>
<p>这个问题和平时用的纸币金额是一个道理，将一根金条切割两次可以得到三根金条，这三根金条必须可以组合出1-7之间的任意金额。</p>
</blockquote>
<p>将金条分两次切成长度为1、2、4的金条</p>
<ol>
<li>第一天，将长度为1的金条支付给工人。</li>
<li>第二天，将长度为2的金条支付给工人，工人将长度为1的金条还给你。</li>
<li>第三天，将长度为1的金条支付给工人</li>
<li>第四天，将长度为4的金条支付给工人，工人将长度为1，2的金条还给你</li>
<li>第五条，将长度为1的金条支付给工人</li>
<li>第六条，将长度为2的金条支付给工人，工人将长度为1的金条还给你</li>
<li>第七天，将长度为1的金条支付给工人</li>
</ol>
<h3 id="有三个酒杯，其中两个大酒杯每个可以装8两酒，一个可以装3两酒。现在两个大酒杯都装满了酒，只用这三个杯子怎么把酒平均的分给4个人喝？"><a href="#有三个酒杯，其中两个大酒杯每个可以装8两酒，一个可以装3两酒。现在两个大酒杯都装满了酒，只用这三个杯子怎么把酒平均的分给4个人喝？" class="headerlink" title="有三个酒杯，其中两个大酒杯每个可以装8两酒，一个可以装3两酒。现在两个大酒杯都装满了酒，只用这三个杯子怎么把酒平均的分给4个人喝？"></a>有三个酒杯，其中两个大酒杯每个可以装8两酒，一个可以装3两酒。现在两个大酒杯都装满了酒，只用这三个杯子怎么把酒平均的分给4个人喝？</h3><p>用三个数字表示三个杯子，最开始为880，即两个8两的杯子是满的，一个3两的杯子是空的。</p>
<ol>
<li>880—&gt;853，这时A喝掉第三个杯子的三两酒变成850</li>
<li>850—&gt;823，这时B喝掉第二个杯子的二两变酒成803</li>
<li>803—&gt;830—&gt;533—&gt;560—&gt;263—&gt;281，A喝掉第三个杯子的一两酒变成280（A喝完了4两）</li>
<li>280—&gt;253—&gt;550—&gt;523—&gt;820—&gt;703—&gt;730—&gt;433—&gt;460—&gt;163—&gt;181，这时C和D各喝一<br>两酒变成080</li>
<li>080—&gt;053—&gt;350—&gt;323，这时B喝点第二个杯子的二两酒，C和D各喝三两酒，到此所有人都喝<br>了四两酒</li>
</ol>
<h3 id="在地球什么地方能够，往南走1公里，然后往东走1公里，再往北走1公里能回到原点？"><a href="#在地球什么地方能够，往南走1公里，然后往东走1公里，再往北走1公里能回到原点？" class="headerlink" title="在地球什么地方能够，往南走1公里，然后往东走1公里，再往北走1公里能回到原点？"></a>在地球什么地方能够，往南走1公里，然后往东走1公里，再往北走1公里能回到原点？</h3><p>答案是：北极点或者距离南极点1+1&#x2F;(2 · <em><strong>pi</strong></em> · k)的点</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E5%9C%B0%E7%90%83%E5%8D%97%E4%B8%9C%E5%8C%97%E4%B8%80%E5%85%AC%E9%87%8C.png" srcset="/img/loading.gif" lazyload alt="image-20220502220334927"></p>
<p>有一个周长为一公里的圆，圆心在北极点和南极点的连线上，只要站在这个圆上的任意一个点，向东或向西走一公里都会回到原点。如下图绿色的圆。所以这个点是距离南极1+1&#x2F;(2·<em><strong>pi</strong></em>)的点，假设这个点为A点，先向南走一公里到达B点，向东走一公里还是B点（相当于绕了一圈），再向北走一公里回到A点。这时是假设这个圆的圆心就是南极点，圆的半径就是1&#x2F;(2·<em><strong>pi</strong></em>)，因为地球非常大，这个圆的周长又只有一公里，这么假设是可以的。</p>
<p>这时又有人说了，这个B点所在的圆还可以小一点，即一公里是这个圆的周长的整数倍，这样也是可以的，向东走一公里相当于绕了很多圈还是回到了原点。所以答案是距离南极点1+1&#x2F;(2<em>pi</em>k)的点，都是可以的，k为正整数。</p>
<p>还有一个答案就是北极点，很好理解，在北极点先向南走一公里，在向东走一公里，这时距离北极点还是一公里，在向被走一公里就回到北极点了。</p>
<h3 id="50名运动员按顺序排成一排，教练下令：“单数运动员出列！”剩下的运动员重新排列编号，教练又下令：“单数运动员出列！”如此下去，最后只剩下一个人，他是最开始的几号运动员？"><a href="#50名运动员按顺序排成一排，教练下令：“单数运动员出列！”剩下的运动员重新排列编号，教练又下令：“单数运动员出列！”如此下去，最后只剩下一个人，他是最开始的几号运动员？" class="headerlink" title="50名运动员按顺序排成一排，教练下令：“单数运动员出列！”剩下的运动员重新排列编号，教练又下令：“单数运动员出列！”如此下去，最后只剩下一个人，他是最开始的几号运动员？"></a>50名运动员按顺序排成一排，教练下令：“单数运动员出列！”剩下的运动员重新排列编号，教练又下令：“单数运动员出列！”如此下去，最后只剩下一个人，他是最开始的几号运动员？</h3><blockquote>
<p> 这个问题不难，很容易就可以想到，先正着推，在逆着推就可以了</p>
</blockquote>
<p>正向思维：</p>
<ol>
<li>运动员编号为1-50，单号出列后为2，4，6，……，50</li>
<li>运动员重新编号为1-25，单号出列后为2，4，6，……,24</li>
<li>运动员重新编号为1-12，单号出列后为2，4，6，……，12</li>
<li>运动员重新编号为1-6，单号出列后为2，4，6</li>
<li>运动员重新编号为1-3，单号出列后为2</li>
</ol>
<p>反向思维：</p>
<ol>
<li>第五轮运动员的编号为2</li>
<li>第五轮编号为2的运动员在第四轮编号为4</li>
<li>第四轮编号为4的运动员在第三轮中编号为8</li>
<li>第三轮编号为8的运动员在第二轮中编号为16</li>
<li>第二轮编号为16的运动员在第一轮中编号为32</li>
</ol>
<p>所以，剩下的最后一名运动员在开始的编号为32</p>
<h3 id="连续正整数之和为1000-的共有几组"><a href="#连续正整数之和为1000-的共有几组" class="headerlink" title="连续正整数之和为1000 的共有几组?"></a>连续正整数之和为1000 的共有几组?</h3><p>假设开始的数为m，从m加到n等于1000，根据等差求和公式得，(m+n)(n-m+1) &#x3D; 2000，即2000为一个奇数和一个偶数的乘积，并且2000 &#x3D; 2·2·2·2·5·5·5；</p>
<p>所以取值情况为：奇数可取1，5，25，125四种情况</p>
<h3 id="49个人中至少几个人生日是同一月？"><a href="#49个人中至少几个人生日是同一月？" class="headerlink" title="49个人中至少几个人生日是同一月？"></a>49个人中至少几个人生日是同一月？</h3><p>一年有12个月，那么49个人最后至少有49&#x2F;12+1&#x3D;5个人出生月份相同</p>
<h3 id="一枚正反概率不一样的硬币，如何当一枚正常的硬币来用（正反概率相同）？"><a href="#一枚正反概率不一样的硬币，如何当一枚正常的硬币来用（正反概率相同）？" class="headerlink" title="一枚正反概率不一样的硬币，如何当一枚正常的硬币来用（正反概率相同）？"></a>一枚正反概率不一样的硬币，如何当一枚正常的硬币来用（正反概率相同）？</h3><p>连续抛两次即可，第一次为正面、第二次为反面和第一次为反面、第二次为正面得概率相同。</p>
<h3 id="1楼到n楼的每层电梯门口都放着一颗钻石，钻石大小不一。你乘坐电梯从1楼到n楼，每层楼电梯门都会打开一次，只能拿一次钻石，问怎样才能拿到最大的一颗？"><a href="#1楼到n楼的每层电梯门口都放着一颗钻石，钻石大小不一。你乘坐电梯从1楼到n楼，每层楼电梯门都会打开一次，只能拿一次钻石，问怎样才能拿到最大的一颗？" class="headerlink" title="1楼到n楼的每层电梯门口都放着一颗钻石，钻石大小不一。你乘坐电梯从1楼到n楼，每层楼电梯门都会打开一次，只能拿一次钻石，问怎样才能拿到最大的一颗？"></a>1楼到n楼的每层电梯门口都放着一颗钻石，钻石大小不一。你乘坐电梯从1楼到n楼，每层楼电梯门都会打开一次，只能拿一次钻石，问怎样才能拿到最大的一颗？</h3><p>原型是秘书问题，推导公式就不看了，结论是大概观察前<strong>百分之1&#x2F;e（约等于37%）</strong>的楼层的钻石，记住最大的，后面遇到比这个大的就直接拿了。<strong>不能保证可以拿到最大的一颗，但整体上是一个最优解。</strong></p>
<p>所以如果n是10楼，先观察前3楼的钻石，记住最大的，从第四楼开始遇到比这个最大的还要大就拿着</p>
<h3 id="要聘请一名秘书，有-n-个应聘者。每次面试一人，面试后就要及时决定是否聘他，如果当时决定不聘他，他便不会回来。面试后总能清楚了解应聘者的合适程度，并能和之前的每个人做比较。问什么样的策略，才使最佳人选被选中的概率最大。"><a href="#要聘请一名秘书，有-n-个应聘者。每次面试一人，面试后就要及时决定是否聘他，如果当时决定不聘他，他便不会回来。面试后总能清楚了解应聘者的合适程度，并能和之前的每个人做比较。问什么样的策略，才使最佳人选被选中的概率最大。" class="headerlink" title="要聘请一名秘书，有 n 个应聘者。每次面试一人，面试后就要及时决定是否聘他，如果当时决定不聘他，他便不会回来。面试后总能清楚了解应聘者的合适程度，并能和之前的每个人做比较。问什么样的策略，才使最佳人选被选中的概率最大。"></a>要聘请一名秘书，有 n 个应聘者。每次面试一人，面试后就要及时决定是否聘他，如果当时决定不聘他，他便不会回来。面试后总能清楚了解应聘者的合适程度，并能和之前的每个人做比较。问什么样的策略，才使最佳人选被选中的概率最大。</h3><h3 id="一副牌除去大小王还有52张，其中10张牌是正面朝上的，要求一个盲人将牌分成两堆，并且每堆牌正面朝上的数量相同，可以任意翻动每张牌，应该怎么分"><a href="#一副牌除去大小王还有52张，其中10张牌是正面朝上的，要求一个盲人将牌分成两堆，并且每堆牌正面朝上的数量相同，可以任意翻动每张牌，应该怎么分" class="headerlink" title="一副牌除去大小王还有52张，其中10张牌是正面朝上的，要求一个盲人将牌分成两堆，并且每堆牌正面朝上的数量相同，可以任意翻动每张牌，应该怎么分"></a>一副牌除去大小王还有52张，其中10张牌是正面朝上的，要求一个盲人将牌分成两堆，并且每堆牌正面朝上的数量相同，可以任意翻动每张牌，应该怎么分</h3><p>分成两堆，一堆10张，一堆42张，并且将第一堆的10张牌全部反转，这时两堆牌中正面朝上的数量是相同的。</p>
<p>比如10张里有7张正的，42张里就有3张正的，把10张牌里全部反转，就只有3张正的</p>
<h3 id="两人玩游戏，在脑门上贴数字（正整数-gt-x3D-1），只看见对方的，看不见自己的，而且两人的数字相差1，以下是两人的对话：A：我不知道，B：我也不知道，A：我知道了，B：我也知道了，问A头上的字是多少，B头上的字是多少？"><a href="#两人玩游戏，在脑门上贴数字（正整数-gt-x3D-1），只看见对方的，看不见自己的，而且两人的数字相差1，以下是两人的对话：A：我不知道，B：我也不知道，A：我知道了，B：我也知道了，问A头上的字是多少，B头上的字是多少？" class="headerlink" title="两人玩游戏，在脑门上贴数字（正整数&gt;&#x3D;1），只看见对方的，看不见自己的，而且两人的数字相差1，以下是两人的对话：A：我不知道，B：我也不知道，A：我知道了，B：我也知道了，问A头上的字是多少，B头上的字是多少？"></a>两人玩游戏，在脑门上贴数字（正整数&gt;&#x3D;1），只看见对方的，看不见自己的，而且两人的数字相差1，以下是两人的对话：A：我不知道，B：我也不知道，A：我知道了，B：我也知道了，问A头上的字是多少，B头上的字是多少？</h3><h3 id="在一个飞机场有N架飞机，每架飞机只有一个油箱，每箱油可以使飞机绕地球飞半圈。如果使一架飞机绕地球一圈，至少需要出动多少飞机？（要求所有飞机均能安全返回到机场，只能通过飞机给飞机这样加油方式，不能降落到机场加油）"><a href="#在一个飞机场有N架飞机，每架飞机只有一个油箱，每箱油可以使飞机绕地球飞半圈。如果使一架飞机绕地球一圈，至少需要出动多少飞机？（要求所有飞机均能安全返回到机场，只能通过飞机给飞机这样加油方式，不能降落到机场加油）" class="headerlink" title="在一个飞机场有N架飞机，每架飞机只有一个油箱，每箱油可以使飞机绕地球飞半圈。如果使一架飞机绕地球一圈，至少需要出动多少飞机？（要求所有飞机均能安全返回到机场，只能通过飞机给飞机这样加油方式，不能降落到机场加油）"></a>在一个飞机场有N架飞机，每架飞机只有一个油箱，每箱油可以使飞机绕地球飞半圈。如果使一架飞机绕地球一圈，至少需要出动多少飞机？（要求所有飞机均能安全返回到机场，只能通过飞机给飞机这样加油方式，不能降落到机场加油）</h3><h3 id="晚上有四个人需要过桥，但是只有一个手电筒，并且桥一次最多过两个人，每个人通过桥所需的时间也不同，A、B、C、D过桥所需的时间分别为1、2、5、10分钟。请问如何过桥所需时间最短？"><a href="#晚上有四个人需要过桥，但是只有一个手电筒，并且桥一次最多过两个人，每个人通过桥所需的时间也不同，A、B、C、D过桥所需的时间分别为1、2、5、10分钟。请问如何过桥所需时间最短？" class="headerlink" title="晚上有四个人需要过桥，但是只有一个手电筒，并且桥一次最多过两个人，每个人通过桥所需的时间也不同，A、B、C、D过桥所需的时间分别为1、2、5、10分钟。请问如何过桥所需时间最短？"></a>晚上有四个人需要过桥，但是只有一个手电筒，并且桥一次最多过两个人，每个人通过桥所需的时间也不同，A、B、C、D过桥所需的时间分别为1、2、5、10分钟。请问如何过桥所需时间最短？</h3><blockquote>
<p>这个问题最开始想到的可能是让速度最快的人分别送其他三个人过去，因为他回来所需的时间最短。其实不是这样的，最佳的解决方案是将两个耗时最多的人一起过桥，而不是分开过桥，并且不需要返回。</p>
</blockquote>
<p>第一次过桥：A和B一起过，需要2分钟，A再回来，所需1分钟，一共所需3分钟</p>
<p>第二次过桥： C和D一起过桥，需要10分钟，B再回来，所需2分钟，一共需12分钟</p>
<p>第三次过桥：A和B一起过桥，所需2分钟</p>
<p>一共所需17分钟。</p>
<h3 id="一个人8块钱买了一只鸡，9块钱卖了，10块钱又买回来了，11块钱又卖了，请问他挣了多少钱？"><a href="#一个人8块钱买了一只鸡，9块钱卖了，10块钱又买回来了，11块钱又卖了，请问他挣了多少钱？" class="headerlink" title="一个人8块钱买了一只鸡，9块钱卖了，10块钱又买回来了，11块钱又卖了，请问他挣了多少钱？"></a>一个人8块钱买了一只鸡，9块钱卖了，10块钱又买回来了，11块钱又卖了，请问他挣了多少钱？</h3><p>2块钱</p>
<h3 id="一共有N颗石子，每次最多取M颗最少取1颗，A，B轮流取（A先），谁最后拿完石子谁就获胜，请问最后谁会获胜？"><a href="#一共有N颗石子，每次最多取M颗最少取1颗，A，B轮流取（A先），谁最后拿完石子谁就获胜，请问最后谁会获胜？" class="headerlink" title="一共有N颗石子，每次最多取M颗最少取1颗，A，B轮流取（A先），谁最后拿完石子谁就获胜，请问最后谁会获胜？"></a>一共有N颗石子，每次最多取M颗最少取1颗，A，B轮流取（A先），谁最后拿完石子谁就获胜，请问最后谁会获胜？</h3><p>这种没有具体的数字就要分类讨论下了，注意<strong>每次拿多少可以是不固定的</strong></p>
<p>假设M&gt;&#x3D;N，那么A一次就把石子拿完了，A胜</p>
<p>假设M&lt;N，如果N可以被（M+1）整除时，A失败，如果N不可以被（M+1）整除时，A胜</p>
<p>具体分析：</p>
<p>如果N可以被（M+1）整除时，无论A怎么拿，B都会保持拿完后石子的数量为（M+1）的倍数，到最后只能M+1个，A无论怎么拿，B都会在下一次把石子拿完。</p>
<p>如果N不可以被（M+1）整除时，A可以保证自己拿完剩下的石子数量一定是（M+1）的倍数，同理，A胜。</p>
<h3 id="海盗分金币问题：5个海盗抢到了100枚金币，他们的分配方案，先抽签决定自己的发言顺序。1号提出的方案，由5个人进行投票表决，如果半数人以上同意（不包括半数），就按他的方案分配，否则扔进海里喂鱼。如果1号被喂鱼，由2号发言，提出的方案由4个人进行投票表决，规则同上。如果2号被喂鱼，以此类推。1号海盗提出什么样的方法才能使得自己分到最多的金币"><a href="#海盗分金币问题：5个海盗抢到了100枚金币，他们的分配方案，先抽签决定自己的发言顺序。1号提出的方案，由5个人进行投票表决，如果半数人以上同意（不包括半数），就按他的方案分配，否则扔进海里喂鱼。如果1号被喂鱼，由2号发言，提出的方案由4个人进行投票表决，规则同上。如果2号被喂鱼，以此类推。1号海盗提出什么样的方法才能使得自己分到最多的金币" class="headerlink" title="海盗分金币问题：5个海盗抢到了100枚金币，他们的分配方案，先抽签决定自己的发言顺序。1号提出的方案，由5个人进行投票表决，如果半数人以上同意（不包括半数），就按他的方案分配，否则扔进海里喂鱼。如果1号被喂鱼，由2号发言，提出的方案由4个人进行投票表决，规则同上。如果2号被喂鱼，以此类推。1号海盗提出什么样的方法才能使得自己分到最多的金币"></a>海盗分金币问题：5个海盗抢到了100枚金币，他们的分配方案，先抽签决定自己的发言顺序。1号提出的方案，由5个人进行投票表决，如果半数人以上同意（不包括半数），就按他的方案分配，否则扔进海里喂鱼。如果1号被喂鱼，由2号发言，提出的方案由4个人进行投票表决，规则同上。如果2号被喂鱼，以此类推。1号海盗提出什么样的方法才能使得自己分到最多的金币</h3><p>这个题的思路主要是逆推法</p>
<p>从最后面开始，如果前三个人都被喂鱼了，只剩4号和5号，那么无论4号说什么，5号都会反对，4号一定会被喂鱼，5号独吞100枚金币。所以3号无论说什么，4号只能同意</p>
<p>3号知道这些，会提出“100，0，0”这种分配方案，4号海盗为了活命只能赞同，加上自己一票即可使得投票通过半数。</p>
<p>2号知道这些，会提出“98，0，1，1”的分配方案，以此拉拢4号和5号。</p>
<p>1号知道这些，他还需要两个人支持他，2号是不可能的，3号只需1枚金币，4号或者5号其中一人即可，所以1号的分配方案是“97，0，1，2，0”或者“97，0，1，0，2”</p>
<h3 id="高层扔鸡蛋问题：有一个100层的高楼，给你两个鸡蛋，需要测试出在哪层楼扔鸡蛋，鸡蛋不会碎。鸡蛋如果没有碎可以扔无数次。最少需要扔多少次？"><a href="#高层扔鸡蛋问题：有一个100层的高楼，给你两个鸡蛋，需要测试出在哪层楼扔鸡蛋，鸡蛋不会碎。鸡蛋如果没有碎可以扔无数次。最少需要扔多少次？" class="headerlink" title="高层扔鸡蛋问题：有一个100层的高楼，给你两个鸡蛋，需要测试出在哪层楼扔鸡蛋，鸡蛋不会碎。鸡蛋如果没有碎可以扔无数次。最少需要扔多少次？"></a>高层扔鸡蛋问题：有一个100层的高楼，给你两个鸡蛋，需要测试出在哪层楼扔鸡蛋，鸡蛋不会碎。鸡蛋如果没有碎可以扔无数次。最少需要扔多少次？</h3><blockquote>
<p>这是一个非常经典的动态规划问题，手撕代码时也很常见</p>
</blockquote>
<p>如果是只有1个鸡蛋，这个问题就很简单了，为保证一定找到这个楼层，只能从第一层开始试。</p>
<p>题目中是两个鸡蛋，正常就是会想到二分法之类，先在50层扔一个，没碎，捡回来在75层扔，碎了，第二个鸡蛋只能从第1层开始试了。第一个鸡蛋用来缩短范围，第二个鸡蛋用来遍历范围。</p>
<p>假设需要x次才能找到临界的楼层，也就是说第一个鸡蛋从第x层扔出（因为需要考虑最差情况，万一第一个鸡蛋碎了，为保证x次能找到，第一个鸡蛋需要从x层扔出。因为如果鸡蛋恰好在第x层碎了，在第x-1层没碎，第一个鸡蛋在x层以上的楼层扔的话，第二个鸡蛋需要遍历x次，一共需要x+1次）</p>
<p>如果第一个鸡蛋碎了，第二个鸡蛋遍历1至x-1层，则需要x次找到。</p>
<p>如果第一个鸡蛋没碎，则第一个鸡蛋的任务是需要继续缩小范围，还是为了保持这个x次能找到临界楼层的条件，现在只剩x-1次了，下一次只能在x-1层扔第一个鸡蛋，以此类推，x+(x-1)+(x-2)+……+1&gt;&#x3D;100，x&#x3D;14</p>
<p>也就是说最少需要扔14次。</p>
<p>这个问题还有一些变种问题，比如2个鸡蛋，n层楼；k个鸡蛋，n层楼（力扣887题，大家感兴趣可以看看）</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>八股文</div>
      <div>http://example.com/2022/06/17/面试/八股文/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>万宇</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年6月17日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>






  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>






<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
