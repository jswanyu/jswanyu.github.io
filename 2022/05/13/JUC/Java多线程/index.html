

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="万宇">
  <meta name="keywords" content="">
  
    <meta name="description" content="参考资料： 黑马 JUC视频 《实战：Java高并发程序设计》 目录黑马的课程将整个课程分为四部分：主要内容、模式、应用、原理，我在做笔记时选择将另外三个部分都穿插在主要内容里，不单独写额外的模式笔记和应用笔记了 模式：  终止模式之两阶段终止-利用isInterrupted 同步模式之保护性暂停 异步模式之生产者消费者 同步模式之顺序控制  应用：  应用之提高效率  应用之同步-join实现">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC：Java多线程">
<meta property="og:url" content="http://jswanyu.github.io/2022/05/13/JUC/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="Wynn&#39;s blog">
<meta property="og:description" content="参考资料： 黑马 JUC视频 《实战：Java高并发程序设计》 目录黑马的课程将整个课程分为四部分：主要内容、模式、应用、原理，我在做笔记时选择将另外三个部分都穿插在主要内容里，不单独写额外的模式笔记和应用笔记了 模式：  终止模式之两阶段终止-利用isInterrupted 同步模式之保护性暂停 异步模式之生产者消费者 同步模式之顺序控制  应用：  应用之提高效率  应用之同步-join实现">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/icon/JUC%E5%9B%BE%E6%A0%87.jpeg">
<meta property="article:published_time" content="2022-05-13T12:32:56.000Z">
<meta property="article:modified_time" content="2022-08-01T12:30:09.499Z">
<meta property="article:author" content="万宇">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/icon/JUC%E5%9B%BE%E6%A0%87.jpeg">
  
  
  
  <title>JUC：Java多线程 - Wynn&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"jswanyu.github.io","root":"/","version":"1.9.1","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":false},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wynn&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                时间线
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/icon/JUC%E5%9B%BE%E6%A0%87.jpeg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="JUC：Java多线程"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-05-13 20:32" pubdate>
          2022年5月13日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          107k 字
        
      </span>
    

    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JUC：Java多线程</h1>
            
            <div class="markdown-body">
              
              <p>参考资料：</p>
<p>黑马 JUC视频</p>
<p>《实战：Java高并发程序设计》</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>黑马的课程将整个课程分为四部分：主要内容、模式、应用、原理，我在做笔记时选择将另外三个部分都穿插在主要内容里，不单独写额外的模式笔记和应用笔记了</p>
<p>模式：</p>
<ul>
<li><a href="###%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2-%E5%88%A9%E7%94%A8isInterrupted">终止模式之两阶段终止-利用isInterrupted</a></li>
<li><a href="##%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C">同步模式之保护性暂停</a></li>
<li><a href="##%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85">异步模式之生产者消费者</a></li>
<li><a href="##%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6">同步模式之顺序控制</a></li>
</ul>
<p>应用：</p>
<ul>
<li><p><a href="##%E5%BA%94%E7%94%A8%E4%B9%8B%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87">应用之提高效率</a></p>
</li>
<li><p><a href="###%E5%BA%94%E7%94%A8%E4%B9%8B%E5%90%8C%E6%AD%A5-join%E5%AE%9E%E7%8E%B0">应用之同步-join实现</a></p>
</li>
</ul>
<h1 id="一、进程"><a href="#一、进程" class="headerlink" title="一、进程"></a>一、进程</h1><blockquote>
<p>进程: 资源分配的最小单位</p>
<ul>
<li>进程是线程的容器, 一个进程中包含多个线程, 真正执行任务的是线程</li>
</ul>
<p>线程: 资源调度的最小单位</p>
</blockquote>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul>
<li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。<strong>进程就是用来加载指令、管理内存、管理 IO 的</strong>。</li>
<li><strong>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程</strong>。</li>
<li><strong>进程就可以视为程序的一个实例</strong>。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul>
<li>一个进程之内可以分为<strong>一到多个线程</strong>。</li>
<li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。</li>
<li>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器</li>
</ul>
<h2 id="进程与线程对比"><a href="#进程与线程对比" class="headerlink" title="进程与线程对比"></a>进程与线程对比</h2><ul>
<li><strong>进程基本上相互独立</strong>的，而<strong>线程存在于进程内，是进程的一个子集</strong></li>
<li><strong>进程拥有共享的资源，如内存空间等，供其内部的线程共享</strong></li>
<li>进程间通信较为复杂 <ul>
<li>同一台计算机的进程通信称为 IPC（Inter-process communication）</li>
<li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li>
</ul>
</li>
<li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量 </li>
<li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li>
</ul>
<p><font color=red>进程和线程的切换</font></p>
<h2 id="并发-concurrent"><a href="#并发-concurrent" class="headerlink" title="并发(concurrent)"></a>并发(concurrent)</h2><p><strong>是一个CPU核在不同的时间轮流执行不同线程中的指令</strong>。</p>
<p>虽然叫并发，但实际还是串行执行, CPU的时间片切换非常快，给人一种同时运行的感觉。微观串行, 宏观并行<br>（操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于cpu 在线程间（时间片很短）的切换非常快，给人的感觉是同时运行的 。）</p>
<h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p><strong>多核CPU的每个核在同一时刻处理不同的线程。</strong></p>
<p>并行中也可能存在并发，比如说2核cpu, 同时执行4个线程. 理论上同时可以有2个线程是并行执行的. 此时还是存在并发， 因为2个cpu也会同时切换不同的线程执行任务罢了</p>
<h2 id="并发与并行对比"><a href="#并发与并行对比" class="headerlink" title="并发与并行对比"></a>并发与并行对比</h2><p>引用 Rob Pike 的一段描述：</p>
<ul>
<li>并发（concurrent）是同一时间<strong>应对</strong>（dealing with）多件事情的能力</li>
<li>并行（parallel）是同一时间<strong>动手做</strong>（doing）多件事情的能力</li>
</ul>
<h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>以调用方角度来讲，如果</p>
<ul>
<li>需要等待结果返回，才能继续运行就是<strong>同步</strong></li>
<li>不需要等待结果返回，就能继续运行就是<strong>异步</strong></li>
</ul>
<p>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如 果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停…</p>
<p>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</p>
<p>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞</p>
<p>tomcat 的工作线程 ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</p>
<ul>
<li><p>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活</p>
</li>
<li><p>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的</p>
<ul>
<li><p>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分（参考后文的<font color=red>阿姆达尔定律</font>）</p>
</li>
<li><p>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</p>
</li>
</ul>
</li>
<li><p>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化</p>
</li>
</ul>
<h2 id="应用之提高效率"><a href="#应用之提高效率" class="headerlink" title="应用之提高效率"></a>应用之提高效率</h2><p>计算 1 花费 10 ms，计算 2 花费 11 ms，计算 3 花费 9 ms，汇总需要 1 ms</p>
<p>如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 &#x3D; 31ms</p>
<p>但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms 最后加上汇总时间只会花费 12ms</p>
<ol>
<li><p>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用cpu ，不至于一个线程总占用 cpu，别的线程没法干活</p>
</li>
<li><p>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的</p>
</li>
</ol>
<p>  有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分（参考后文的【阿姆达尔定律】）</p>
<p>  也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</p>
<ol start="3">
<li>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化</li>
</ol>
<h1 id="二、线程"><a href="#二、线程" class="headerlink" title="二、线程"></a>二、线程</h1><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%BB%91%E9%A9%AC%E8%A7%86%E9%A2%91%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93.png" srcset="/img/loading.gif" lazyload alt="image-20220120001554388"></p>
<p>提示：</p>
<p>后面的实例代码都加上@Slf4j，用log.debug打印信息，而不是用System.out，log能够带上当前线程和时间，更好观察</p>
<h2 id="1-创建线程"><a href="#1-创建线程" class="headerlink" title="1. 创建线程"></a>1. 创建线程</h2><p>Java中创建一个线程（非主线程）有如下几种方法</p>
<h3 id="方法一：继承Thread类创建线程"><a href="#方法一：继承Thread类创建线程" class="headerlink" title="方法一：继承Thread类创建线程"></a>方法一：继承Thread类创建线程</h3><ol>
<li>创建线程对象</li>
<li>启动线程</li>
</ol>
<p>Thread是lang包下的多线程类，自定义类继承Thread 类创建线程，重写run方法，主函数里调用实例的start方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadDemo</span> <span class="hljs-variable">threadDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadDemo</span>();<br>        threadDemo.start();<br>        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-number">17</span>:<span class="hljs-number">52</span>:<span class="hljs-number">22.974</span> [main] <span class="hljs-symbol">DEBUG</span> <span class="hljs-symbol">Code01_CreateThread</span>.<span class="hljs-symbol">ThreadDemo</span> - running...<br><span class="hljs-number">17</span>:<span class="hljs-number">52</span>:<span class="hljs-number">22.974</span> [<span class="hljs-symbol">Thread</span><span class="hljs-number">-0</span>] <span class="hljs-symbol">DEBUG</span> <span class="hljs-symbol">Code01_CreateThread</span>.<span class="hljs-symbol">ThreadDemo</span> - running...<br></code></pre></td></tr></table></figure>

<p>或者用匿名内部类的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CreateThread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;Thread-0&quot;</span>) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>            &#125;<br>        &#125;;<br>        myThread.start();<br>        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>使用继承方式的好处是:</p>
<ul>
<li>在run()方法内获取当前线程直接使用this就可以了，无须使用Thread.currentThread（）方法；</li>
</ul>
<p>不好的地方是:</p>
<ul>
<li>Java不支持多继承，如果继承了Thread类，那么就不能再继承其他类。</li>
<li>任务与代码没有分离，当多个线程执行一样的任务时需要多份任务代码</li>
</ul>
<h3 id="方法二：实现-Runnable-接口创建线程（推荐）"><a href="#方法二：实现-Runnable-接口创建线程（推荐）" class="headerlink" title="方法二：实现 Runnable 接口创建线程（推荐）"></a>方法二：实现 Runnable 接口创建线程（推荐）</h3><p>把【线程】和【任务】（要执行的代码）分开，首先创建实现Runnable 接口的类RunnableDemo ，重写run() 方法；创建类RunnableDemo 的实例对象runnableDemo ，以runnableDemo 作为参数创建Thread 对象，调用Thread 对象的start() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">RunnableDemo</span> <span class="hljs-variable">runnableDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableDemo</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnableDemo);<br>        thread.start();<br>        log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">17:54:34.180 [main] <span class="hljs-built_in">DEBUG</span> Code01_CreateThread.RunnableTest - running<br>17:54:34.180 [Thread-0] <span class="hljs-built_in">DEBUG</span> Code01_CreateThread.RunnableDemo - running<span class="hljs-built_in">..</span>.<br></code></pre></td></tr></table></figure>

<p>同样可以使用匿名内部类的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>            log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable, <span class="hljs-string">&quot;Thread-0&quot;</span>);<br>    thread.start();<br>    log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>JDK8之后，对于匿名内部类，可以使用 lambda 精简代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//任务对象</span><br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; log.debug(<span class="hljs-string">&quot;running...&quot;</span>); <span class="hljs-comment">//任务有多行语句也可以加上大括号</span><br>    <span class="hljs-comment">//线程对象</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br>    <span class="hljs-comment">//启动线程</span><br>    thread.start();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>也可以进一步简写，将任务对象也用lambda 形式，写到线程的第一个参数里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; log.debug(<span class="hljs-string">&quot;running...&quot;</span>), <span class="hljs-string">&quot;Thread-0&quot;</span>);<br>    thread.start();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果后续用不到myThread2，直接启动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; log.debug(<span class="hljs-string">&quot;running...&quot;</span>), <span class="hljs-string">&quot;Thread-0&quot;</span>).start();<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>原理之 Thread 与 Runnable 的关系</strong></p>
<p>分析 Thread 的源码，理清它与 Runnable 的关系：</p>
<p>Thread的构造方法第一个参数就是Runnable 类型的参数，传到最后就是调用Runnable 的run方法</p>
<p><strong>小结</strong></p>
<ul>
<li>方法1 是把线程和任务合并在了一起</li>
<li>方法2 是把线程和任务分开了</li>
<li>用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li>
</ul>
<h3 id="方法三：使用Callable-和FutureTask-创建线程"><a href="#方法三：使用Callable-和FutureTask-创建线程" class="headerlink" title="方法三：使用Callable 和FutureTask 创建线程"></a>方法三：使用Callable 和FutureTask 创建线程</h3><p>方法二的任务对象Runnable是没有返回值的，想要带返回值，就需要用新的对象，FutureTask，使用FutureTask可以用泛型指定线程的返回值类型。</p>
<p>此方法需要搭配Callable来使用，<strong>Callable接口</strong>代表一段可以调用并返回结果的代码，Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果。</p>
<ol>
<li>创建Callable接口的实现类CallableDemo ，重写call() 方法。</li>
<li>以类CallableDemo 的实例化对象作为参数创建FutureTask 对象。</li>
<li>以FutureTask 对象作为参数，创建Thread 对象。</li>
<li>调用Thread 对象的start() 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallableDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallableTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-type">CallableDemo</span> <span class="hljs-variable">callableDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CallableDemo</span>();<br>        FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;Integer&gt;(callableDemo);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>        thread.start();<br>        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>        log.debug(<span class="hljs-string">&quot;result: &quot;</span> + futureTask.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">18:01:48.211 [Thread-0] <span class="hljs-built_in">DEBUG</span> Code01_CreateThread.CallableDemo - running<span class="hljs-built_in">..</span>.<br>18:01:48.211 [main] <span class="hljs-built_in">DEBUG</span> Code01_CreateThread.CallableTest - running<span class="hljs-built_in">..</span>.<br>18:01:48.215 [main] <span class="hljs-built_in">DEBUG</span> Code01_CreateThread.CallableTest - result: 0<br></code></pre></td></tr></table></figure>

<p>之前的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CreateThread3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-comment">// 创建任务对象</span><br>        FutureTask&lt;Integer&gt; futuretask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;);<br>        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br><br>        <span class="hljs-comment">// 创建线程对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futuretask, <span class="hljs-string">&quot;myThread&quot;</span>);<br>        thread.start();<br><br>        <span class="hljs-comment">// 主线程阻塞，同步等待 task 执行完毕的结果</span><br>        log.debug(<span class="hljs-string">&quot;阻塞了&#123;&#125;s&quot;</span>,futuretask.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">18:04:07.643 [main] <span class="hljs-built_in">DEBUG</span> Code01_CreateThread.CreateThread3 - running<span class="hljs-built_in">..</span>.<br>18:04:07.645 [myThread] <span class="hljs-built_in">DEBUG</span> Code01_CreateThread.CreateThread3 - running<span class="hljs-built_in">..</span>.<br>18:04:09.660 [main] <span class="hljs-built_in">DEBUG</span> Code01_CreateThread.CreateThread3 - 阻塞了2s<br></code></pre></td></tr></table></figure>





<h2 id="2-线程运行原理"><a href="#2-线程运行原理" class="headerlink" title="2. 线程运行原理"></a>2. 线程运行原理</h2><p>多个Java线程同时运行是交替运行的，谁先谁后是由操作系统的任务调度器控制</p>
<p>查看进程线程的方法：暂时省略</p>
<h3 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h3><p>每个线程启动后，虚拟机就会为其分配一块栈内存。</p>
<ul>
<li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法（视频03.011图解栈帧讲的挺好）</li>
<li>线程拥有独立的栈内存，彼此之间不受影响</li>
</ul>
<h3 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h3><p>所谓的上下文切换其实也就是<strong>线程切换</strong>，即cpu 不再执行当前的线程，转而执行另一个线程的代码。一般会是因为以下几种情况：</p>
<ul>
<li>分给线程的 cpu 时间片用完</li>
<li>垃圾回收 </li>
<li>有更高优先级的线程需要运行</li>
<li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li>
</ul>
<p>当线程切换发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是<strong>程序计数器</strong>（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p>
<ul>
<li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li>
<li><strong>线程切换频繁发生会影响性能</strong></li>
</ul>
<h2 id="3-线程常见方法"><a href="#3-线程常见方法" class="headerlink" title="3. 线程常见方法"></a>3. 线程常见方法</h2><h3 id="3-1-start与run"><a href="#3-1-start与run" class="headerlink" title="3.1 start与run"></a>3.1 start与run</h3><p>新线程启动时<strong>必须使用start方法</strong>，如果直接使用<strong>run方法，会是主线程在运行run方法，并没有启动新的线程</strong>。使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Start_and_Run</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; log.debug(<span class="hljs-string">&quot;running...&quot;</span>));<br>        thread.run();<br>        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">21:23:15.425 [main] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - running<span class="hljs-built_in">..</span>.<br>21:23:15.427 [main] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - running<span class="hljs-built_in">..</span>.<br></code></pre></td></tr></table></figure>

<p><strong>start方法只能调用一次，多次调用会抛出异常</strong></p>
<h3 id="3-2-sleep"><a href="#3-2-sleep" class="headerlink" title="3.2 sleep"></a>3.2 sleep</h3><p>sleep (使线程阻塞)</p>
<p>调用 sleep()方法会让当前线程从 <strong>Running 进入 Timed Waiting 状态（阻塞）</strong>，可通过state()方法查看线程状态。处于阻塞状态的线程，CPU不会给其分配时间片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SleepTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;finish...&quot;</span>);<br>        &#125;);<br>        thread.start();<br>        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">21:22:44.896 [Thread-0] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - running<span class="hljs-built_in">..</span>.<br>21:22:44.896 [main] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - running<span class="hljs-built_in">..</span>.<br>21:22:46.904 [Thread-0] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - finish<span class="hljs-built_in">..</span>.<br></code></pre></td></tr></table></figure>

<p>建议用 <strong>TimeUnit 的 sleep</strong> 代替 Thread 的 sleep 来获得更好的可读性 。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//休眠一秒</span><br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//休眠一分钟</span><br>TimeUnit.MINUTES.sleep(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>



<p>其它线程可以使用 <strong>interrupt</strong> 方法打断正在睡眠的线程，<code>myThread.interrupt()</code>，这时 sleep 方法会抛出 InterruptedException</p>
<p>睡眠结束后的线程未必会立刻得到执行，CPU可能正在执行其他线程，需要等待任务调度器分配时间片给它</p>
<h3 id="3-3-yield"><a href="#3-3-yield" class="headerlink" title="3.3 yield"></a>3.3 yield</h3><p><strong>yield （让出当前线程）</strong></p>
<p>yield()方法 <strong>提示</strong>调度器当前线程愿意放弃当前的CPU资源，调度器如果接受这个提示会执行其他线程，当前线程从 <strong>Running 进入  Runnable（就绪）状态</strong>。但如果CPU太闲，也会不接受这个提示，依然执行当前线程。</p>
<h3 id="3-4-join"><a href="#3-4-join" class="headerlink" title="3.4 join"></a>3.4 join</h3><p>用于等待某个线程结束。如在主线程中调用t1.join()，则是主线程等待t1线程结束       <font color=red>应用之同步</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>		Sleeper.sleep(<span class="hljs-number">2</span>);<br>        log.debug(<span class="hljs-string">&quot;finish&quot;</span>);<br>    &#125;);<br>    thread.start();<br>    thread.join();<br>    log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">21:21:36.512 [Thread-0] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - running<span class="hljs-built_in">..</span>.<br>21:21:38.517 [Thread-0] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - finish<br>21:21:38.517 [main] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - running<span class="hljs-built_in">..</span>.<br></code></pre></td></tr></table></figure>

<p>join()还有带参数的形式，表示最多等待的时间。如果一个线程被阻塞了2s，join的参数是1s，那么最多等待1s；如果一个线程被阻塞了1s，join的参数是2s，那么只用等待1s</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>        Sleeper.sleep(<span class="hljs-number">2</span>);<br>        log.debug(<span class="hljs-string">&quot;finish&quot;</span>);<br>    &#125;);<br>    thread.start();<br>    thread.join(<span class="hljs-number">1000</span>);<br>    log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">21:21:16.629 [Thread-0] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - running<span class="hljs-built_in">..</span>.<br>21:21:17.641 [main] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - running<span class="hljs-built_in">..</span>.<br>21:21:18.638 [Thread-0] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - finish<br></code></pre></td></tr></table></figure>



<h3 id="应用之同步-join实现"><a href="#应用之同步-join实现" class="headerlink" title="应用之同步-join实现"></a>应用之同步-join实现</h3><p>同步指需要等待结果，这里可以使用join实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    log.debug(<span class="hljs-string">&quot;开始&quot;</span>);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;开始&quot;</span>);<br>        Sleeper.sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;结束&quot;</span>);<br>        result = <span class="hljs-number">10</span>;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>    t1.start();<br>    t1.join();<br>    log.debug(<span class="hljs-string">&quot;结果为:&#123;&#125;&quot;</span>, result);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">19:03:26.049 [main] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 开始<br>19:03:26.052 [t1] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 开始<br>19:03:27.062 [t1] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 结束<br>19:03:27.062 [main] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 结果为:10<br></code></pre></td></tr></table></figure>



<h3 id="3-5-interrupt"><a href="#3-5-interrupt" class="headerlink" title="3.5 interrupt"></a>3.5 interrupt</h3><p>interrupt() 用于打断线程，每个线程会有一个标志位<code>isInterrupted()</code>，用于记录打断的状态，默认是false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用于查看打断标记，返回值被boolean类型</span><br>t1.isInterrupted();<br><span class="hljs-comment">//更推荐使用当前线程的方法</span><br>Thread.currentThread().isInterrupted();<br><span class="hljs-comment">//无法手动设置标志位状态！！！</span><br>Thread.currentThread().isInterrupted()=<span class="hljs-literal">true</span>; <span class="hljs-comment">//会报错</span><br></code></pre></td></tr></table></figure>

<p>（1）如果是打断正处于sleep，wait，join 的线程（这几个方法都会让线程进入阻塞状态），会清空打断状态，打断状态为false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>        Sleeper.sleep(<span class="hljs-number">2</span>);<br>        log.debug(<span class="hljs-string">&quot;finish...&quot;</span>);<br>        log.debug(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span>, Thread.currentThread().isInterrupted());<br>    &#125;);<br>    thread.start();<br>    log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>    <span class="hljs-comment">// 主线程阻塞1s后打断thread的阻塞状态，让其退出阻塞状态</span><br>    Sleeper.sleep(<span class="hljs-number">1</span>);<br>    thread.interrupt();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">21:18:14.138 [Thread-0] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - running<span class="hljs-built_in">..</span>.<br>21:18:14.138 [main] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - running<span class="hljs-built_in">..</span>.<br>java.lang.InterruptedException: sleep interrupted<br>	at java.base/java.lang.Thread.sleep(Native Method)<br>	<span class="hljs-built_in">..</span>.<br>21:18:15.151 [Thread-0] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - finish<span class="hljs-built_in">..</span>.<br>21:18:15.151 [Thread-0] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> -  打断状态: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<p>还需要指出，线程有另一个方法是<code>interrupted()</code> ，和<code>isInterrupted()</code>类似，但他不会清空打断标记</p>
<p>（2）打断正常运行的线程，不会清空打断标记，打断标记为true，<strong>但打断的线程不会停止</strong>，会继续执行。如果要让线程在被打断后停下来，需要<strong>使用打断标记来判断，break掉循环</strong>，这是一种更优雅的处理方式。<font color=red>模式之两阶段终止</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isInterrupted</span> <span class="hljs-operator">=</span> Thread.currentThread().isInterrupted();<br>            <span class="hljs-keyword">if</span>(isInterrupted)&#123;<br>                log.debug(<span class="hljs-string">&quot;被打断了，退出循环&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;);<br><br>    thread.start();<br>    Sleeper.sleep(<span class="hljs-number">1</span>);<br>    log.debug(<span class="hljs-string">&quot;main interrupt thread ! &quot;</span>);<br>    thread.interrupt();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">21:17:32.352 [Thread-0] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - running<span class="hljs-built_in">..</span>.<br><span class="hljs-built_in">..</span>.<br>21:17:32.352 [Thread-0] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - running<span class="hljs-built_in">..</span>.<br>21:17:32.352 [main] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - main interrupt thread ! <br>21:17:32.352 [Thread-0] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - running<span class="hljs-built_in">..</span>.<br>21:17:32.352 [Thread-0] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 被打断了，退出循环<br></code></pre></td></tr></table></figure>



<h3 id="终止模式之两阶段终止-利用isInterrupted"><a href="#终止模式之两阶段终止-利用isInterrupted" class="headerlink" title="终止模式之两阶段终止-利用isInterrupted"></a>终止模式之两阶段终止-利用isInterrupted</h3><p>在一个线程 T1 中如何“优雅”终止线程 T2？这里的【优雅】指的是给 T2 一个料理后事的机会。</p>
<p>错误思路：</p>
<ul>
<li>使用线程对象的 stop() 方法停止线程，stop 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁</li>
<li>使用 System.exit(int) 方法停止线程，目的仅是停止一个线程，但这种做法会让整个程序都停止</li>
</ul>
<p>正确思路：</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java/JUC/%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F.png" srcset="/img/loading.gif" lazyload alt="image-20220521190804284"></p>
<p>利用interrupt方法和isInterrupted()标记可以实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j(topic = &quot;info&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoPhaseTermination</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">TPTInteruption</span> <span class="hljs-variable">tpt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TPTInteruption</span>();<br>        tpt.start();<br>        Thread.sleep(<span class="hljs-number">5000</span>);<br>        log.debug(<span class="hljs-string">&quot;主线程打断监控线程&quot;</span>);<br>        tpt.stop();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;info&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TPTInteruption</span>&#123;<br>    <span class="hljs-keyword">private</span> Thread monitor;<br>    <span class="hljs-comment">// 启动监控线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 创建一个监控线程</span><br>        monitor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted())&#123;<br>                    <span class="hljs-comment">// 如果是正常打断，则料理后事然后结束</span><br>                    log.debug(<span class="hljs-string">&quot;料理后事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 每隔2s监控一次</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                    log.debug(<span class="hljs-string">&quot;执行监控&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    log.debug(<span class="hljs-string">&quot;打断标记：&#123;&#125;&quot;</span>,Thread.currentThread().isInterrupted());<br>                    e.printStackTrace();<br>                    <span class="hljs-comment">// 睡眠时捕获到打断异常，重新设置打断标记，让其为真，好退出循环，</span><br>                    <span class="hljs-comment">// 不重新设置的话，isInterrupted仍然为false，不会退出循环</span><br>                    Thread.currentThread().interrupt();<br>                    log.debug(<span class="hljs-string">&quot;打断标记：&#123;&#125;&quot;</span>,monitor.isInterrupted());<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;监控线程&quot;</span>);<br><br>        monitor.start();<br>    &#125;<br><br>    <span class="hljs-comment">// 停止线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span>&#123;<br>        monitor.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">19:11:26.714 [监控线程] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 执行监控<br>19:11:28.727 [监控线程] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 执行监控<br>19:11:29.710 [main] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 主线程打断监控线程<br>19:11:29.711 [监控线程] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 打断标记：<span class="hljs-literal">false</span><br>19:11:29.716 [监控线程] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 打断标记：<span class="hljs-literal">true</span><br>19:11:29.716 [监控线程] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 料理后事<br>java.lang.InterruptedException: sleep interrupted<br>	at java.base/java.lang.Thread.sleep(Native Method)<br>	<span class="hljs-built_in">..</span>.<br></code></pre></td></tr></table></figure>



<h3 id="3-6-setPriority"><a href="#3-6-setPriority" class="headerlink" title="3.6 setPriority"></a>3.6 setPriority</h3><ul>
<li>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</li>
<li>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">thread1.setPriority(Thread.MAX_PRIORITY); <span class="hljs-comment">//设置为优先级最高</span><br></code></pre></td></tr></table></figure>

<p>yield和设置优先级均只是一个提示，真正的运行还是得看任务调度器</p>
<h3 id="3-7-setDaemon"><a href="#3-7-setDaemon" class="headerlink" title="3.7 setDaemon"></a>3.7 setDaemon</h3><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守<br>护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在线程开启前将线程设置为守护线程, 默认为false</span><br>monitor.setDaemon(<span class="hljs-literal">true</span>);<br>monitor.start();<br></code></pre></td></tr></table></figure>

<p>常见的守护线程：</p>
<ul>
<li><p>垃圾回收器线程就是一种守护线程</p>
</li>
<li><p>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</p>
</li>
</ul>
<h3 id="3-8-Thread-currentThread"><a href="#3-8-Thread-currentThread" class="headerlink" title="3.8 Thread.currentThread()"></a>3.8 Thread.currentThread()</h3><p>获取当前线程相关信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">Thread.currentThread().getName()<br>Thread.currentThread().isInterrupted() <br>......<br></code></pre></td></tr></table></figure>



<h3 id="3-9-不推荐-x2F-过时"><a href="#3-9-不推荐-x2F-过时" class="headerlink" title="3.9 不推荐&#x2F;过时"></a>3.9 不推荐&#x2F;过时</h3><p>还有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁</p>
<p>stop() –  停止线程运行</p>
<p>suspend() –  挂起（暂停）线程运行</p>
<p>resume() –  恢复线程运行</p>
<h2 id="4-线程状态"><a href="#4-线程状态" class="headerlink" title="4. 线程状态"></a>4. 线程状态</h2><h3 id="五种状态"><a href="#五种状态" class="headerlink" title="五种状态"></a>五种状态</h3><p>这是从 操作系统 层面来描述的</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" srcset="/img/loading.gif" lazyload alt="image-20220112213855310"></p>
<ul>
<li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联（例如线程调用了start方法）</li>
<li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li>
<li>【运行状态】指获取了 CPU 时间片运行中的状态<ul>
<li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li>
</ul>
</li>
<li>【阻塞状态】<ul>
<li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】</li>
<li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li>
<li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li>
</ul>
</li>
<li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li>
</ul>
<h3 id="六种状态"><a href="#六种状态" class="headerlink" title="六种状态"></a>六种状态</h3><p>这是从 Java API 层面来描述的，根据 Thread.State 枚举，分为六种状态</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%812.png" srcset="/img/loading.gif" lazyload alt="image-20220112215155531"></p>
<ul>
<li><strong>NEW</strong> 线程刚被创建，但是还没有调用 start() 方法</li>
<li><strong>RUNNABLE</strong> 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了操作系统层面的 【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为 是可运行）</li>
<li><strong>BLOCKED ， WAITING ， TIMED_WAITING</strong> 都是 <strong>Java API 层面</strong>对【阻塞状态】的细分，如sleep就位TIMED_WAITING， join为WAITING状态。后面会在状态转换一节详述。</li>
<li><strong>TERMINATED</strong> 当线程代码运行结束</li>
</ul>
<h2 id="5-查看线程"><a href="#5-查看线程" class="headerlink" title="5. 查看线程"></a>5. 查看线程</h2><p>windows</p>
<ul>
<li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li>
<li>tasklist 查看进程</li>
<li>taskkill 杀死进程</li>
</ul>
<p>linux</p>
<ul>
<li>ps -fe 查看所有进程</li>
<li>ps -fT -p <PID> 查看某个进程（PID）的所有线程</li>
<li>kill 杀死进程</li>
<li>top 按大写 H 切换是否显示线程</li>
<li>top -H -p <PID> 查看某个进程（PID）的所有线程</li>
</ul>
<p>Java</p>
<ul>
<li>jps 命令查看所有 Java 进程</li>
<li>jstack <PID> 查看某个 Java 进程（PID）的所有线程状态</li>
<li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li>
</ul>
<h1 id="三、互斥和同步"><a href="#三、互斥和同步" class="headerlink" title="三、互斥和同步"></a>三、互斥和同步</h1><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%BB%91%E9%A9%AC%E8%A7%86%E9%A2%91%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93.png" srcset="/img/loading.gif" lazyload alt="image-20220120001451671"></p>
<h2 id="1-共享带来的问题"><a href="#1-共享带来的问题" class="headerlink" title="1. 共享带来的问题"></a>1. 共享带来的问题</h2><h3 id="1-1-临界区-Critical-Section"><a href="#1-1-临界区-Critical-Section" class="headerlink" title="1.1 临界区 Critical Section"></a>1.1 临界区 Critical Section</h3><ul>
<li>一个程序运行多个线程本身是没有问题的</li>
<li>问题出在多个线程访问共享资源<ul>
<li>多个线程读共享资源其实也没有问题</li>
<li>在多个线程对共享资源<strong>读写操作时发生指令交错</strong>，就会出现问题</li>
</ul>
</li>
<li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为<strong>临界区</strong></li>
</ul>
<p>例如，下面代码中的临界区，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br> <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> <br><span class="hljs-comment">// 临界区 </span><br>&#123;   <br>    counter++; <br>&#125;<br> <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> <br><span class="hljs-comment">// 临界区 </span><br>&#123; <br>    counter--; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>用更详细的代码来演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j(topic = &quot;info&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> counter=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                counter++;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                counter--;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        log.debug(<span class="hljs-string">&quot;counter:&#123;&#125;&quot;</span>,counter);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">11:26:38.895 [main] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - counter:2013<br></code></pre></td></tr></table></figure>

<p>其底层字节码分析原理见视频04.003</p>
<h3 id="1-2-竞态条件-Race-Condition"><a href="#1-2-竞态条件-Race-Condition" class="headerlink" title="1.2 竞态条件 Race Condition"></a>1.2 竞态条件 Race Condition</h3><p>多个线程在<strong>临界区</strong>内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p>
<h3 id="1-3-解决方案"><a href="#1-3-解决方案" class="headerlink" title="1.3 解决方案"></a>1.3 解决方案</h3><p>为了避免临界区的竞态条件发生，有多种方法可以解决。</p>
<ul>
<li>阻塞式的解决方案：synchronized，Lock</li>
<li>非阻塞式的解决方案：原子变量</li>
</ul>
<p>注意：虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：</p>
<ul>
<li>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</li>
<li>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</li>
</ul>
<h2 id="2-synchronized-解决方案"><a href="#2-synchronized-解决方案" class="headerlink" title="2. synchronized 解决方案"></a>2. synchronized 解决方案</h2><p>synchronized，英文翻译为同步的，是俗称的<strong>【对象锁】</strong>，它采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会**阻塞住(blocked)**。锁住之后CPU就不会分时间片给它，所以哪怕正在执行的线程时间片到了，也不会其他线程对对象进行操作，而是在自己下一次被分到时间片后继续执行临界区代码，执行完了之后，其会释放锁，唤醒其他阻塞的线程，进行后续操作。</p>
<p>synchronized 实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换所打断。</p>
<h3 id="2-1-synchronized-加在对象上"><a href="#2-1-synchronized-加在对象上" class="headerlink" title="2.1 synchronized 加在对象上"></a>2.1 synchronized 加在对象上</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) &#123;<br>	<span class="hljs-comment">//临界区</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在以后给对象加锁的时候，尽量将该对象<strong>用final关键字</strong>修饰，保证锁住的是同一个对象。防止引用变了之后，锁住的是不同对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;info&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest1</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> counter=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                <span class="hljs-keyword">synchronized</span> (room)&#123;<br>                    counter++;<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                <span class="hljs-keyword">synchronized</span> (room)&#123;<br>                    counter--;<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        log.debug(<span class="hljs-string">&quot;counter:&#123;&#125;&quot;</span>,counter);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">11:38:08.893 [main] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - counter:0<br></code></pre></td></tr></table></figure>

<p>synchronized(对象) 中的对象，可以想象为一个房间（room），有唯一入口（门）房间只能一次进入一人进行计算，线程 t1，t2 想象成两个人。当线程 t1 执行到 synchronized(room) 时就好比 t1 进入了这个房间，并锁住了门拿走了钥匙，在门内执行count++ 代码，这时候如果 t2 也运行到了 synchronized(room) 时，它发现门被锁住了，只能在门外等待，发生了上下文切换，<strong>阻塞住了</strong>。<font color=red>这中间即使 t1 的 cpu 时间片不幸用完，被踢出了门外（不要错误理解为锁住了对象就能一直执行下去），这时门还是锁住的，t1 仍拿着钥匙，t2 线程还在阻塞状态进不来，只有下次轮到 t1 自己再次获得时间片时才能开门进入</font>。当 t1 执行完 synchronized{} 块内的代码，这时候才会从 obj 房间出来并解开门上的锁，唤醒 t2 线程把钥匙给他。t2 线程这时才可以进入 obj 房间，锁住了门拿上钥匙，执行它的 count– 代码</p>
<p>synchronized 实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切<br>换所打断。</p>
<blockquote>
<ul>
<li><p>如果把 synchronized(obj) 放在 for 循环的外面，如何理解？– 原子性</p>
<ul>
<li>放在里面是对++或者–这样四行JVM指令进行保护原子性，放在for循环外面就是对大概5000*4行JVM指令进行保护原子性。也可以得到正确结果，但没有必要</li>
</ul>
</li>
<li><p>如果 t1 synchronized(obj1) 而 t2 synchronized(obj2) 会怎样运作？– 锁对象</p>
<ul>
<li>仍然会发生竞态条件，锁住的不是同一个对象</li>
</ul>
</li>
<li><p>如果 t1 synchronized(obj) 而 t2 没有加会怎么样？如何理解？– 锁对象</p>
<ul>
<li>t2没有synchronized的话，t2想获取这个对象锁时就<strong>不会被阻塞住</strong>，就会被分到时间片，进而执行程序，仍然会发生竞态条件</li>
</ul>
</li>
</ul>
</blockquote>
<p>上面是面向过程的思想，可以改进为如下面向对象的思想：把需要保护的共享变量放入一个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Room</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Room</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                room.increment();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5000</span>; j++) &#123;<br>                room.decrement();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        log.debug(<span class="hljs-string">&quot;counter:&#123;&#125;&quot;</span>,room.get());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            value++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            value--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">11:58:19.537 [main] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - counter:0<br></code></pre></td></tr></table></figure>



<h3 id="2-2-synchronized-加在方法上"><a href="#2-2-synchronized-加在方法上" class="headerlink" title="2.2 synchronized 加在方法上"></a>2.2 synchronized 加在方法上</h3><ul>
<li>加在成员方法上</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>	<span class="hljs-comment">//在方法上加上synchronized关键字</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>	<br>	&#125;<br>	<span class="hljs-comment">//等价于给对象加锁</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>		<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 上面的例子</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Room1</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span>&#123;<br>        value++;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> &#123;<br>        value--;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>加在静态方法上</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>	<span class="hljs-comment">//在静态方法上加上synchronized关键字</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>	<br>	&#125;<br>	<span class="hljs-comment">//等价于给类对象加锁</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">synchronized</span>(Demo.class) &#123;<br>		<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 上面的例子</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Room2</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span>&#123;<br>        value++;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> &#123;<br>        value--;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>不在方法上加<code>synchronized</code>就相当于不加锁</p>
<h3 id="2-3-几种加锁的例子"><a href="#2-3-几种加锁的例子" class="headerlink" title="2.3 几种加锁的例子"></a>2.3 几种加锁的例子</h3><p>常见的有“八锁”，可以网上搜。举其中几个特殊的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Number</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123; n1.b(); &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>方法a是静态方法加了synchronized，相当于是给Number这个类对象加了锁，而方法b是给实例对象（this对象）加的锁，加锁的不是同一个对象，因此不会发生<strong>互斥</strong>，因此打印结果是“2“ ，1s后 ”1”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Number</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123; n1.b(); &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>都是给静态方法加锁，都是给Number这个类对象加了锁，内存中只有一个Number类对象，所以是互斥的，打印结果为“2“ 1s后” 1”，或者1s后 “12”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Number</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>();<br>    <span class="hljs-type">Number</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123; n2.b(); &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>都是给静态方法加锁，虽然调用的是两个实例对象，但其实就是在调用类对象的静态方法，锁的还是类对象，所以发生互斥，打印结果同上</p>
<h2 id="3-变量线程安全分析"><a href="#3-变量线程安全分析" class="headerlink" title="3. 变量线程安全分析"></a>3. 变量线程安全分析</h2><h3 id="3-1-成员变量和静态变量"><a href="#3-1-成员变量和静态变量" class="headerlink" title="3.1 成员变量和静态变量"></a>3.1 成员变量和静态变量</h3><ul>
<li>如果它们没有共享，则线程安全</li>
<li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况<ul>
<li>如果只有读操作，则线程安全</li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li>
</ul>
</li>
</ul>
<h3 id="3-2-局部变量"><a href="#3-2-局部变量" class="headerlink" title="3.2 局部变量"></a>3.2 局部变量</h3><p><strong>局部变量是线程安全的</strong>，例如下面这段代码中，若有多个线程调用 test1() 方法时，局部变量 i 会在每个线程的栈帧内存中被创建多份，因此不存在共享</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    i++;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8.png" srcset="/img/loading.gif" lazyload alt="image-20220116122219919"></p>
<h3 id="3-3-局部变量引用"><a href="#3-3-局部变量引用" class="headerlink" title="3.3 局部变量引用"></a>3.3 局部变量引用</h3><p>但局部变量引用的对象则未必 （<strong>要看该对象是否被共享且被执行了读写操作</strong>）</p>
<p>如果调用的对象被共享，且执行了读写操作，则<strong>线程不安全</strong></p>
<p>下面是局部变量引用了成员变量的例子：其中一种情况是，如果线程2 还未 add，线程1 remove 就会报错，无论哪个线程中的 method2 引用的都是同一个对象中的 list 成员变量，method3 与 method2 分析相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadUnsafe</span> &#123;<br>    ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <span class="hljs-comment">// list是成员变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>        <span class="hljs-comment">// &#123; 临界区, 会产生竞态条件</span><br>            method2();<br>            method3();<br>        <span class="hljs-comment">// &#125; 临界区</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//注意此处方法定义为private</span><br>        list.add(<span class="hljs-string">&quot;666&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//注意此处方法定义为private</span><br>        list.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">ThreadUnsafe</span> <span class="hljs-variable">threadUnsafe</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadUnsafe</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            threadUnsafe.method1(<span class="hljs-number">200</span>);<br>        &#125;,<span class="hljs-string">&quot;Thread&quot;</span>+i).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sas">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;Thread0&quot;</span> java.lang.ArrayIndexOutOfBoundsException: <span class="hljs-keyword">Index</span> -1 <span class="hljs-keyword">out</span> of bounds for <span class="hljs-keyword">length</span> 10<br>	...<br></code></pre></td></tr></table></figure>

<p>出现的错误就是线程1还没往集合添加元素呢，另一个线程就要删除元素了</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90.png" srcset="/img/loading.gif" lazyload alt="image-20220116123108856"></p>
<p>碰到上面这种<strong>共享的成员变量</strong>情况，可以改成线程内<strong>私有的局部变量</strong>，则会在堆中创建对应的对象，不会存在线程安全问题</p>
<p>将成员变量 list 修改为局部变量，那么就不会有上述问题了。list 是局部变量，每个线程调用时会创建其不同实例，没有共享。而 method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象，method3 的参数分析与 method2 相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafe</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <span class="hljs-comment">//改为局部变量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            method2(list);<br>            method3(list);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;   <span class="hljs-comment">//局部变量传进来</span><br>        list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;   <span class="hljs-comment">//注意此处方法定义为private</span><br>        list.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ThreadSafe</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadSafe</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            test.method1(<span class="hljs-number">200</span>);<br>        &#125;, <span class="hljs-string">&quot;Thread&quot;</span> + i).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E5%88%86%E6%9E%901.png" srcset="/img/loading.gif" lazyload alt="image-20220116123735323"></p>
<p>但并不是说只要是成员变量就一定是线程不安全的，还是要严格看<strong>该对象是否被共享且被执行了读写操作</strong>，如果某个成员变量引用的类里没有可更改的属性（又称为无状态的），那么也可能是线程安全的</p>
<h3 id="3-4-方法修饰符保护引用暴露"><a href="#3-4-方法修饰符保护引用暴露" class="headerlink" title="3.4 方法修饰符保护引用暴露"></a>3.4 方法修饰符保护引用暴露</h3><p>上面的分析将局部变量引用改为局部变量，即可解决线程安全问题，那么现在有<strong>方法访问修饰</strong>符带来的思考，如果把 method2 和 method3 的方法修改为 public 会不会影响线程安全问题？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafe</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <span class="hljs-comment">//局部变量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            method2(list);<br>            method3(list);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;   <span class="hljs-comment">//局部变量传进来</span><br>        list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;<br>        list.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>情况1：线程1调用method1，线程2调用method2，会有线程安全问题吗</p>
<p>回答：不会出现问题，和上面的分析一样，线程1调用method1，线程2调用method2，都会创建不同的list对象，分别传到自己的线程中，不会出现线程安全问题</p>
<p>情况2：在 情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法。覆盖的方法中又调用了新线程，此时是否会引起线程安全问题</p>
<p>回答：<strong>会影响</strong>，因为线程1的子类对象在调用方法3时，方法3中新线程访问的list和方法1中的list是同一个list，两个线程访问同一个list，会引起线程安全。</p>
<p>父类方法管不了子类覆盖方法的内容，是可能造成线程安全问题的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafeSubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadSafe</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            list.remove(<span class="hljs-number">0</span>);<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ThreadSafeSubClass</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadSafeSubClass</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            test.method1(<span class="hljs-number">200</span>);<br>        &#125;, <span class="hljs-string">&quot;Thread&quot;</span> + i).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因此，得到的启发是，<strong>方法的访问修饰符是很有意义的，一定程度上能够保护线程安全，<code>private</code>修饰符限制了子类方法不能覆盖父类方法</strong>（一个类的private方法会隐式的被指定为final方法）。对于public修饰的公共方法如果不想让子类覆盖，加上<code>final</code>修饰符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafe</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <span class="hljs-comment">//局部变量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            method2(list);<br>            method3(list);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;   <span class="hljs-comment">//局部变量传进来</span><br>        list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;<br>        list.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从这个例子可以看出 private 或 final 提供【安全】的意义所在，请体会开闭原则中的【闭】</p>
<h2 id="4-常见线程安全类"><a href="#4-常见线程安全类" class="headerlink" title="4. 常见线程安全类"></a>4. 常见线程安全类</h2><h3 id="4-1-常见线程安全类"><a href="#4-1-常见线程安全类" class="headerlink" title="4.1 常见线程安全类"></a>4.1 常见线程安全类</h3><ul>
<li>String</li>
<li>Integer</li>
<li>StringBuﬀer</li>
<li>Random</li>
<li>Vector （List的线程安全实现类）</li>
<li>Hashtable （Hash的线程安全实现类）</li>
<li>java.util.concurrent 包下的类</li>
</ul>
<p>这里说它们是线程安全的是指，多个线程调用它们<strong>同一个实例的某个方法时</strong>，是线程安全的</p>
<h3 id="4-2-线程安全类的单独方法"><a href="#4-2-线程安全类的单独方法" class="headerlink" title="4.2 线程安全类的单独方法"></a>4.2 线程安全类的单独方法</h3><p>它们的每个方法是原子的（都被加上了synchronized）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//不会有线程安全问题</span><br><span class="hljs-type">Hashtable</span> <span class="hljs-variable">table</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>	table.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>&#125;).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>	table.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>&#125;).start();<br></code></pre></td></tr></table></figure>



<h3 id="4-3-线程安全类方法的组合"><a href="#4-3-线程安全类方法的组合" class="headerlink" title="4.3 线程安全类方法的组合"></a>4.3 线程安全类方法的组合</h3><p>但注意它们<strong>多个方法的组合不是原子的</strong>，所以可能会出现线程安全问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Hashtable</span> <span class="hljs-variable">table</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>();<br><span class="hljs-comment">// 如下面的流程图所示，线程1刚get完就被线程2进入时间片，put完value2后，又被线程1的value1覆盖</span><br><span class="hljs-keyword">if</span>( table.get(<span class="hljs-string">&quot;key&quot;</span>) == <span class="hljs-literal">null</span>) &#123;<br>	table.put(<span class="hljs-string">&quot;key&quot;</span>, value);<br>&#125;<br></code></pre></td></tr></table></figure>

<pre><code class=" mermaid">sequenceDiagram
participant t1 as 线程1
participant t2 as 线程2
participant table
t1 -&gt;&gt; table : get(&quot;key&quot;) == null
t2 -&gt;&gt; table : get(&quot;key&quot;) == null
t2 -&gt;&gt; table : put(&quot;key&quot;, value2)
t1 -&gt;&gt; table : put(&quot;key&quot;, value1)
</code></pre>

<h3 id="4-4-不可变类线程安全"><a href="#4-4-不可变类线程安全" class="headerlink" title="4.4 不可变类线程安全"></a>4.4 不可变类线程安全</h3><p>String、Integer 等都是<strong>不可变类</strong>，因为其内部的状态不可以改变，因此它们的方法都是线程安全的。</p>
<p>有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安全的呢？这是因为这些方法的返回值都<strong>创建了一个新的对象</strong>，而不是直接改变String、Integer对象本身。</p>
<p>几个典型的例子：判断是不是线程安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">Date</span> <span class="hljs-variable">D2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();  <span class="hljs-comment">// 不安全，Date内容是可变的，final只是不让其指向其他引用对象</span><br>-----------------------------------------------------------------------------------<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 不安全，foo是抽象方法，将sdf可变类转给抽象方法，一旦foo被子类对象重写并涉及到多线程，容易出现安全问题</span><br>        <span class="hljs-comment">// foo 的行为是不确定的，可能导致不安全的发生，被称之为外星方法</span><br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>        foo(sdf);<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(SimpleDateFormat sdf)</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>().bar();<br>    &#125;<br>&#125;<br>-----------------------------------------------------------------------------------<br></code></pre></td></tr></table></figure>



<h2 id="5-对象锁"><a href="#5-对象锁" class="headerlink" title="5. 对象锁"></a>5. 对象锁</h2><h3 id="1-锁状态"><a href="#1-锁状态" class="headerlink" title="(1) 锁状态"></a>(1) 锁状态</h3><p>锁的状态由Java对象头的Mark Word决定，有正常、偏向锁、轻量级锁、重量级锁等。</p>
<p>32位虚拟机的Java对象头组成：</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-Java%E5%AF%B9%E8%B1%A1%E5%A4%B4.png" srcset="/img/loading.gif" lazyload alt="image-20220116230951245"></p>
<p>其中 Mark Word 结构为：</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-Mark%20Word.png" srcset="/img/loading.gif" lazyload alt="image-20220116231130950"></p>
<p>64位虚拟机的Mark Word：</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-64%E4%BD%8D%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E5%A4%B4.png" srcset="/img/loading.gif" lazyload alt="image-20220117211337152"></p>
<h3 id="2-重量级锁"><a href="#2-重量级锁" class="headerlink" title="(2) 重量级锁"></a>(2) 重量级锁</h3><p>Monitor，又被称为锁&#x2F;管程，这里实际上指的是重量级锁</p>
<p>锁（Monitor）原理：当线程执行到临界区代码时，如果使用了synchronized，会先查询synchronized中所指定的对象(obj)<strong>是否绑定了Monitor</strong>（Monitor是由操作系统提供的）。</p>
<ul>
<li>如果<strong>没有绑定</strong>，则会先去与Monitor绑定（将对象头中的<strong>Mark Word</strong>置为Monitor指针），并且将Owner设为当前线程。</li>
<li>如果<strong>已经绑定</strong>，则会去查询该Monitor是否已经有了Owner<ul>
<li>如果没有，则Owner与将当前线程绑定</li>
<li>如果有，则放入EntryList，进入阻塞状态(blocked)</li>
</ul>
</li>
<li>当Monitor的Owner将临界区中代码执行完毕后，Owner便会被清空，此时EntryList中处于<strong>阻塞</strong>状态的线程会被<strong>叫醒并竞争</strong>，此时的竞争是<strong>非公平的</strong>（既不是先到先得）</li>
</ul>
<p>注意：</p>
<p>每个对象都会绑定一个<strong>唯一的Monitor</strong>，如果synchronized中所指定的对象(obj)<strong>不同</strong>，则会绑定<strong>不同</strong>的Monitor</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81%E5%8E%9F%E7%90%86.png" srcset="/img/loading.gif" lazyload alt="image-20220116202736471"></p>
<p>Monitor是由操作系统提供的，加锁是依赖底层操作系统的 mutex相关指令实现，所以会造成用户态和内核态之间的切换，非常耗性能！</p>
<p>在JDK6的时候，引入了<strong>偏向锁</strong>和<strong>轻量级锁</strong>对synchronized进行了优化，在JVM层实现加锁的逻辑，不依赖底层操作系统，就没有了切换的消耗</p>
<h3 id="3-锁自旋优化"><a href="#3-锁自旋优化" class="headerlink" title="(3) 锁自旋优化"></a>(3) 锁自旋优化</h3><p><strong>重量级锁竞争</strong>的时候，还可以使用自旋来进行优化 （不加入Monitor的阻塞队列EntryList中）</p>
<ul>
<li><p>如果当前线程2自旋成功（即在自旋的时候持锁的线程1释放了锁），那么当前线程2就可以不用进行上下文切换（持锁线程1执行完synchronized同步块后，释放锁，Owner为空，唤醒阻塞队列来竞争，胜出的线程得到cpu执行权的过程）就获得了锁</p>
<p>  <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81%E8%87%AA%E6%97%8B%E6%88%90%E5%8A%9F.png" srcset="/img/loading.gif" lazyload alt="image-20220117221208994"></p>
</li>
<li><p>自旋重试失败的情况，自旋了一定次数还是没有等到持锁的线程1释放锁，线程2就会加入Monitor的阻塞队列(EntryList)</p>
<p>  <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81%E8%87%AA%E6%97%8B%E5%A4%B1%E8%B4%A5.png" srcset="/img/loading.gif" lazyload alt="image-20220117221237881"></p>
</li>
</ul>
<p>优化的点：<strong>不用将线程加入到阻塞队列，减少cpu切换</strong>，注意<strong>不是优化轻量级锁，而是优化重量级锁</strong></p>
<p>注意：</p>
<ul>
<li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</li>
<li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。Java 7 之后不能控制是否开启自旋功能（JVM底层）</li>
</ul>
<h3 id="4-轻量级锁"><a href="#4-轻量级锁" class="headerlink" title="(4) 轻量级锁"></a>(4) 轻量级锁</h3><p><strong>轻量级锁使用场景：</strong>当一个对象被多个线程所访问，但访问的时间是<strong>错开的（不存在竞争）</strong>，此时就可以使用<strong>轻量级锁</strong>来优化。如果有竞争，还是升级为重量级锁</p>
<p>轻量级锁对使用者是透明的，语法仍然是 Synchronized。</p>
<p>假设有两个方法同步块，利用同一个对象加加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">synchronized</span>(obj)&#123;<br>        <span class="hljs-comment">//同步块A</span><br>        method2()<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">synchronized</span>(obj)&#123;<br>		<span class="hljs-comment">//同步块B</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>轻量级锁加锁步骤：</p>
<ul>
<li>创建<strong>锁记录</strong>（Lock Record）对象（这是JVM层面的，不是Java对象），每个线程的栈帧都会包含一个锁记录对象，内部可以存储加锁对象的mark word（不再一开始就使用Monitor）</li>
<li>让锁记录中的Object reference指向锁对象（Object），并尝试用cas(后面再讲，其具有原子性)去替换Object中的mark word，将此mark word放入lock record中保存</li>
</ul>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%86.png" srcset="/img/loading.gif" lazyload alt="image-20220116224353413"></p>
<ul>
<li>如果cas替换成功，则将Object的对象头替换为<strong>锁记录的地址</strong>和<strong>状态 00（轻量级锁状态）</strong>，并由该线程给对象加锁</li>
</ul>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%862.png" srcset="/img/loading.gif" lazyload alt="image-20220116224611879"></p>
<ul>
<li>如果cas替换失败，有两种情况 :<ul>
<li>如果是其它线程已经持有了该Object的轻量级锁（对象头中已经存储了别的线程的锁记录地址 00），那么表示有竞争，将进入<strong>锁膨胀</strong>阶段。图示见下一节</li>
<li>如果是自己的线程已经执行了synchronized，则发生<strong>锁重入</strong>，会再添加一条 Lock Record 作为重入锁的计数。线程中有多少个锁记录，就能表明该线程对这个对象加了几次锁（锁重入计数）<br>  <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%863.png" srcset="/img/loading.gif" lazyload alt="image-20220116232601812"></li>
</ul>
</li>
</ul>
<p>轻量级锁解锁步骤：</p>
<ul>
<li>当线程退出synchronized代码块的时候，如果获取的是取值为 null 的锁记录，表示有<strong>锁重入</strong>，这时重置锁记录，表示重入计数减一</li>
<li>当线程退出synchronized代码块的时候，如果获取的锁记录取值不为 null，那么使用cas将Mark Word的值恢复给对象，将直接替换的内容还原。<ul>
<li>成功，轻量级锁解锁成功</li>
<li>失败，表示有竞争, 则说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程 (Monitor流程)</li>
</ul>
</li>
</ul>
<h3 id="5-锁膨胀"><a href="#5-锁膨胀" class="headerlink" title="(5) 锁膨胀"></a>(5) 锁膨胀</h3><p>如果一个线程在给一个对象加轻量级锁时，<strong>cas替换操作失败</strong>（因为此时其他线程已经给对象加了轻量级锁），此时该线程就会进入<strong>锁膨胀</strong>过程。</p>
<p>如图所示，线程1想用cas将线程1中的lock record替换Object的mark word，显然是替换不了的，因为已经有了线程0的轻量级锁了</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81%E8%86%A8%E8%83%80.png" srcset="/img/loading.gif" lazyload alt="image-20220116234258915"></p>
<p>此时Thread-1加轻量级锁失败，<strong>进入锁膨胀流程</strong></p>
<ul>
<li>为对象申请Monitor锁（重量级锁），让Object指向重量级锁地址 10</li>
<li>然后自己进入Monitor 的EntryList 变成BLOCKED状态（轻量级锁没有阻塞队列的概念）</li>
</ul>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81%E8%86%A8%E8%83%802.png" srcset="/img/loading.gif" lazyload alt="image-20220116234855323"></p>
<p>当Thread-0 线程执行完同步块时，使用cas将Mark Word的值恢复给对象头，肯定恢复失败，因为对象的对象头中存储的是重量级锁的地址，状态变为10了，之前的是00，肯定恢复失败。那么会进入重量级锁的解锁过程，即按照Monitor的地址找到Monitor对象，将Owner设置为null，唤醒EntryList中的Thread-1线程</p>
<h3 id="6-偏向锁"><a href="#6-偏向锁" class="headerlink" title="(6) 偏向锁"></a>(6) 偏向锁</h3><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然执行CAS替换操作，这样是会使性能降低的。</p>
<p>Java6 引入了<strong>偏向锁</strong>对性能进行优化：在<strong>第一次</strong>cas时会将<strong>线程的ID</strong>写入对象的Mark Word中。此后发现这个线程ID就是自己的，就表示没有竞争，就不需要再次cas，以后只要不发生竞争，这个对象就归该线程所有。即<strong>偏向锁用于优化轻量级锁重入</strong></p>
<p>一个对象创建时：</p>
<ul>
<li>如果开启了偏向锁（默认开启），在创建对象时，对象的Mark Word后三位应该是101</li>
<li>但是偏向锁默认是<strong>有延迟</strong>的，不会再程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态。如果想避免延迟，可以添加虚拟机参数来禁用延迟：<code>-XX:BiasedLockingStartupDelay=0</code>来禁用延迟</li>
<li>如果没有开启偏向锁，那么对象创建后最后三位的值为001，这时候它的hashcode，age都为0，hashcode是第一次用到hashcode时才赋值的。添加虚拟机参数来禁用偏向锁：<code>-XX:-UseBiasedLocking</code>。禁用偏向锁则优先使用轻量级锁</li>
</ul>
<p>撤销偏向锁</p>
<ul>
<li>当调用对象的hashcode方法的时候就会撤销这个对象的偏向锁，因为使用偏向锁时没有位置存hashcode的值了，存的是线程id</li>
<li>还有一种方法就是当有其他线程也使用偏向锁对象时，便会将偏向锁升级为轻量级锁（前提是两个线程没有锁竞争，即一个线程执行完了，另一个线程还没执行，否则就升级为重量级锁）</li>
<li>调用了wait&#x2F;notify方法（调用wait方法会导致锁膨胀而使用重量级锁）</li>
</ul>
<p>批量重偏向</p>
<ul>
<li>如果对象虽然被多个线程访问，但是线程间不存在竞争，这时偏向T1的对象仍有机会重新偏向T2，重偏向会重置Thread ID</li>
<li>当撤销超过20次后（超过阈值），JVM会觉得是不是偏向错了，这时会在给<strong>剩下的对象</strong>加锁时，批量重偏向至更需要的加锁线程。</li>
</ul>
<p>批量撤销</p>
<ul>
<li>当 撤销偏向锁的阈值超过40以后 ，就会将整个类的对象都改为<strong>不可偏向</strong>的，后三位为001，</li>
</ul>
<h3 id="7-锁消除"><a href="#7-锁消除" class="headerlink" title="(7) 锁消除"></a>(7) 锁消除</h3><p>给对象加锁（线程同步）的代价是很高的，会降低并发性和性能。在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</p>
<p>简言之，JVM底层会判断有没有必要加锁，没必要的话就会自动去掉锁。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>synchronized锁原来只有重量级锁(Monitor)，但这玩意儿是操作系统层的，比较浪费性能。因此从Jdk1.6开始使用偏向锁和轻量级锁优化性能，在不同场景使用不同的锁。锁只有升级，没有降级</p>
<ul>
<li>只有一个线程进入临界区 –&gt; 偏向锁（对象头的Mark Word记录线程ID进行比对）</li>
<li>多个线程交替（没有竞争）进入临界区 –&gt; 轻量级锁（用CAS将对象头原本的Mark Word拷贝到线程栈帧的Lock Record中，在对象头放锁记录的地址和锁状态）</li>
<li>多个线程同时（有竞争）进入临界区 –&gt; 重量级锁（每个对象绑定唯一的Monitor，其他线程竞争时会有<strong>锁自旋优化</strong>，自旋失败则进入Monitor中的Entrylist放置等待）</li>
</ul>
<h2 id="6-synchronized-原理"><a href="#6-synchronized-原理" class="headerlink" title="6. synchronized 原理"></a>6. synchronized 原理</h2><p>要从字节码角度去分析</p>
<p>（1）给对象加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//其他操作.......</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123; <span class="hljs-comment">//this表示当前对象实例，这里还可以使用syncTest.class，表示class对象锁</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>            i++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码，其字节码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-number">1</span> dup<br><span class="hljs-number">2</span> astore_1<br><span class="hljs-number">3</span> monitorenter <span class="hljs-comment">//进入同步代码块的指令</span><br><span class="hljs-number">4</span> iconst_0<br><span class="hljs-number">5</span> istore_2<br><span class="hljs-number">6</span> iload_2<br><span class="hljs-number">7</span> sipush <span class="hljs-number">10000</span><br><span class="hljs-number">10</span> if_icmpge <span class="hljs-number">27</span> (+<span class="hljs-number">17</span>)<br><span class="hljs-number">13</span> getstatic #<span class="hljs-number">2</span> &lt;com/company/syncTest.i&gt;<br><span class="hljs-number">16</span> iconst_1<br><span class="hljs-number">17</span> iadd<br><span class="hljs-number">18</span> putstatic #<span class="hljs-number">2</span> &lt;com/company/syncTest.i&gt;<br><span class="hljs-number">21</span> iinc <span class="hljs-number">2</span> by <span class="hljs-number">1</span><br><span class="hljs-number">24</span> goto <span class="hljs-number">6</span> (-<span class="hljs-number">18</span>)<br><span class="hljs-number">27</span> aload_1<br><span class="hljs-number">28</span> monitorexit <span class="hljs-comment">//结束同步代码块的指令</span><br><span class="hljs-number">29</span> goto <span class="hljs-number">37</span> (+<span class="hljs-number">8</span>)<br><span class="hljs-number">32</span> astore_3<br><span class="hljs-number">33</span> aload_1<br><span class="hljs-number">34</span> monitorexit <span class="hljs-comment">//遇到异常时执行的指令</span><br><span class="hljs-number">35</span> aload_3<br><span class="hljs-number">36</span> athrow<br><span class="hljs-number">37</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>

<p>从上述字节码中可以看到同步代码块的实现是由monitorenter 和 monitorexit 指令完成的，其中 monitorenter 指令所在的位置是同步代码块开始的位置，第一个monitorexit 指令是用于正常结束同步代码块的指令，第二个monitorexit 指令是用于异常结束时所执行的释放Monitor指令。</p>
<p>（2）给同步方法加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>    i++;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其字节码指令为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-number">0</span> getstatic #<span class="hljs-number">2</span> &lt;com/company/syncTest.i&gt;<br><span class="hljs-number">3</span> iconst_1<br><span class="hljs-number">4</span> iadd<br><span class="hljs-number">5</span> putstatic #<span class="hljs-number">2</span> &lt;com/company/syncTest.i&gt;<br><span class="hljs-number">8</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>

<p>发现这个没有monitorenter 和 monitorexit 这两个指令了，而在查看该方法的class文件的结构信息时发现了Access flags后边的synchronized标识，该标识表明了该方法是一个同步方法。Java虚拟机通过该标识可以来辨别一个方法是否为同步方法，如果有该标识，线程将持有Monitor，再执行方法，最后释放Monitor。</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java/JUC/synchronized%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%BF%A1%E6%81%AF.png" srcset="/img/loading.gif" lazyload alt="image-20220521154818224"></p>
<p>总结：Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，代码块同步使用的是monitorenter 和 monitorexit 指令实现的，而方法同步是通过Access flags后面的标识来确定该方法是否为同步方法。</p>
<h2 id="7-wait-x2F-notify"><a href="#7-wait-x2F-notify" class="headerlink" title="7. wait&#x2F;notify"></a>7. wait&#x2F;notify</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当线程获得到了锁，成为Monitor的Owner，但是此时它发现自己想要执行synchroized代码块的条件不满足，此时它就调用<code>obj.wait</code>方法，进入到 Monitor 中的 WaitSet 集合，此时线程0的状态就变为WAITING</p>
<p>BLOCKED 和 WAITING 状态的线程都为阻塞状态，CPU都不会分给他们时间片。但是有所区别：</p>
<ul>
<li>BLOCKED状态的线程是在竞争锁对象时，发现Monitor的Owner已经是别的线程了，此时就会进入EntryList中，并处于BLOCKED状态。处于BLOCKED状态的线程会在锁被释放的时候被唤醒</li>
<li>WAITING状态的线程是获得了对象的锁，但是自身的原因无法执行synchroized的临界区资源需要进入阻塞状态时，锁对象调用了wait方法而进入了WaitSet中，处于WAITING状态。处于WAITING状态的线程只有被锁对象调用了notify方法<code>(obj.notify/obj.notifyAll)</code>，才会被唤醒。</li>
<li><strong>被唤醒后不意味着立刻获得锁，它会进入到EntryList，</strong>重新竞争锁 (此时就将锁升级为重量级锁)</li>
</ul>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81notify.png" srcset="/img/loading.gif" lazyload alt="image-20220118114911104"></p>
<h3 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h3><p>下面的几个方法都是Object中的方法，通过<strong>锁对象来调用</strong>（前提是<strong>对象被上锁之后</strong>，才能调用），不是线程的方法，不上锁调用报错</p>
<ul>
<li>wait(): 让获得对象锁的线程到waitSet中一直等待</li>
<li>wait(long n) : 当该等待线程没有被notify, 等待时间到了之后, 也会自动唤醒，单位ms</li>
<li>notify(): 让获得对象锁的线程, 使用锁对象调用notify去waitSet的等待线程中（随机）挑一个唤醒</li>
<li>notifyAll() : 让获得对象锁的线程, 使用锁对象调用notifyAll去唤醒waitSet中所有的等待线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j(topic = &quot;info&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wait_and_Notify</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span>(obj)&#123;<br>                log.debug(<span class="hljs-string">&quot;执行...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    obj.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;其他代码...&quot;</span>);<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span>(obj)&#123;<br>                log.debug(<span class="hljs-string">&quot;执行...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    obj.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;其他代码...&quot;</span>);<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>        Sleeper.sleep(<span class="hljs-number">2</span>);<br>        log.debug(<span class="hljs-string">&quot;唤醒obj上其他线程&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (obj)&#123;<br><span class="hljs-comment">//            obj.notify();     // 唤醒obj上一个线程</span><br>            obj.notifyAll();  <span class="hljs-comment">// 唤醒obj所有线程</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>只唤醒一个线程：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">16:08:29.260 [t1] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 执行<span class="hljs-built_in">..</span>.<br>16:08:29.262 [t2] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 执行<span class="hljs-built_in">..</span>.<br>16:08:31.259 [main] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 唤醒obj上其他线程<br>16:08:31.259 [t1] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 其他代码<span class="hljs-built_in">..</span>.<br><br>程序不会结束<br></code></pre></td></tr></table></figure>

<p>唤醒所有线程：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">16:04:41.689 [t1] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 执行<span class="hljs-built_in">..</span>.<br>16:04:41.691 [t2] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 执行<span class="hljs-built_in">..</span>.<br>16:04:43.689 [main] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 唤醒obj上其他线程<br>16:04:43.689 [main] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 主线程结束<br>16:04:43.689 [t1] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 其他代码<span class="hljs-built_in">..</span>.<br>16:04:43.689 [t2] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 其他代码<span class="hljs-built_in">..</span>.<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure>



<h3 id="Wait与Sleep的区别"><a href="#Wait与Sleep的区别" class="headerlink" title="Wait与Sleep的区别"></a>Wait与Sleep的区别</h3><p><strong>不同点</strong></p>
<ul>
<li>Sleep是Thread类的静态方法，Wait是Object的方法，Object又是所有类的父类，所以所有类都有Wait方法。</li>
<li><strong>Sleep在阻塞的时候不会释放锁，而Wait在阻塞的时候会释放锁</strong></li>
<li>Sleep不需要与synchronized一起使用，而Wait需要与synchronized一起使用（对象被锁以后才能使用）</li>
</ul>
<p><strong>相同点</strong></p>
<ul>
<li>阻塞状态都为<strong>TIMED_WAITING</strong></li>
</ul>
<h3 id="正确使用wait-x2F-notify"><a href="#正确使用wait-x2F-notify" class="headerlink" title="正确使用wait&#x2F;notify"></a>正确使用wait&#x2F;notify</h3><p>什么时候适合使用wait。当线程<strong>不满足某些条件</strong>，需要暂停运行时，可以使用wait。这样会将<strong>对象的锁释放</strong>，让其他线程能够继续运行。但是使用wait&#x2F;notify有很多注意点，下面结合代码一一讲解</p>
<p>举例：小南线程需要抽烟才能干活，小女线程需要外卖才能干活，剩下五个线程可以正常干活，有另一个线程送外卖过来让小女干活，怎么使用wait&#x2F;notify让他们合理的运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j(topic = &quot;info&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wait_and_Notify_Use</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasCigarette</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasTakeout</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;                              <span class="hljs-comment">// 注意点1</span><br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>                <span class="hljs-keyword">while</span> (!hasCigarette) &#123;                        <span class="hljs-comment">// 注意点3</span><br>                    log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        room.wait();                           <span class="hljs-comment">// 注意点1</span><br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>                <span class="hljs-keyword">if</span> (hasCigarette) &#123;<br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;小南&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>                log.debug(<span class="hljs-string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);<br>                <span class="hljs-keyword">while</span> (!hasTakeout) &#123;                              <br>                    log.debug(<span class="hljs-string">&quot;没外卖，先歇会！&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        room.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);<br>                <span class="hljs-keyword">if</span> (hasTakeout) &#123;<br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;小女&quot;</span>).start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                    log.debug(<span class="hljs-string">&quot;正常干活&quot;</span>);<br>                &#125;<br>            &#125;, <span class="hljs-string">&quot;其它人&quot;</span>).start();<br>        &#125;<br><br>        Sleeper.sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                hasTakeout = <span class="hljs-literal">true</span>;<br>                log.debug(<span class="hljs-string">&quot;外卖到了噢！&quot;</span>);<br>                room.notifyAll();                                <span class="hljs-comment">// 注意点2</span><br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;送外卖的&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros">16:55:36.386 [小南] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 有烟没？[<span class="hljs-literal">false</span>]<br>16:55:36.388 [小南] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 没烟，先歇会！<br>16:55:36.388 [其它人] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 正常干活<br>16:55:36.388 [其它人] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 正常干活<br>16:55:36.388 [其它人] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 正常干活<br>16:55:36.389 [其它人] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 正常干活<br>16:55:36.389 [其它人] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 正常干活<br>16:55:36.389 [小女] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 外卖送到没？[<span class="hljs-literal">false</span>]<br>16:55:36.389 [小女] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 没外卖，先歇会！<br>16:55:37.387 [送外卖的] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 外卖到了噢！<br>16:55:37.387 [小南] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 没烟，先歇会！<br>16:55:37.388 [小女] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 外卖送到没？[<span class="hljs-literal">true</span>]<br>16:55:37.388 [小女] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 可以开始干活了<br><br>程序未结束，因为小南线程未结束<br></code></pre></td></tr></table></figure>



<p>上述代码有很多注意点值得思考，结合注释：</p>
<ul>
<li>注意点1：这里不能使用sleep，<strong>如果此时使用sleep，会导致所有线程都进入阻塞</strong>，导致剩下的所有线程都没法运行，直到当前线程sleep结束后，运行完毕，才能得到执行。所以我们不推荐使用sleep，而是使用wait，使用wait就得结合锁对象使用，而不是调用Thread的方法</li>
<li>注意点2：这里不能使用notify，容易造成虚假唤醒（唤醒的不是满足条件的等待线程），即送外卖的这个线程其实是想唤醒小女的，但notify并不能保证唤醒的一定是小女，也可能唤醒的是小南，所以此处只能使用notifyAll方法</li>
<li>注意点3：此处必须要使用while判断，而不是if，if只能判断一次，送外卖线程把小女小南都唤醒后，小女能干活了，但小南应该继续进入下一次wait，继续等待送烟线程，所以要使用while循环判断</li>
</ul>
<p>因此，可以总结出正确使用wait&#x2F;notify的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">synchronized</span>(lock) &#123;     <span class="hljs-comment">// 注意点1</span><br>	<span class="hljs-keyword">while</span>(条件不成立) &#123;    <span class="hljs-comment">// 注意点3</span><br>		lock.wait();     <span class="hljs-comment">// 注意点1</span><br>	&#125;<br>	<span class="hljs-comment">// 干活</span><br>&#125;<br><br><span class="hljs-comment">//另一个线程</span><br><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>	lock.notifyAll();    <span class="hljs-comment">// 注意点2</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="同步模式之保护性暂停"><a href="#同步模式之保护性暂停" class="headerlink" title="同步模式之保护性暂停"></a>同步模式之保护性暂停</h2><h3 id="1-保护性暂停"><a href="#1-保护性暂停" class="headerlink" title="(1) 保护性暂停"></a>(1) 保护性暂停</h3><p>定义：用在一个线程等待另一个线程的执行结果，即 Guarded Suspension</p>
<p>要点：</p>
<ul>
<li>有一个结果需要从一个线程传递到另一个线程（下图t1想要t2的结果），让他们关联同一个 GuardedObject</li>
<li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者&#x2F;消费者）</li>
<li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li>
<li>因为要等待另一方的结果，因此归类到同步模式</li>
</ul>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C.png" srcset="/img/loading.gif" lazyload alt="image-20220119111105735"></p>
<p>线程1等待线程2下载的结果，并获取该结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedSuspensionTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObject</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 子线程执行下载</span><br>                List&lt;String&gt; response = Downloader.download();<br>                log.debug(<span class="hljs-string">&quot;download complete...&quot;</span>);<br>                guardedObject.complete(response);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br>        log.debug(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>        <span class="hljs-comment">// 主线程阻塞等待</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> guardedObject.get();<br>        log.debug(<span class="hljs-string">&quot;get response: [&#123;&#125;] lines&quot;</span>, ((List&lt;String&gt;) response).size());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObject</span> &#123;<br>    <span class="hljs-keyword">private</span> Object response;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// 条件不满足则等待</span><br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    lock.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> response;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Object response)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// 条件满足，通知等待线程</span><br>            <span class="hljs-built_in">this</span>.response = response;<br>            lock.notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-带超时时间"><a href="#2-带超时时间" class="headerlink" title="(2) 带超时时间"></a>(2) 带超时时间</h3><p>设置超时时间，如果超过时间还没返回结果，此时就不等了，退出while循环。。<strong>没太认真看，后续有需要再看吧</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardeObject</span> &#123;<br>    <span class="hljs-comment">// 结果</span><br>    <span class="hljs-keyword">private</span> Object response;<br><br>    <span class="hljs-comment">// 获取结果</span><br>    <span class="hljs-comment">// timeout表示最多等待多久. 这里假如是2s</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">// 假如开始时间为 15:00:00</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            <span class="hljs-comment">// 经历的时间</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">passedTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 这一轮循环应该等待的时间 = 最大等待时间 - 已经经历的时间</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">waitTime</span> <span class="hljs-operator">=</span> timeout - passedTime;<br>                <span class="hljs-comment">// 经历的时间超过了最大等待时间, 退出循环</span><br>                <span class="hljs-comment">// 这里也可以改成if (waitTime &lt;= 0)，一样的</span><br>                <span class="hljs-keyword">if</span> (passedTime &gt;= timeout) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">// this.wait(timeout)的问题: 虚假唤醒在15:00:01的时候,此时response还null, 此时经历时间就为1s,</span><br>           <span class="hljs-comment">// 进入while循环的时候response还是空,此时判断1s&lt;=timeout 2s,此时再次this.wait(2s)吗,此时已经经历了</span><br>           <span class="hljs-comment">// 1s,所以只要再等1s就可以了. 所以等待的时间应该是 超时时间(timeout) - 经历的时间(passedTime)</span><br>           <span class="hljs-comment">// 即不用wait(timeout)的原因就是避免虚假唤醒导致下一轮等待的时间边长</span><br>                    <span class="hljs-built_in">this</span>.wait(waitTime);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-comment">// 经历时间，当前时间-开始时间</span><br>                passedTime = System.currentTimeMillis() - begin; <span class="hljs-comment">// 15:00:02</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> response;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 产生结果</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Object response)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">// 给结果变量赋值</span><br>            <span class="hljs-built_in">this</span>.response = response;<br>            <span class="hljs-built_in">this</span>.notifyAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的超时时间看起来复杂，实际上很简单，可以看下面join的代码，else里的逻辑</p>
<h3 id="3-join方法原理"><a href="#3-join方法原理" class="headerlink" title="(3) join方法原理"></a>(3) join方法原理</h3><p>join带参形式的源码就是带超时时间的保护性暂停</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span><br><span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>            wait(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// join一个指定的时间</span><br>        <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> millis - now;<br>            <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            wait(delay);<br>            now = System.currentTimeMillis() - base;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="4-多任务版"><a href="#4-多任务版" class="headerlink" title="(4) 多任务版"></a>(4) 多任务版</h3><p>暂时跳过</p>
<h2 id="异步模式之生产者消费者"><a href="#异步模式之生产者消费者" class="headerlink" title="异步模式之生产者消费者"></a>异步模式之生产者消费者</h2><h2 id="8-park-amp-unpack"><a href="#8-park-amp-unpack" class="headerlink" title="8. park &amp; unpack"></a>8. park &amp; unpack</h2><h3 id="8-1-使用方法"><a href="#8-1-使用方法" class="headerlink" title="8.1 使用方法"></a>8.1 使用方法</h3><p>park&#x2F;unpark（park：把…搁置）都是LockSupport类（一个多线程工具类）中的的方法，和之前的wait&#x2F;notify有相同的作用，即用于暂停和恢复线程的运行，是非常好用的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//暂停线程运行</span><br>LockSupport.park;<br><br><span class="hljs-comment">//恢复某个线程运行，需要传入指定线程</span><br>LockSupport.unpark(thread);<br></code></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;t1 启动...&quot;</span>);<br>        Sleeper.sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;t1 使用 park 暂停运行...&quot;</span>);<br>        LockSupport.park();<br>        log.debug(<span class="hljs-string">&quot;t1 恢复运行...&quot;</span>);<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>    t1.start();<br>    Sleeper.sleep(<span class="hljs-number">2</span>);<br>    log.debug(<span class="hljs-string">&quot;主线程 unpark t1线程...&quot;</span>);<br>    LockSupport.unpark(t1);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">12:58:48.109 [t1] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - t1 启动<span class="hljs-built_in">..</span>.<br>12:58:49.123 [t1] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - t1 使用 park 暂停运行<span class="hljs-built_in">..</span>.<br>12:58:50.119 [main] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 主线程 unpark t1线程<span class="hljs-built_in">..</span>.<br>12:58:50.119 [t1] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - t1 恢复运行<span class="hljs-built_in">..</span>.<br></code></pre></td></tr></table></figure>



<p><strong>与wait&#x2F;notify的区别</strong></p>
<ul>
<li><p>wait，notify 和 notifyAll 必须配合<strong>Object Monitor</strong>一起使用，而park，unpark不必</p>
</li>
<li><p>park ，unpark 是以<strong>线程为单位</strong>来阻塞和唤醒线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么精确</p>
</li>
<li><p><strong>park不会释放锁</strong>，而wait会释放锁</p>
</li>
<li><p>park &amp; unpark 可以<strong>先 unpark</strong>（见下面代码），而 wait &amp; notify 不能先 notify：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;t1 启动...&quot;</span>);<br>        Sleeper.sleep(<span class="hljs-number">2</span>);<br>        log.debug(<span class="hljs-string">&quot;t1 使用 park 暂停运行...&quot;</span>);<br>        LockSupport.park();<br>        log.debug(<span class="hljs-string">&quot;t1 恢复运行...&quot;</span>);<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>    t1.start();<br>    Sleeper.sleep(<span class="hljs-number">1</span>);<br>    log.debug(<span class="hljs-string">&quot;主线程 unpark t1线程...&quot;</span>);<br>    LockSupport.unpark(t1);<br>&#125;<br></code></pre></td></tr></table></figure>

  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">13:02:02.729 [t1] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - t1 启动<span class="hljs-built_in">..</span>.<br>13:02:03.739 [main] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 主线程 unpark t1线程<span class="hljs-built_in">..</span>.<br>13:02:04.736 [t1] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - t1 使用 park 暂停运行<span class="hljs-built_in">..</span>.<br>13:02:04.736 [t1] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - t1 恢复运行<span class="hljs-built_in">..</span>.<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-2-原理"><a href="#8-2-原理" class="headerlink" title="8.2 原理"></a>8.2 原理</h3><p>每个线程都有一个自己的<strong>Park对象</strong>，并且该对象**_counter, _cond,__mutex**组成</p>
<ul>
<li>先调用park<ul>
<li>线程运行时，会将Park对象中的**_counter的值设为0**；</li>
<li>调用park时，会先查看counter的值是否为0，如果为0，则将线程放入阻塞队列cond中</li>
<li>放入阻塞队列中后，会<strong>再次</strong>将counter设置为0</li>
</ul>
</li>
</ul>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-Park.png" srcset="/img/loading.gif" lazyload alt="image-20220119171857218"></p>
<ul>
<li>然后调用unpark<ul>
<li>调用unpark方法后，会将counter的值设置为1</li>
<li>去唤醒阻塞队列cond中的线程</li>
<li>线程继续运行并将counter的值设为0</li>
</ul>
</li>
</ul>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-Unpark.png" srcset="/img/loading.gif" lazyload alt="image-20220119171951831"></p>
<p>如果是先调用Unpark，会将counter的值设置为1，再调用Park，发现counter值为1，无需阻塞，继续运行，再设置counter为0</p>
<h2 id="9-线程状态转换"><a href="#9-线程状态转换" class="headerlink" title="9. 线程状态转换"></a>9. 线程状态转换</h2><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%812.png" srcset="/img/loading.gif" lazyload alt="image-20220112215155531"></p>
<p>假设有线程 Thread t</p>
<h3 id="情况一：NEW-–-gt-RUNNABLE"><a href="#情况一：NEW-–-gt-RUNNABLE" class="headerlink" title="情况一：NEW –&gt; RUNNABLE"></a>情况一：NEW –&gt; RUNNABLE</h3><ul>
<li>当调用了t.start()方法时，由 NEW –&gt; RUNNABLE</li>
</ul>
<h3 id="情况二：-RUNNABLE-lt-–-gt-WAITING"><a href="#情况二：-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况二： RUNNABLE &lt;–&gt; WAITING"></a>情况二： RUNNABLE &lt;–&gt; WAITING</h3><ul>
<li>当调用了t 线程用 synchronized(obj) 获取了对象锁后<ul>
<li>调用 obj.wait() 方法时，t 线程从 RUNNABLE –&gt; WAITING</li>
<li>调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时<ul>
<li>竞争锁成功，t 线程从 WAITING –&gt; RUNNABLE</li>
<li>竞争锁失败，t 线程从 WAITING –&gt; BLOCKED</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="情况三：RUNNABLE-lt-–-gt-WAITING"><a href="#情况三：RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况三：RUNNABLE &lt;–&gt; WAITING"></a>情况三：RUNNABLE &lt;–&gt; WAITING</h3><ul>
<li><p>当前线程调用 t.join() 方法时，当前线程从 RUNNABLE –&gt; WAITING</p>
<ul>
<li>注意是<strong>当前线程</strong>在t 线程对象的监视器上等待</li>
</ul>
</li>
<li><p>t 线程<strong>运行结束</strong>，或调用了<strong>当前线程</strong>的 interrupt() 时，当前线程从 WAITING –&gt; RUNNABLE</p>
</li>
</ul>
<h3 id="情况四：-RUNNABLE-lt-–-gt-WAITING"><a href="#情况四：-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况四： RUNNABLE &lt;–&gt; WAITING"></a>情况四： RUNNABLE &lt;–&gt; WAITING</h3><ul>
<li>当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE –&gt; WAITING</li>
<li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING –&gt; RUNNABLE</li>
</ul>
<h3 id="情况五：-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况五：-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况五： RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况五： RUNNABLE &lt;–&gt; TIMED_WAITING</h3><p>t 线程用 synchronized(obj) 获取了对象锁后</p>
<ul>
<li>调用 obj.wait(<strong>long n</strong>) 方法时，t 线程从 RUNNABLE –&gt; TIMED_WAITING</li>
<li>t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时<ul>
<li>竞争锁成功，t 线程从 TIMED_WAITING –&gt; RUNNABLE</li>
<li>竞争锁失败，t 线程从 TIMED_WAITING –&gt; BLOCKED</li>
</ul>
</li>
</ul>
<h3 id="情况六：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况六：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况六：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况六：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul>
<li><p>当前线程调用 t.join(long n) 方法时，当前线程从 RUNNABLE –&gt; TIMED_WAITING</p>
<ul>
<li>注意是当前线程在t 线程对象的监视器上等待</li>
</ul>
</li>
<li><p>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 TIMED_WAITING –&gt; RUNNABLE</p>
</li>
</ul>
<h3 id="情况七：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况七：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况七：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况七：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul>
<li>当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –&gt; TIMED_WAITING</li>
<li>当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING –&gt; RUNNABLE</li>
</ul>
<h3 id="情况八：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况八：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况八：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况八：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul>
<li>当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线 程从 RUNNABLE –&gt; TIMED_WAITING</li>
<li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING–&gt; RUNNABLE</li>
</ul>
<h3 id="情况九：RUNNABLE-lt-–-gt-BLOCKED"><a href="#情况九：RUNNABLE-lt-–-gt-BLOCKED" class="headerlink" title="情况九：RUNNABLE &lt;–&gt; BLOCKED"></a>情况九：RUNNABLE &lt;–&gt; BLOCKED</h3><ul>
<li>t 线程用 synchronized(obj) 获取了对象锁时如果<strong>竞争失败</strong>，从 RUNNABLE –&gt; BLOCKED</li>
<li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –&gt; RUNNABLE ，其它<strong>失败</strong>的线程仍然 BLOCKED</li>
</ul>
<h3 id="情况十：-RUNNABLE-lt-–-gt-TERMINATED"><a href="#情况十：-RUNNABLE-lt-–-gt-TERMINATED" class="headerlink" title="情况十： RUNNABLE &lt;–&gt; TERMINATED"></a>情况十： RUNNABLE &lt;–&gt; TERMINATED</h3><p>当前线<strong>程所有代码运行完毕</strong>，进入 TERMINATED</p>
<h2 id="10-多把锁"><a href="#10-多把锁" class="headerlink" title="10. 多把锁"></a>10. 多把锁</h2><h3 id="10-1-多把锁"><a href="#10-1-多把锁" class="headerlink" title="10.1 多把锁"></a>10.1 多把锁</h3><p>将锁的粒度细分，提供多个对象锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BigRoom</span> &#123;<br>    <span class="hljs-comment">//额外创建对象来作为锁</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">studyRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">bedRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>好处，是可以增强并发度</li>
<li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li>
</ul>
<h3 id="10-2-活跃性"><a href="#10-2-活跃性" class="headerlink" title="10.2 活跃性"></a>10.2 活跃性</h3><p>因为某种原因，使得代码<strong>一直无法执行完毕</strong>，这样的现象叫做活跃性。常见的活跃性情况为：死锁、活锁、饥饿</p>
<h3 id="10-3-死锁"><a href="#10-3-死锁" class="headerlink" title="10.3 死锁"></a>10.3 死锁</h3><p>一个线程需要<strong>同时获取多把锁</strong>，这时就容易发生死锁</p>
<p>发生死锁的必要条件</p>
<ul>
<li>互斥条件：在一段时间内，一种资源只能被一个进程所使用</li>
<li>请求和保持条件：进程已经拥有了至少一种资源，同时又去申请其他资源。因为其他资源被别的进程所使用，该进程进入阻塞状态，并且不释放自己已有的资源</li>
<li>不可抢占条件：进程对已获得的资源在未使用完成前不能被强占，只能在进程使用完后自己释放</li>
<li>循环等待条件：发生死锁时，必然存在一个进程——资源的循环链</li>
</ul>
<p>如：t1线程获得A对象锁，接下来想获取B对象的锁，t2线程获得B对象锁，接下来想获取A对象的锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;info&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLockTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span> (A)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                    log.debug(<span class="hljs-string">&quot;t1运行&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;t1尝试获得锁B&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (B)&#123;<br><br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span> (B)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    log.debug(<span class="hljs-string">&quot;t2运行&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;t2尝试获得锁A&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (A)&#123;<br><br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">15:50:24.969 [t2] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - t2运行<br>15:50:24.971 [t2] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - t2尝试获得锁A<br>15:50:25.953 [t1] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - t1运行<br>15:50:25.953 [t1] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - t1尝试获得锁B<br><br>程序未结束<br></code></pre></td></tr></table></figure>



<p><strong>定位死锁的方法</strong></p>
<ul>
<li><p>先用JPS定位ThreadID，再用<code>jstack ThreadID</code>可以查看线程状态</p>
  <figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs smali">PS D:\codework\Java\IDEA\JavaSE_learn\out\production\Other&gt; jps<br>47776 DeadLockTest<br>34264 Launcher<br>37560 RemoteMavenServer36<br>37624<br>17052 Jps<br><br>PS D:\codework\Java\IDEA\JavaSE_learn\out\production\Other&gt; jstack 47776<br><span class="hljs-keyword">.</span>.....<br>Found one Java-level deadlock:<br>=============================<br><span class="hljs-string">&quot;t1&quot;</span>:<br>  waiting to lock<span class="hljs-built_in"> monitor </span>0x000001f3c0bf6bd0 (object 0x00000007116e7530, a java.lang.Object),<br>  which is held by <span class="hljs-string">&quot;t2&quot;</span><br><br><span class="hljs-string">&quot;t2&quot;</span>:<br>  waiting to lock<span class="hljs-built_in"> monitor </span>0x000001f3c0bf78f0 (object 0x00000007116e7520, a java.lang.Object),<br>  which is held by <span class="hljs-string">&quot;t1&quot;</span><br><br>Java stack information for the threads listed above:<br>===================================================<br><span class="hljs-keyword">.</span>.....<br></code></pre></td></tr></table></figure>
</li>
<li><p>jconsole检测死锁：打开jconsole-连接线程-线程选项卡-检测死锁-死锁选项卡</p>
<p>  <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java/JUC/Jconsole%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81.png" srcset="/img/loading.gif" lazyload alt="image-20220522155630192"></p>
</li>
</ul>
<p><strong>避免死锁的方法</strong></p>
<ul>
<li><p>在线程使用锁对象时<strong>，顺序加锁</strong>（如上面的例子可以让两个线程都先持有A对象锁，再去持有B对象锁）即可避免死锁，不过也<strong>会导致饥饿</strong>问题，可以使用Hash值的大小来确定加锁的先后</p>
</li>
<li><p>尽可能缩减加锁的范围, 等到操作共享变量的时候才加锁</p>
</li>
<li><p>使用可释放的定时锁 (一段时间申请不到锁的权限了, 直接释放掉)</p>
</li>
</ul>
<h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><p>有五位哲学家，围坐在圆桌旁。他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。如果筷子被身边的人拿着，自己就得等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhilosopherEating</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;2&quot;</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;3&quot;</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;4&quot;</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;5&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;苏格拉底&quot;</span>, c1, c2).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;柏拉图&quot;</span>, c2, c3).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;亚里士多德&quot;</span>, c3, c4).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;赫拉克利特&quot;</span>, c4, c5).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;阿基米德&quot;</span>, c5, c1).start();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 哲学家类</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    Chopstick left;<br>    Chopstick right;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Philosopher</span><span class="hljs-params">(String name, Chopstick left, Chopstick right)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;eating...&quot;</span>);<br>        Sleeper.sleep(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 获得左手筷子</span><br>            <span class="hljs-keyword">synchronized</span> (left) &#123;<br>                <span class="hljs-comment">// 获得右手筷子</span><br>                <span class="hljs-keyword">synchronized</span> (right) &#123;<br>                    <span class="hljs-comment">// 吃饭</span><br>                    eat();<br>                &#125;<br>                <span class="hljs-comment">// 放下右手筷子</span><br>            &#125;<br>            <span class="hljs-comment">// 放下左手筷子</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 筷子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chopstick</span> &#123;<br>    String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chopstick</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;筷子&#123;&quot;</span> + name + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行不多会，就执行不下去了，使用 jconsole 检测死锁，发现</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">-------------------------------------------------------------------------</span><br><span class="hljs-code">名称: 阿基米德</span><br><span class="hljs-code">状态: cn.itcast.Chopstick@1540e19d (筷子1) 上的BLOCKED, 拥有者: 苏格拉底</span><br><span class="hljs-code">总阻止数: 2, 总等待数: 1</span><br><span class="hljs-code">堆栈跟踪:</span><br><span class="hljs-code">cn.itcast.Philosopher.run(TestDinner.java:48)</span><br><span class="hljs-code">- 已锁定 cn.itcast.Chopstick@6d6f6e28 (筷子5)</span><br><span class="hljs-code">-------------------------------------------------------------------------</span><br>名称: 苏格拉底<br>状态: cn.itcast.Chopstick@677327b6 (筷子2) 上的BLOCKED, 拥有者: 柏拉图<br>总阻止数: 2, 总等待数: 1<br>堆栈跟踪:<br>cn.itcast.Philosopher.run(TestDinner.java:48)<br><span class="hljs-section">- 已锁定 cn.itcast.Chopstick@1540e19d (筷子1)</span><br><span class="hljs-section">-------------------------------------------------------------------------</span><br>名称: 柏拉图<br>状态: cn.itcast.Chopstick@14ae5a5 (筷子3) 上的BLOCKED, 拥有者: 亚里士多德<br>总阻止数: 2, 总等待数: 0<br>堆栈跟踪:<br>cn.itcast.Philosopher.run(TestDinner.java:48)<br><span class="hljs-section">- 已锁定 cn.itcast.Chopstick@677327b6 (筷子2)</span><br><span class="hljs-section">-------------------------------------------------------------------------</span><br>名称: 亚里士多德<br>状态: cn.itcast.Chopstick@7f31245a (筷子4) 上的BLOCKED, 拥有者: 赫拉克利特<br>总阻止数: 1, 总等待数: 1<br>堆栈跟踪:<br>cn.itcast.Philosopher.run(TestDinner.java:48)<br><span class="hljs-section">- 已锁定 cn.itcast.Chopstick@14ae5a5 (筷子3)</span><br><span class="hljs-section">-------------------------------------------------------------------------</span><br>名称: 赫拉克利特<br>状态: cn.itcast.Chopstick@6d6f6e28 (筷子5) 上的BLOCKED, 拥有者: 阿基米德<br>总阻止数: 2, 总等待数: 0<br>堆栈跟踪:<br>cn.itcast.Philosopher.run(TestDinner.java:48)<br><span class="hljs-bullet">- </span>已锁定 cn.itcast.Chopstick@7f31245a (筷子4)<br></code></pre></td></tr></table></figure>



<h3 id="4-活锁"><a href="#4-活锁" class="headerlink" title="(4) 活锁"></a>(4) 活锁</h3><p>活锁出现在两个线程<strong>互相改变对方的结束条件</strong>，谁也无法结束。活锁区别死锁在于：活锁一直在运行</p>
<p>下面的代码中，线程1一直–，减到0才退出，线程2一直++，加到20才退出，互相改变对方的结束条件，谁也无法结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j(topic = &quot;info&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LiveLockTest</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 期望减到 0 退出循环</span><br>            <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>                Sleeper.sleep(<span class="hljs-number">0.2</span>);<br>                count--;<br>                log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 期望超过 20 退出循环</span><br>            <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">20</span>) &#123;<br>                Sleeper.sleep(<span class="hljs-number">0.2</span>);<br>                count++;<br>                log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>避免活锁的方法</strong>：</p>
<ul>
<li>在线程执行时，中途给予<strong>不同的间隔时间</strong>即可。（上面的例子中，让线程2sleep时间改为1s）</li>
</ul>
<h3 id="5-饥饿"><a href="#5-饥饿" class="headerlink" title="(5) 饥饿"></a>(5) 饥饿</h3><p>一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束</p>
<p>演示，将之前哲学家问题改一下，改成顺序持有筷子，比如将阿基米德线程拿筷子为c1 c5，</p>
<p>让死锁不发生，用jconsole检测会发现不存在死锁，但从结果上来看，一直是 [赫拉克利特] 和 [亚里士多德] 在运行，其他线程没怎么运行，这就是饥饿现象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>    <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;2&quot;</span>);<br>    <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;3&quot;</span>);<br>    <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;4&quot;</span>);<br>    <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;5&quot;</span>);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;苏格拉底&quot;</span>, c1, c2).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;柏拉图&quot;</span>, c2, c3).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;亚里士多德&quot;</span>, c3, c4).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;赫拉克利特&quot;</span>, c4, c5).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;阿基米德&quot;</span>, c5, c1).start();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros">16:16:46.044 [苏格拉底] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - eating<span class="hljs-built_in">..</span>.<br>16:16:46.044 [亚里士多德] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - eating<span class="hljs-built_in">..</span>.<br>16:16:47.048 [亚里士多德] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - eating<span class="hljs-built_in">..</span>.<br>16:16:47.050 [苏格拉底] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - eating<span class="hljs-built_in">..</span>.<br>16:16:48.049 [亚里士多德] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - eating<span class="hljs-built_in">..</span>.<br>16:16:49.052 [亚里士多德] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - eating<span class="hljs-built_in">..</span>.<br>16:16:50.063 [赫拉克利特] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - eating<span class="hljs-built_in">..</span>.<br>16:16:51.063 [赫拉克利特] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - eating<span class="hljs-built_in">..</span>.<br>16:16:52.073 [赫拉克利特] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - eating<span class="hljs-built_in">..</span>.<br>16:16:53.086 [赫拉克利特] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - eating<span class="hljs-built_in">..</span>.<br>16:16:54.100 [赫拉克利特] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - eating<span class="hljs-built_in">..</span>.<br>16:16:55.110 [赫拉克利特] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - eating<span class="hljs-built_in">..</span>.<br><span class="hljs-built_in">..</span>.<br>后面一直是 [赫拉克利特] <br></code></pre></td></tr></table></figure>





<h2 id="11-ReentrantLock"><a href="#11-ReentrantLock" class="headerlink" title="11. ReentrantLock"></a>11. ReentrantLock</h2><p>ReentrantLock属于JUC下面一个类，为了与Synchronized对比，在这里提前学习</p>
<p><strong>和synchronized相比具有的的特点</strong></p>
<ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置为公平锁 (先到先得)</li>
<li>支持多个条件变量( 具有<strong>多个</strong>waitset)</li>
<li>与 synchronized 一样，都支持可重入</li>
</ul>
<h3 id="11-1-基本语法"><a href="#11-1-基本语法" class="headerlink" title="11.1 基本语法"></a>11.1 基本语法</h3><p>ReentrantLock是在对象层建立，synchronized是在关键字级别对临界区进行保护</p>
<p><strong>lock和unlock必须成对出现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取ReentrantLock对象</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-comment">//加锁（放在try里外都可以）</span><br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>	<span class="hljs-comment">//需要执行的代码</span><br>&#125;<span class="hljs-keyword">finally</span> &#123;<br>	<span class="hljs-comment">//释放锁</span><br>	lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>



<p>ReentrantLock的特点：</p>
<h3 id="11-2-可重入"><a href="#11-2-可重入" class="headerlink" title="11.2 可重入"></a>11.2 可重入</h3><p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁。reentrantlock和synchronized都是可重入的</p>
<p>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</p>
<p>如下代码中，主线程层层调用，创建了多个栈帧，有权利多次获取同一把锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;info&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLockTest</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        method1();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;execute method1&quot;</span>);<br>            method2();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;execute method2&quot;</span>);<br>            method3();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;execute method3&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smali">22:06:17.097 [main] DEBUG info -<span class="hljs-built_in"> execute </span>method1<br>22:06:17.099 [main] DEBUG info -<span class="hljs-built_in"> execute </span>method2<br>22:06:17.099 [main] DEBUG info -<span class="hljs-built_in"> execute </span>method3<br></code></pre></td></tr></table></figure>



<h3 id="11-3-可打断"><a href="#11-3-可打断" class="headerlink" title="11.3 可打断"></a>11.3 可打断</h3><p>可打断是指在等待锁的过程中，其他线程可以用interrupt方法终止等待。之前的Synchronized就是不可打断的，所以可能会造成死锁，现在reentrantLock是可打断的，出现死锁让其他线程调用interrupt即可</p>
<p>处于阻塞状态的线程，被打断了就不用阻塞了，直接停止运行。这样就不会出现死等的情况。显然可打断比不可打断要更灵活。可打断是用<code>lock.lockInterruptibly()</code>，reentrantLock.lock都是不可打断的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;t1启动...&quot;</span>);<br>            lock.lockInterruptibly();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>            log.debug(<span class="hljs-string">&quot;等锁的过程中被打断&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>    lock.lock();<br>    log.debug(<span class="hljs-string">&quot;main 获得了锁&quot;</span>);<br>    t1.start();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Sleeper.sleep(<span class="hljs-number">1</span>);<br>        t1.interrupt();<br>        log.debug(<span class="hljs-string">&quot;main 执行打断&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>        log.debug(<span class="hljs-string">&quot;main 释放了锁&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">12:14:25.367 [main] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - main 获得了锁<br>12:14:25.369 [t1] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - t1启动<span class="hljs-built_in">..</span>.<br>12:14:26.373 [main] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - main 执行打断<br>12:14:26.373 [main] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - main 释放了锁<br>12:14:26.375 [t1] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 等锁的过程中被打断<br>java.lang.InterruptedException<br>	at <span class="hljs-built_in">..</span>.<br></code></pre></td></tr></table></figure>



<h3 id="11-4-锁超时"><a href="#11-4-锁超时" class="headerlink" title="11.4 锁超时"></a>11.4 锁超时</h3><p>上面的可打断特性是被动地等待其他线程打断当前线程地等待，而不是主动的，使用<code>lock.tryLock()</code>方法会返回获取锁是否成功。如果成功则返回true，反之则返回false。</p>
<p>并且tryLock方法可以<strong>指定等待时间</strong>，参数为：<code>tryLock(long timeout, TimeUnit unit)</code>, 其中timeout为最长等待时间，TimeUnit为时间单位</p>
<p><strong>简而言之</strong>就是：获取失败了、获取超时了或者被打断了，不再阻塞，直接停止运行</p>
<p>不设置等待时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;t1 启动...&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!lock.tryLock()) &#123;<br>            log.debug(<span class="hljs-string">&quot;获取立刻失败，返回&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>    lock.lock();<br>    log.debug(<span class="hljs-string">&quot;main 获得了锁&quot;</span>);<br>    t1.start();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Sleeper.sleep(<span class="hljs-number">2</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">12:20:26.984 [main] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - main 获得了锁<br>12:20:26.986 [t1] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - t1 启动<span class="hljs-built_in">..</span>.<br>12:20:26.986 [t1] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 获取立刻失败，返回<br></code></pre></td></tr></table></figure>



<p>设置等待时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;t1 启动...&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (!lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;<br>                log.debug(<span class="hljs-string">&quot;t1 获取等待 1s 后失败，返回&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;t1 获得了锁&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>    lock.lock();<br>    log.debug(<span class="hljs-string">&quot;main 获得了锁&quot;</span>);<br>    t1.start();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Sleeper.sleep(<span class="hljs-number">2</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">12:22:25.331 [main] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - main 获得了锁<br>12:22:25.333 [t1] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - t1 启动<span class="hljs-built_in">..</span>.<br>12:22:26.342 [t1] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - t1 获取等待 1s 后失败，返回<br></code></pre></td></tr></table></figure>



<h3 id="11-5-公平锁"><a href="#11-5-公平锁" class="headerlink" title="11.5 公平锁"></a>11.5 公平锁</h3><p>线程获取锁失败，进入阻塞队列时，<strong>先进入</strong>的会在锁被释放后<strong>先获得</strong>锁。这样的获取方式就是<strong>公平</strong>的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//默认是不公平锁，需要在创建时指定为公平锁</span><br><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure>

<p>一般不设置ReentrantLock为公平的，会降低并发度</p>
<h3 id="11-6-条件变量"><a href="#11-6-条件变量" class="headerlink" title="11.6 条件变量"></a>11.6 条件变量</h3><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入waitSet 等待</p>
<p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持<strong>多个</strong>条件变量的，这就好比</p>
<ul>
<li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li>
<li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒，这样就不用像wait-notify机制那样，必须要使用notifyall去全部唤醒，否则会出现虚假唤醒</li>
</ul>
<p>创建condition对象的方法如下，必须要绑定lock锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-type">Condition</span> <span class="hljs-variable">condition1</span> <span class="hljs-operator">=</span> lock.newCondition();<br><span class="hljs-type">Condition</span> <span class="hljs-variable">condition2</span> <span class="hljs-operator">=</span> lock.newCondition();<br></code></pre></td></tr></table></figure>

<p>条件变量（等待室）的等待和唤醒方法为：</p>
<p><code>condition.await()</code>：等待</p>
<p>&#96;&#96;condition.signal()&#96;：唤醒条件变量（等待室）中的<strong>一个</strong>线程</p>
<p><code>condition.signalAll()</code>： 唤醒条件变量（等待室）中的<strong>所有</strong>线程</p>
<p>使用要点：</p>
<ul>
<li><code>condition.await()</code>前需要<strong>获得锁</strong><code>lock.lock();</code></li>
<li>await 执行后，会释放锁，进入 conditionObject 等待</li>
<li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li>
<li>竞争 lock 锁成功后，从 await 后继续执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLockTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasCigarette</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasTakeout</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-comment">// 等待烟的休息室</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">waitCigaretteSet</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-comment">// 等外卖的休息室</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">waitTakeoutSet</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>                <span class="hljs-keyword">while</span> (!hasCigarette) &#123;<br>                    log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 此时小南进入到 等烟的休息室</span><br>                        waitCigaretteSet.await();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;烟来咯, 可以开始干活了&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;小南&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);<br>                <span class="hljs-keyword">while</span> (!hasTakeout) &#123;<br>                    log.debug(<span class="hljs-string">&quot;没外卖，先歇会！&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 此时小女进入到 等外卖的休息室</span><br>                        waitTakeoutSet.await();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;外卖来咯, 可以开始干活了&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;小女&quot;</span>).start();<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;送外卖的来咯~&quot;</span>);<br>                hasTakeout = <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">// 唤醒等外卖的小女线程</span><br>                waitTakeoutSet.signal();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;送外卖的&quot;</span>).start();<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;送烟的来咯~&quot;</span>);<br>                hasCigarette = <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">// 唤醒等烟的小南线程</span><br>                waitCigaretteSet.signal();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;送烟的&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">12:35:07.726 [小南] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 有烟没？[<span class="hljs-literal">false</span>]<br>12:35:07.739 [小南] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 没烟，先歇会！<br>12:35:07.739 [小女] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 外卖送到没？[<span class="hljs-literal">false</span>]<br>12:35:07.739 [小女] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 没外卖，先歇会！<br>12:35:08.739 [送外卖的] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 送外卖的来咯~<br>12:35:08.740 [小女] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 外卖来咯, 可以开始干活了<br>12:35:09.750 [送烟的] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 送烟的来咯~<br>12:35:09.750 [小南] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 烟来咯, 可以开始干活了<br></code></pre></td></tr></table></figure>



<h3 id="11-7-总结"><a href="#11-7-总结" class="headerlink" title="11.7 总结"></a>11.7 总结</h3><p>基本语法及可重入：<code>ReentrantLock lock = new ReentrantLock(); lock.lock(); lock.unlock(); </code></p>
<p>可打断：<code>ReentrantLock lock = new ReentrantLock(); lock.lockInterruptibly(); lock.unlock(); </code></p>
<p>锁超时：<code>ReentrantLock lock = new ReentrantLock(); lock.tryLock(long timeout, TimeUnit unit); lock.unlock(); </code></p>
<p>条件变量：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">ReentrantLock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock();<br>Condition condition1 = <span class="hljs-keyword">lock</span>.newCondition();<br><span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br>condition.<span class="hljs-keyword">await</span>()<br>condition.signal()/condition.signalAll()<br></code></pre></td></tr></table></figure>



<h2 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a>同步模式之顺序控制</h2><h3 id="顺序输出"><a href="#顺序输出" class="headerlink" title="顺序输出"></a>顺序输出</h3><p>假如有两个线程, 线程A打印1, 线程B打印2。要求: <strong>程序先打印2，再打印1</strong></p>
<p>三种方法：</p>
<ul>
<li>Wait&#x2F;Notify版本实现</li>
<li>使用ReentrantLock的await&#x2F;signal</li>
<li>使用LockSupport中的park&#x2F;unpart</li>
</ul>
<h4 id="Wait-x2F-Notify版本实现"><a href="#Wait-x2F-Notify版本实现" class="headerlink" title="Wait&#x2F;Notify版本实现"></a>Wait&#x2F;Notify版本实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SyncPrintWaitTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-comment">// t2线程释放执行过</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">t2Runned</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">while</span> (!t2Runned) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                    	<span class="hljs-comment">// 进入等待(waitset), 会释放锁</span><br>                        lock.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>                t2Runned = <span class="hljs-literal">true</span>;<br>                lock.notify();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">23:05:17.852 [t2] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 2<br>23:05:17.854 [t1] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - 1<br></code></pre></td></tr></table></figure>



<h4 id="使用ReentrantLock的await-x2F-signal"><a href="#使用ReentrantLock的await-x2F-signal" class="headerlink" title="使用ReentrantLock的await&#x2F;signal"></a>使用ReentrantLock的await&#x2F;signal</h4><p>和上面类似，代码省略</p>
<h4 id="使用LockSupport中的park-x2F-unpart"><a href="#使用LockSupport中的park-x2F-unpart" class="headerlink" title="使用LockSupport中的park&#x2F;unpart"></a>使用LockSupport中的park&#x2F;unpart</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SyncPrintWaitTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            LockSupport.park();<br>            log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>            LockSupport.unpark(t1);<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h3><p>线程1 输出 a 5次, 线程2 输出 b 5次, 线程3 输出 c 5次。现在要求输出 abcabcabcabcabcabc</p>
<h4 id="wait-x2F-notify版本"><a href="#wait-x2F-notify版本" class="headerlink" title="wait&#x2F;notify版本"></a>wait&#x2F;notify版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestWaitNotify</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">WaitNotify</span> <span class="hljs-variable">waitNotify</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitNotify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            waitNotify.print(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        &#125;, <span class="hljs-string">&quot;a线程&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            waitNotify.print(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>        &#125;, <span class="hljs-string">&quot;b线程&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            waitNotify.print(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br>        &#125;, <span class="hljs-string">&quot;c线程&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNotify</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> flag;<br>    <br>    <span class="hljs-comment">// 循环次数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNumber;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WaitNotify</span><span class="hljs-params">(<span class="hljs-type">int</span> flag, <span class="hljs-type">int</span> loopNumber)</span> &#123;<br>		<span class="hljs-built_in">this</span>.flag = flag;<br>		<span class="hljs-built_in">this</span>.loopNumber = loopNumber;<br>	&#125;<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        输出内容    等待标记    下一个标记</span><br><span class="hljs-comment">        a           1          2</span><br><span class="hljs-comment">        b           2          3</span><br><span class="hljs-comment">        c           3          1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str, <span class="hljs-type">int</span> waitFlag, <span class="hljs-type">int</span> nextFlag)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-keyword">while</span> (waitFlag != <span class="hljs-built_in">this</span>.flag) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-built_in">this</span>.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.print(str);<br>                <span class="hljs-built_in">this</span>.flag = nextFlag;<br>                <span class="hljs-built_in">this</span>.notifyAll();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">abcabcabcabcabc</span><br></code></pre></td></tr></table></figure>



<h4 id="await-x2F-signal版本"><a href="#await-x2F-signal版本" class="headerlink" title="await&#x2F;signal版本"></a>await&#x2F;signal版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestAwaitSignal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">AwaitSignal</span> <span class="hljs-variable">awaitSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AwaitSignal</span>(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">a_condition</span> <span class="hljs-operator">=</span> awaitSignal.newCondition();<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">b_condition</span> <span class="hljs-operator">=</span> awaitSignal.newCondition();<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">c_condition</span> <span class="hljs-operator">=</span> awaitSignal.newCondition();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            awaitSignal.print(<span class="hljs-string">&quot;a&quot;</span>, a_condition, b_condition);<br>        &#125;, <span class="hljs-string">&quot;a&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            awaitSignal.print(<span class="hljs-string">&quot;b&quot;</span>, b_condition, c_condition);<br>        &#125;, <span class="hljs-string">&quot;b&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            awaitSignal.print(<span class="hljs-string">&quot;c&quot;</span>, c_condition, a_condition);<br>        &#125;, <span class="hljs-string">&quot;c&quot;</span>).start();<br><br>        awaitSignal.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            a_condition.signal();  <span class="hljs-comment">//首先唤醒a线程</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            awaitSignal.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AwaitSignal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> loopNumber;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AwaitSignal</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        <span class="hljs-built_in">this</span>.loopNumber = loopNumber;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str, Condition condition, Condition next)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    condition.await();<br>                    <span class="hljs-comment">//System.out.print(&quot;i:===&quot;+i);</span><br>                    System.out.print(str);<br>                    next.signal();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="park-x2F-unpark实现"><a href="#park-x2F-unpark实现" class="headerlink" title="park&#x2F;unpark实现"></a>park&#x2F;unpark实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestParkUnpark</span> &#123;<br>    <span class="hljs-keyword">static</span> Thread a;<br>    <span class="hljs-keyword">static</span> Thread b;<br>    <span class="hljs-keyword">static</span> Thread c;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ParkUnpark</span> <span class="hljs-variable">parkUnpark</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParkUnpark</span>(<span class="hljs-number">5</span>);<br><br>        a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            parkUnpark.print(<span class="hljs-string">&quot;a&quot;</span>, b);<br>        &#125;, <span class="hljs-string">&quot;a&quot;</span>);<br><br>        b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            parkUnpark.print(<span class="hljs-string">&quot;b&quot;</span>, c);<br>        &#125;, <span class="hljs-string">&quot;b&quot;</span>);<br><br>        c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            parkUnpark.print(<span class="hljs-string">&quot;c&quot;</span>, a);<br>        &#125;, <span class="hljs-string">&quot;c&quot;</span>);<br><br>        a.start();<br>        b.start();<br>        c.start();<br><br>        <span class="hljs-comment">// 从a先唤醒</span><br>        LockSupport.unpark(a);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParkUnpark</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> loopNumber;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ParkUnpark</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        <span class="hljs-built_in">this</span>.loopNumber = loopNumber;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str, Thread nextThread)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            LockSupport.park();<br>            System.out.print(str);<br>            LockSupport.unpark(nextThread);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h1 id="四、内存"><a href="#四、内存" class="headerlink" title="四、内存"></a>四、内存</h1><p>上一章讲解的 Monitor 主要关注的是访问共享变量时，保证临界区代码的原子性。这一章我们进一步深入学习共享变量在多线程间的【可见性】问题与多条指令执行时的【有序性】问题</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%BB%91%E9%A9%AC%E8%A7%86%E9%A2%91%E7%AC%AC%E4%BA%94%E7%AB%A0%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93.png" srcset="/img/loading.gif" lazyload alt="image-20220121224206151"></p>
<h2 id="1-Java-内存模型（JMM）"><a href="#1-Java-内存模型（JMM）" class="headerlink" title="1. Java 内存模型（JMM）"></a>1. Java 内存模型（JMM）</h2><p>JMM 即 Java Memory Model，它定义了<strong>主存（共享内存）、工作内存（线程私有）</strong>抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。</p>
<p><strong>JMM体现在以下几个方面</strong></p>
<ul>
<li>原子性 - 保证指令不会受到线程上下文切换的影响</li>
<li>可见性 - 保证指令不会受 cpu 缓存（工作内存中的一部分）的影响</li>
<li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li>
</ul>
<h2 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h2><p>引例：退不出的循环</p>
<p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-keyword">while</span> (run) &#123;<br>            <span class="hljs-comment">//如果run为真，则一直执行</span><br>        &#125;<br>    &#125;).start();<br><br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    System.out.println(<span class="hljs-string">&quot;改变run的值为false&quot;</span>);<br>    run = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>为什么无法退出该循环</strong></p>
<ul>
<li>初始状态， t 线程刚开始从<strong>主内存</strong>读取了 run 的值到<strong>工作内存</strong></li>
<li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值<strong>缓存至自己工作内存</strong>中的<strong>高速缓存</strong>中， 减少对主存中 run 的访问，提高效率</li>
<li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是<strong>旧值</strong>。即对主存的修改对线程来说是<strong>不可见</strong>的。</li>
</ul>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%BB%E5%AD%98%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98.png" srcset="/img/loading.gif" lazyload alt="image-20220121221529370"></p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>解决上述问题可以使用如下方法：</p>
<ul>
<li><p>使用volatile易变关键字（jdk5之后）</p>
<ul>
<li><p>它可以用来修饰<strong>成员变量</strong>和<strong>静态成员变量</strong>（放在主存中的变量），可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是<strong>直接操作主存</strong>。不用来修饰局部变量，因为局部变量不是共享的，是线程私有的。</p>
</li>
<li><p>volatile保证可见性的原理见后续内存屏障部分</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>创建一个同步块然后加锁，也能保证可见性。但这个操作属于重量级操作，性能较低。</p>
</li>
</ul>
<h3 id="可见性与原子性"><a href="#可见性与原子性" class="headerlink" title="可见性与原子性"></a>可见性与原子性</h3><ul>
<li>前面例子体现的实际就是<strong>可见性</strong>，它保证的是在多个线程之间，一个线程对volatile变量的修改对另一个线程可见，但并不能解决指令交错问题，即不能保证原子性，仅用在<strong>一个写线程，多个读线程</strong>的情况</li>
</ul>
<ul>
<li>synchronized 语句块既可以保证代码块的<strong>原子性</strong>，也同时保证代码块内变量的<strong>可见性</strong>。但缺点是 synchronized 是属于<strong>重量级</strong>操作，性能相对更低。</li>
</ul>
<p>思考：如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run 变量的修改了，想一想为什么？</p>
<p>回答：因为System.out.println()使用了<strong>synchronized</strong>关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">println</span><span class="hljs-params">(String x)</span> &#123;<br>    <span class="hljs-comment">//使用了synchronized关键字</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        print(x);<br>        newLine();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="两阶终止模式优化"><a href="#两阶终止模式优化" class="headerlink" title="两阶终止模式优化"></a>两阶终止模式优化</h3><p>volatile应用的例子</p>
<h3 id="同步模式之犹豫模式"><a href="#同步模式之犹豫模式" class="headerlink" title="同步模式之犹豫模式"></a>同步模式之犹豫模式</h3><p>使用volatile并不能解决问题，涉及到一个线程既读又写的情况，需要使用加锁</p>
<h2 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性"></a>3. 有序性</h2><p>引入知识：指令重排</p>
<ul>
<li>现代处理器会设计为一个时钟周期完成一条执行时间长的 CPU 指令。为什么这么做呢？可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为： <strong>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</strong> 这5 个阶段。在不改变程序结果的前提下，这些指令的各个阶段可以通过<strong>重排序</strong>和<strong>组合</strong>来实现<strong>指令级并行</strong>。现代 CPU 支持多级<strong>指令流水线</strong>，例如支持<strong>同时</strong>执行 <strong>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</strong> 的处理器，就可以称之为五级指令流水线。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一条执行时间长的复杂指令），IPC &#x3D; 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地<strong>吞吐率</strong>。</li>
</ul>
<h3 id="指令重排导致的多线程错误"><a href="#指令重排导致的多线程错误" class="headerlink" title="指令重排导致的多线程错误"></a>指令重排导致的多线程错误</h3><p>JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，这种特性称之为『指令重排』，是JIT 编译器在运行时的一些优化。但在多线程环境下，指令重排序可能导致出现意料之外的结果。</p>
<p>下面代码中，actor2如果是先执行<code>ready = true;</code>，那么actor1的结果就变了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// volatile 修饰的变量，可以禁用指令重排 volatile boolean ready = false; 可以防止变量之前的代码被重排序</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <br><br><span class="hljs-comment">// 线程1 执行此方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;<br>	 <span class="hljs-keyword">if</span>(ready) &#123;<br>	 	r.r1 = num + num;<br>	 &#125; <br>	 <span class="hljs-keyword">else</span> &#123;<br>	 	r.r1 = <span class="hljs-number">1</span>;<br>	 &#125;<br>&#125;<br><span class="hljs-comment">// 线程2 执行此方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;<br>	 num = <span class="hljs-number">2</span>;<br>	 ready = <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这个现象需要通过大量测试才能复现，可以使用<code>jcstress工具</code>进行压力测试。这部分略过</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>volatile</strong> 修饰的变量，可以<strong>禁用</strong>指令重排</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>防止变量之前的代码被重排序</li>
</ul>
<h2 id="4-volatile原理：内存屏障"><a href="#4-volatile原理：内存屏障" class="headerlink" title="4. volatile原理：内存屏障"></a>4. volatile原理：内存屏障</h2><p>volatile的底层实现原理是<strong>内存屏障</strong>，Memory Barrier（Memory Fence）</p>
<ul>
<li>对 volatile 变量的<strong>写指令后</strong>会加入写屏障</li>
<li>对 volatile 变量的<strong>读指令前</strong>会加入读屏障</li>
</ul>
<h3 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h3><ul>
<li>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</li>
<li>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中新数据</li>
</ul>
<h3 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h3><ul>
<li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li>
<li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li>
</ul>
<p><strong>但是不能解决指令交错问题 (不能解决原子性)，可以使用<code>synchronized</code>来解决原子性</strong></p>
<ul>
<li>写屏障仅仅是保证之后的读能够读到新的结果，但不能保证读跑到它前面去</li>
<li>而有序性的保证也只是保证了<strong>本线程内</strong>相关代码不被重排序</li>
</ul>
<h2 id="5-double-checked-locking-双重检查锁-问题"><a href="#5-double-checked-locking-双重检查锁-问题" class="headerlink" title="5.  double-checked locking (双重检查锁) 问题"></a>5.  double-checked locking (双重检查锁) 问题</h2><p>synchronized可以保证它的临界区的资源是 <strong>原子性、可见性、有序性</strong>的</p>
<p>有序性的前提是，在synchronized代码块中的共享变量，不会在代码块外使用到，否则有序性不能被保证，只能使用volatile来保证有序性。下面代码的双重检查单例模式，就出现了这个问题（在synchronized外使用到了INSTANCE）, 此时synchronized就不能防止指令重排, 确保不了指令的有序性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 最开始的单例模式是这样的</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>	    <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;<br>	    	<span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t1</span><br>	    		INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>	        &#125;<br>	    &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码原本的核心思想是<strong>懒汉模式</strong>，即用到时再创建对象，所以对<code>INSTANCE</code>进行判断，如果没有再创建，如果有直接返回。但在多线程同时调用<code>getInstance()</code>时，如果不加synchronized锁，此时两个线程同时判断INSTANCE为空，此时都会new Singleton()，此时就破坏单例了，所以要加锁，防止多线程操作共享资源，造成的安全问题</p>
<p>但上面存在的问题是不同的线程每调用一次<code>getInstance()</code>就会加一次锁，造成性能浪费。所以要双重检查，在加锁前再判断一次<code>if (INSTANCE == null)</code>，如果已经有单例对象，此时就不会再去同步块中获取锁了，提高效率</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t2</span><br>            <span class="hljs-comment">// 首次访问会同步，而之后的使用没有 synchronized</span><br>            <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t1</span><br>                    INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但改进后的代码还是存在问题，<code>if(INSTANCE == null)</code>判断代码没有在同步代码块synchronized中，不能享有synchronized保护有序性，所以可能会导致 <strong>指令重排</strong>。</p>
<p><strong>synchronized确实能够保护同步代码块中共享变量的原子性、可见性、有序性，但前提必须是共享变量都交给synchronized保护，</strong>像上面这种有部分不在synchronized保护范围内的，就可能导致问题。</p>
<p>解决方案：使用volatile关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure>

<p>具体怎么解决需要从字节码角度分析，暂时略过</p>
<h2 id="6-happens-before"><a href="#6-happens-before" class="headerlink" title="6. happens-before"></a>6. happens-before</h2><p>happens-before 规定了<code>对共享变量的写操作,对其它线程的读操作可见</code>，它是可见性与有序性的一套规则总结。<strong>抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见。</strong>变量都是指成员变量或静态成员变量</p>
<ul>
<li><p><strong>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的 读可见</strong>。原因：synchronized锁，保证了可见性</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> x;<br><br><span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    <span class="hljs-keyword">synchronized</span>(m) &#123;<br>        x = <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    <span class="hljs-keyword">synchronized</span>(m) &#123;<br>        System.out.println(x);<br>    &#125;<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br><br><span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</strong>。原因：volatile修饰的变量, 通过写屏障, 共享到主存中, 其他线程通过读屏障, 读取主存的数据</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> x;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    x = <span class="hljs-number">10</span>;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    System.out.println(x);<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>线程 start() 前对变量的写，对该线程开始后对该变量的读可见</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> x;<br>x = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    System.out.println(x);<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>线程结束前对变量的写，对其它线程得知它结束后的读可见</strong>。（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> x;<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    x = <span class="hljs-number">10</span>;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br><br>t1.join();<br>System.out.println(x);<br></code></pre></td></tr></table></figure>
</li>
<li><p>线程 t1 打断 t2(interrupt)前对变量的写，对于其他线程得知 t2 被打断后, 对变量的读可见</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;<br>                System.out.println(x); <span class="hljs-comment">// 10, 打断了, 读取的也是打断前修改的值</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br>    t2.start(); <br><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        x = <span class="hljs-number">10</span>;<br>        t2.interrupt();<br>    &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>    <span class="hljs-keyword">while</span>(!t2.isInterrupted()) &#123;<br>        Thread.yield();<br>    &#125;<br>    System.out.println(x);	<span class="hljs-comment">// 10</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>对变量默认值（0，false，null）的写，对其它线程对该变量的 读可见</strong> (最基本)</p>
</li>
<li><p>具有传递性，如果 <code>x hb-&gt; y</code> 并且 <code>y hb-&gt; z</code> 那么有 <code>x hb-&gt; z</code> ，配合 volatile 的防指令重排，有下面的例子</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> x;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> y;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    y = <span class="hljs-number">10</span>;<br>    x = <span class="hljs-number">20</span>;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    <span class="hljs-comment">// x=20 对 t2 可见, 同时 y=10 也对 t2 可见</span><br>    System.out.println(x);<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="五、无锁"><a href="#五、无锁" class="headerlink" title="五、无锁"></a>五、无锁</h1><p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%BB%91%E9%A9%AC%E8%A7%86%E9%A2%91%E7%AC%AC%E5%85%AD%E7%AB%A0%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93.png" srcset="/img/loading.gif" lazyload alt="image-20220124171020723"></p>
<p>前面的 <strong>synchronized</strong> 和 <strong>ReentrantLock</strong> 等 独占锁 就是用阻塞式的 <strong><code>悲观锁</code></strong> 实现并发控制</p>
<p>本章中<strong>java.util.concurrent.atomic包下面的原子变量类</strong>就是使用了非阻塞式的<code>乐观锁</code>的思想通过 <strong><code>CAS</code></strong> 实现并发控制</p>
<p>问题引入：有如下需求，保证<code>account.withdraw()</code>取款方法的线程安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义接口Account</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-comment">// 定义获取余额方法</span><br>    Integer <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 定义取款方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(Integer amount)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Java8之后接口新特性, 可以添加默认方法</span><br><span class="hljs-comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span><br><span class="hljs-comment">     * 如果初始余额为 10000 那么正确的结果应当是 0。并计算耗费时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(Account account)</span> &#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                account.withdraw(<span class="hljs-number">10</span>);<br>            &#125;));<br>        &#125;<br>        ts.forEach(thread -&gt; thread.start());<br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        System.out.println(account.getBalance()<br>                + <span class="hljs-string">&quot; cost: &quot;</span> + (end - start) / <span class="hljs-number">1000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//定义AccountUnsafe类继承Account接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountUnsafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer balance;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AccountUnsafe</span><span class="hljs-params">(Integer balance)</span> &#123;<br>        <span class="hljs-built_in">this</span>.balance = balance;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">return</span> balance;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(Integer amount)</span> &#123;<br>        balance -= amount;   <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 主函数测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Account.demo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountUnsafe</span>(<span class="hljs-number">10000</span>));  <span class="hljs-comment">//90 cost: 62 ms</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码显然没有加任何线程保护措施，打印的结果也不为0，证明确实有线程安全问题。通过之前的学习可以知道加锁能够保护线程安全，即将<code>AccountUnsafe</code>中的<code>withdraw</code>加上锁。测试结果为0，符合线程安全要求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(Integer amount)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)&#123;<br>        balance -= amount;<br>    &#125;      <br>&#125;<br><br><span class="hljs-comment">// 主函数测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Account.demo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountUnsafe</span>(<span class="hljs-number">10000</span>));  <span class="hljs-comment">//0 cost: 63 ms</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是 synchronized加锁操作太耗费资源 （因为底层使用了操作系统mutex指令, 造成内核态和用户态的切换），这里我们使用 <strong>无锁</strong>来解决此问题。构建<code>AccountCas </code>类</p>
<h2 id="1-CAS和volatile"><a href="#1-CAS和volatile" class="headerlink" title="1. CAS和volatile"></a>1. CAS和volatile</h2><p>CAS是<code>compareAndSwap（比较并设置值）</code>的简称（也有 Compare And Swap 的说法），它必须是原子操作。通过不断重试CAS操作，能够保护线程安全</p>
<p>上个例子的无锁代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义AccountCas类继承Account接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-comment">// 注意：这里使用原子整数: 底层使用CAS+重试的机制</span><br>    <span class="hljs-keyword">private</span> AtomicInteger balance;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AccountCas</span><span class="hljs-params">(<span class="hljs-type">int</span> balance)</span> &#123;<br>        <span class="hljs-built_in">this</span>.balance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(balance);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//得到原子整数的值</span><br>        <span class="hljs-keyword">return</span> balance.get();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(Integer amount)</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">//获得修改前的值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br>            <span class="hljs-comment">//获得修改后的值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev - amount;<br>            <br>            <span class="hljs-keyword">if</span>(balance.compareAndSet(prev, next)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>无锁的测试代码如下，可以发现无锁同样能够保护线程安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Account.demo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountUnsafe</span>(<span class="hljs-number">10000</span>)); <span class="hljs-comment">// 0 cost: 61 ms</span><br>    Account.demo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountCas</span>(<span class="hljs-number">10000</span>));    <span class="hljs-comment">// 0 cost: 52 ms</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="1-cas-重试-的原理"><a href="#1-cas-重试-的原理" class="headerlink" title="(1) cas + 重试 的原理"></a>(1) cas + 重试 的原理</h3><p>改动的关键就在于<code>withdraw</code>方法：</p>
<ul>
<li>线程A首先获取balance.get()，拿到当前的balance值prev</li>
<li>根据这个prev值 - amount值 &#x3D; 修改后的值next</li>
<li>调用compareAndSet方法, 首先会判断当初拿到的prev值,是否和现在的balance值相同<ul>
<li>如果相同，表示其他线程没有修改balance的值，此时就可以将next值设置给balance属性</li>
<li>如果不相同，表示其他线程也修改了balance值，此时就设置next值失败，重新获取balance.get()的值，即重新获取其他线程修改过后的balance值。。。重复获取</li>
</ul>
</li>
</ul>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-CAS.png" srcset="/img/loading.gif" lazyload alt="image-20220122114732613"></p>
<h3 id="2-volatile的作用"><a href="#2-volatile的作用" class="headerlink" title="(2) volatile的作用"></a>(2) volatile的作用</h3><p>其中，<code>AccountCas</code>成员变量类型<code>AtomicInteger</code>的源码中定义了核心变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;<br></code></pre></td></tr></table></figure>

<p>即获取共享变量时，为了<strong>保证该变量的可见性</strong>，需要使用 volatile 修饰。<strong>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</strong></p>
<h3 id="3-无锁效率高的原因"><a href="#3-无锁效率高的原因" class="headerlink" title="(3) 无锁效率高的原因"></a>(3) 无锁效率高的原因</h3><p>对比发现无锁效率比有锁高，其原因是：</p>
<ul>
<li>使用CAS+重试即无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized会让线程在没有获得锁的时候，发生上下文切换，进入阻塞，这部分时间损耗的较多。</li>
<li>无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，因此CAS适合线程数少于CPU核心数的情况，否则没有额外CPU支持，CAS并不能发挥作用（像上面例子中创建1000个线程其实并不能体现CAS的高效）</li>
</ul>
<h3 id="4-CAS的特点"><a href="#4-CAS的特点" class="headerlink" title="(4) CAS的特点"></a>(4) CAS的特点</h3><ul>
<li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。<strong>只是基于乐观锁的思想，其实是没有加锁的。</strong></li>
<li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li>
<li>CAS 体现的是<strong>无锁并发、无阻塞并发</strong><ul>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li>
<li>但如果竞争激烈(写操作多)，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
</li>
</ul>
<h2 id="2-atomic包"><a href="#2-atomic包" class="headerlink" title="2. atomic包"></a>2. atomic包</h2><p><code>java.util.concurrent.atomic</code>提供了一些并发工具类，这里把它分成五类：</p>
<ul>
<li>原子整数</li>
<li>原子引用</li>
<li>原子数组</li>
<li>字段更新器</li>
<li>原子累加器</li>
</ul>
<h3 id="1-原子整数-AtomicInteger"><a href="#1-原子整数-AtomicInteger" class="headerlink" title="(1) 原子整数(AtomicInteger)"></a>(1) 原子整数(AtomicInteger)</h3><p>共享数据为基本数据类型原子类，下面这三种提供的方法几乎相同，所以我们将以 <code>AtomicInteger</code>为例子来介绍。</p>
<ul>
<li>AtomicInteger：整型原子类</li>
<li>AtomicLong：长整型原子类</li>
<li>AtomicBoolean ：布尔型原子类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span><br>    System.out.println(i.getAndIncrement());<br>    <br>    <span class="hljs-comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span><br>    System.out.println(i.incrementAndGet());<br>    <br>    <span class="hljs-comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span><br>    System.out.println(i.decrementAndGet());<br>    <br>    <span class="hljs-comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span><br>    System.out.println(i.getAndDecrement());<br>    <br>    <span class="hljs-comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span><br>    System.out.println(i.getAndAdd(<span class="hljs-number">5</span>));<br>    <br>    <span class="hljs-comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span><br>    System.out.println(i.addAndGet(-<span class="hljs-number">5</span>));<br>    <br>    <span class="hljs-comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span><br>    <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span><br>    System.out.println(i.getAndUpdate(p -&gt; p - <span class="hljs-number">2</span>));<br>    <br>    <span class="hljs-comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span><br>    <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span><br>    System.out.println(i.updateAndGet(p -&gt; p + <span class="hljs-number">2</span>));<br>    <br>    <span class="hljs-comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span><br>    <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span><br>    <span class="hljs-comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span><br>    <span class="hljs-comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final</span><br>    System.out.println(i.getAndAccumulate(<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br>    <br>    <span class="hljs-comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1值, 结果 i = 0, 返回 0）</span><br>    <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span><br>    System.out.println(i.accumulateAndGet(-<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>AtomicInteger 内部这些方法也都是通过<strong>cas的原理</strong>来实现的：</p>
<p>以<code>updateAndGet</code>来看，<code>weakCompareAndSetVolatile</code>本质上还是CAS操作。<code>IntUnaryOperator</code>是一个功能性接口，只包含一个抽象方法，然后配合lamda表达式使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateAndGet</span><span class="hljs-params">(IntUnaryOperator updateFunction)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> get(), next = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">boolean</span> <span class="hljs-variable">haveNext</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;;) &#123;<br>        <span class="hljs-keyword">if</span> (!haveNext)<br>            next = updateFunction.applyAsInt(prev);<br>        <span class="hljs-keyword">if</span> (weakCompareAndSetVolatile(prev, next))<br>            <span class="hljs-keyword">return</span> next;<br>        haveNext = (prev == (prev = get()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用原子整数的方法能够简化上面算账的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-keyword">private</span> AtomicInteger balance;<br>	<br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(Integer amount)</span> &#123;<br>        balance.getAndAdd(-<span class="hljs-number">1</span>*amount)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-原子引用-AtomicReference"><a href="#2-原子引用-AtomicReference" class="headerlink" title="(2) 原子引用 (AtomicReference)"></a>(2) 原子引用 (AtomicReference)</h3><p>保护的共享变量不仅仅是基本数据类型，也可能是引用数据类型</p>
<ul>
<li>AtomicReference：引用类型原子类</li>
<li>AtomicStampedReference：原子更新带有版本号的引用类型。</li>
<li>AtomicMarkableReference ：原子更新带有标记的引用类型。</li>
</ul>
<h4 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h4><p>例子 : 使用原子引用实现BigDecimal存取款的线程安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        DecimalAccount.demo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DecimalAccountCas</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;10000&quot;</span>)));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DecimalAccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DecimalAccount</span> &#123;<br><br>    <span class="hljs-comment">//原子引用，泛型类型为小数类型</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicReference&lt;BigDecimal&gt; balance;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DecimalAccountCas</span><span class="hljs-params">(BigDecimal balance)</span> &#123;<br>        <span class="hljs-built_in">this</span>.balance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(balance);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> balance.get();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br>            <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev.subtract(amount);<br>            <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, next)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">DecimalAccount</span> &#123;<br>    <span class="hljs-comment">// 获取余额</span><br>    BigDecimal <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 取款</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(BigDecimal amount)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span><br><span class="hljs-comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(DecimalAccount account)</span> &#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                account.withdraw(BigDecimal.TEN);<br>            &#125;));<br>        &#125;<br>        ts.forEach(Thread::start);<br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        System.out.println(account.getBalance());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>对于CAS保护的线程来说，他只能认为共享变量跟之前一样则没有被其他线程改动，其实是不严谨的。如果有别的线程对共享变量进行了修改，但是修改之后又变成了原值，即<code>A-&gt;B-&gt;A</code>，这对CAS来说是不可见的，尽管这种操作这对业务代码并无影响</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ABATest</span> &#123;<br>    <span class="hljs-keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        log.debug(<span class="hljs-string">&quot;main start...&quot;</span>);<br>        <span class="hljs-comment">// 获取值 A</span><br>        <span class="hljs-comment">// 这个共享变量被它线程修改过？</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ref.get();<br>        other();<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 尝试改为 C</span><br>        log.debug(<span class="hljs-string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="hljs-string">&quot;C&quot;</span>));<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="hljs-string">&quot;B&quot;</span>));<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        sleep(<span class="hljs-number">500</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="hljs-string">&quot;A&quot;</span>));<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">23:41:20.821 [main] <span class="hljs-built_in">DEBUG</span> ABATest - main start<span class="hljs-built_in">..</span>.<br>23:41:20.824 [t1] <span class="hljs-built_in">DEBUG</span> ABATest - change A-&gt;B <span class="hljs-literal">true</span><br>23:41:21.332 [t2] <span class="hljs-built_in">DEBUG</span> ABATest - change B-&gt;A <span class="hljs-literal">true</span><br>23:41:21.344 [main] <span class="hljs-built_in">DEBUG</span> ABATest - change A-&gt;C <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<p>如果主线程希望：只要有其它线程【动过】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，使用<code>AtomicStampedReference</code>可以解决。</p>
<h4 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h4><p>AtomicStampedReference可以给原子引用加上版本号，追踪原子引用整个的变化过程，如：<code>A -&gt; B -&gt; A -&gt;C </code>，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ABASolution</span> &#123;<br>    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        log.debug(<span class="hljs-string">&quot;main start...&quot;</span>);<br>        <span class="hljs-comment">// 获取值 A</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ref.getReference();<br>        <span class="hljs-comment">// 获取版本号</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> ref.getStamp();<br>        log.debug(<span class="hljs-string">&quot;版本 &#123;&#125;&quot;</span>, stamp);<br>        <span class="hljs-comment">// 如果中间有其它线程干扰，发生了 ABA 现象</span><br>        other();<br>        sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-comment">// 尝试改为 C</span><br>        log.debug(<span class="hljs-string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="hljs-string">&quot;C&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;B&quot;</span>,<br>                    ref.getStamp(), ref.getStamp() + <span class="hljs-number">1</span>));<br>            log.debug(<span class="hljs-string">&quot;更新版本为 &#123;&#125;&quot;</span>, ref.getStamp());<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        sleep(<span class="hljs-number">500</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;A&quot;</span>,<br>                    ref.getStamp(), ref.getStamp() + <span class="hljs-number">1</span>));<br>            log.debug(<span class="hljs-string">&quot;更新版本为 &#123;&#125;&quot;</span>, ref.getStamp());<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h4><p>有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了AtomicMarkableReference，</p>
<p>例子：</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-AtomicMarkableReference.png" srcset="/img/loading.gif" lazyload alt="image-20220122234700311"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestABAAtomicMarkableReference</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">GarbageBag</span> <span class="hljs-variable">bag</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GarbageBag</span>(<span class="hljs-string">&quot;装满了垃圾&quot;</span>);<br>        <span class="hljs-comment">// 参数2 mark 可以看作一个标记，表示垃圾袋满了</span><br>        AtomicMarkableReference&lt;GarbageBag&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicMarkableReference</span>&lt;&gt;(bag, <span class="hljs-literal">true</span>);<br>        <br>        log.debug(<span class="hljs-string">&quot;主线程 start...&quot;</span>);<br>        <span class="hljs-type">GarbageBag</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ref.getReference();<br>        log.debug(prev.toString());<br>        <br>		<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>			log.debug(<span class="hljs-string">&quot;打扫卫生的线程 start...&quot;</span>);<br>            bag.setDesc(<span class="hljs-string">&quot;空垃圾袋&quot;</span>);<br>            <span class="hljs-keyword">while</span> (!ref.compareAndSet(bag, bag, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>)) &#123;&#125;<br>            log.debug(bag.toString());<br>		&#125;).start();<br>        <br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;主线程想换一只新垃圾袋？&quot;</span>);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> ref.compareAndSet(prev, <span class="hljs-keyword">new</span> <span class="hljs-title class_">GarbageBag</span>(<span class="hljs-string">&quot;空垃圾袋&quot;</span>), <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>        log.debug(<span class="hljs-string">&quot;换了么？&quot;</span> + success);<br>        <br>        log.debug(ref.getReference().toString());<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GarbageBag</span> &#123;<br>	String desc;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">GarbageBag</span><span class="hljs-params">(String desc)</span> &#123;<br>		<span class="hljs-built_in">this</span>.desc = desc;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDesc</span><span class="hljs-params">(String desc)</span> &#123;<br>		<span class="hljs-built_in">this</span>.desc = desc;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.toString() + <span class="hljs-string">&quot; &quot;</span> + desc;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">2019<span class="hljs-string">-10</span><span class="hljs-string">-13</span> 15:30:09.264 [main] 主线程 start...<br>2019<span class="hljs-string">-10</span><span class="hljs-string">-13</span> 15:30:09.270 [main] cn.itcast.GarbageBag@5f0fd5a0 装满了垃圾<br>2019<span class="hljs-string">-10</span><span class="hljs-string">-13</span> 15:30:09.293 [Thread<span class="hljs-string">-1</span>] 打扫卫生的线程 start...<br>2019<span class="hljs-string">-10</span><span class="hljs-string">-13</span> 15:30:09.294 [Thread<span class="hljs-string">-1</span>] cn.itcast.GarbageBag@5f0fd5a0 空垃圾袋<br>2019<span class="hljs-string">-10</span><span class="hljs-string">-13</span> 15:30:10.294 [main] 主线程想换一只新垃圾袋？<br>2019<span class="hljs-string">-10</span><span class="hljs-string">-13</span> 15:30:10.294 [main] 换了么？false<br>2019<span class="hljs-string">-10</span><span class="hljs-string">-13</span> 15:30:10.294 [main] cn.itcast.GarbageBag@5f0fd5a0 空垃圾袋<br></code></pre></td></tr></table></figure>



<h3 id="3-原子数组-AtomicIntegerArray"><a href="#3-原子数组-AtomicIntegerArray" class="headerlink" title="(3) 原子数组 (AtomicIntegerArray)"></a>(3) 原子数组 (AtomicIntegerArray)</h3><p>有时并不是更改数组的引用地址，而是想使用原子的方式更新数组里的某个元素。此时若想保证数组内的元素的线程安全，就需要用到原子数组</p>
<ul>
<li>AtomicIntegerArray：整形数组原子类</li>
<li>AtomicLongArray：长整形数组原子类</li>
<li>AtomicReferenceArray：引用类型数组原子类</li>
</ul>
<p>上面三个类提供的方法几乎相同，所以我们这里以 AtomicIntegerArray 为例子来介绍。实例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicArrayTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        demo(<br>            () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>],<br>            array -&gt; array.length,<br>            (array, index) -&gt; array[index]++,<br>            array -&gt; System.out.println(Arrays.toString(array))<br>        );<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 参数1，提供数组、可以是线程不安全数组或线程安全数组</span><br><span class="hljs-comment">     * 参数2，获取数组长度的方法</span><br><span class="hljs-comment">     * 参数3，自增方法，回传 array, index</span><br><span class="hljs-comment">     * 参数4，打印数组的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// supplier 提供者 无中生有 ()-&gt;结果</span><br>    <span class="hljs-comment">// function 函数 一个参数一个结果 (参数)-&gt;结果 , BiFunction (参数1,参数2)-&gt;结果</span><br>    <span class="hljs-comment">// consumer 消费者 一个参数没结果 (参数)-&gt;void, BiConsumer (参数1,参数2)-&gt;void</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(Supplier&lt;T&gt; arraySupplier, Function&lt;T, Integer&gt; lengthFun,</span><br><span class="hljs-params">                                 BiConsumer&lt;T, Integer&gt; putConsumer, Consumer&lt;T&gt; printConsumer)</span> &#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">T</span> <span class="hljs-variable">array</span> <span class="hljs-operator">=</span> arraySupplier.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> lengthFun.apply(array);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-comment">// 创建10个线程, 每个线程对数组作 10000 次操作</span><br>            ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                    putConsumer.accept(array, j % length);<br>                &#125;<br>            &#125;));<br>        &#125;<br><br>        ts.forEach(t -&gt; t.start()); <span class="hljs-comment">// 启动所有线程</span><br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;); <span class="hljs-comment">// 等所有线程结束</span><br><br>        printConsumer.accept(array);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[<span class="hljs-number">9870</span>, <span class="hljs-number">9862</span>, <span class="hljs-number">9774</span>, <span class="hljs-number">9697</span>, <span class="hljs-number">9683</span>, <span class="hljs-number">9678</span>, <span class="hljs-number">9679</span>, <span class="hljs-number">9668</span>, <span class="hljs-number">9680</span>, <span class="hljs-number">9698</span>]<br></code></pre></td></tr></table></figure>



<p>使用<code>AtomicIntegerArray</code>来创建安全数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">demo(<br>        ()-&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-number">10</span>),<br>        (array) -&gt; array.length(),<br>        (array, index) -&gt; array.getAndIncrement(index),<br>        array -&gt; System.out.println(array)<br>);<br></code></pre></td></tr></table></figure>

<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000]</span><br></code></pre></td></tr></table></figure>



<h3 id="4-字段更新器"><a href="#4-字段更新器" class="headerlink" title="(4) 字段更新器"></a>(4) 字段更新器</h3><p>原子更新器用于帮助我们线程安全地改变某个对象中的某个属性，只能配合 <code>volatile</code> 修饰的字段使用，否则会出现异常。</p>
<p>字段更新器用到了反射</p>
<ul>
<li>AtomicReferenceFieldUpdater  引用类型的属性</li>
<li>AtomicIntegerFieldUpdater  整形的属性</li>
<li>AtomicLongFieldUpdate  长整形的属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicFieldUpdaterTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        <span class="hljs-comment">// 获取字段更新器</span><br>        <span class="hljs-comment">// 参数1：要更新的类；参数2：要更新的字段参数类型；参数3：要更新的字段</span><br>        <span class="hljs-type">AtomicReferenceFieldUpdater</span> <span class="hljs-variable">updater</span> <span class="hljs-operator">=</span> AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, <span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-comment">// 期望的为null, 如果name属性没有被别的线程更改过, 默认就为null, 此时匹配, 就可以设置name为张三</span><br>        System.out.println(updater.compareAndSet(stu, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;张三&quot;</span>)); <span class="hljs-comment">// 更新成功</span><br>        System.out.println(updater.compareAndSet(stu, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>)); <span class="hljs-comment">// 更新失败</span><br>        System.out.println(stu);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">volatile</span> String name;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果<code>name</code>字段不用volatile修饰，则会报异常</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Exception</span> <span class="hljs-keyword">in</span> thread &quot;main&quot; java.lang.IllegalArgumentException: Must be <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure>



<h3 id="5-原子累加器-LongAddr"><a href="#5-原子累加器-LongAddr" class="headerlink" title="(5) 原子累加器 (LongAddr)"></a>(5) 原子累加器 (LongAddr)</h3><p>jdk8之后，设计了几个专门用于累加的原子累加器，比原子整数自带的累加方法要更高效</p>
<ul>
<li><code>LongAddr</code></li>
<li>LongAccumulator</li>
<li>DoubleAddr</li>
<li>DoubleAccumulator</li>
</ul>
<p>累加器性能比较 AtomicLong, LongAddr：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;----AtomicLong----&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            demo(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(), adder -&gt; adder.getAndIncrement());<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;----LongAdder----&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            demo(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>(), adder -&gt; adder.increment());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action)</span> &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">adder</span> <span class="hljs-operator">=</span> adderSupplier.get();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 4 个线程，每人累加 50 万</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">500000</span>; j++) &#123;<br>                    action.accept(adder);<br>                &#125;<br>            &#125;));<br>        &#125;<br>        ts.forEach(t -&gt; t.start());<br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        System.out.println(adder + <span class="hljs-string">&quot; cost:&quot;</span> + (end - start) / <span class="hljs-number">1000_000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vim">----AtomicLong----<br><span class="hljs-number">20000000</span> <span class="hljs-built_in">cos</span><span class="hljs-variable">t:323</span><br><span class="hljs-number">20000000</span> <span class="hljs-built_in">cos</span><span class="hljs-variable">t:337</span><br><span class="hljs-number">20000000</span> <span class="hljs-built_in">cos</span><span class="hljs-variable">t:287</span><br><span class="hljs-number">20000000</span> <span class="hljs-built_in">cos</span><span class="hljs-variable">t:386</span><br><span class="hljs-number">20000000</span> <span class="hljs-built_in">cos</span><span class="hljs-variable">t:339</span><br>----LongAdder----<br><span class="hljs-number">20000000</span> <span class="hljs-built_in">cos</span><span class="hljs-variable">t:38</span><br><span class="hljs-number">20000000</span> <span class="hljs-built_in">cos</span><span class="hljs-variable">t:28</span><br><span class="hljs-number">20000000</span> <span class="hljs-built_in">cos</span><span class="hljs-variable">t:17</span><br><span class="hljs-number">20000000</span> <span class="hljs-built_in">cos</span><span class="hljs-variable">t:31</span><br><span class="hljs-number">20000000</span> <span class="hljs-built_in">cos</span><span class="hljs-variable">t:16</span><br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>性能提升对比：</p>
<p><code>LongAddr</code></p>
<ul>
<li>性能提升的原因很简单，就是在有竞争时，设置多个累加单元(但不会超过cpu的核心数)，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。</li>
</ul>
<p><code>AtomicLong</code></p>
<ul>
<li>之前AtomicLong等都是在一个共享资源变量上进行竞争, while(true)循环进行CAS重试, 性能没有LongAdder高</li>
</ul>
<h5 id="LongAdder原理-了解"><a href="#LongAdder原理-了解" class="headerlink" title="LongAdder原理 (了解)"></a>LongAdder原理 (了解)</h5><p>暂时没看</p>
<h2 id="3-Unsafe"><a href="#3-Unsafe" class="headerlink" title="3. Unsafe"></a>3. Unsafe</h2><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过<strong>反射</strong>获得。可以发现<code>AtomicInteger</code>以及其他的原子类，底层都使用的是<code>Unsafe</code>类</p>
<p>使用底层的Unsafe实现原子操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 通过反射获得Unsafe对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">unsafeClass</span> <span class="hljs-operator">=</span> Unsafe.class;<br>        <span class="hljs-comment">// 获得构造函数，Unsafe的构造函数为私有的</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> unsafeClass.getDeclaredConstructor();<br>        <span class="hljs-comment">// 设置为允许访问私有内容</span><br>        constructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 创建Unsafe对象</span><br>        <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> (Unsafe) constructor.newInstance();<br><br>        <span class="hljs-comment">// 创建Person对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        <span class="hljs-comment">// 获得其属性 name 的偏移量</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">nameOffset</span> <span class="hljs-operator">=</span> unsafe.objectFieldOffset(Person.class.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>));<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ageOffset</span> <span class="hljs-operator">=</span> unsafe.objectFieldOffset(Person.class.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>));<br><br>        <span class="hljs-comment">// 通过unsafe的CAS操作改变值</span><br>        unsafe.compareAndSwapObject(person, nameOffset, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;张三&quot;</span>);<br>        unsafe.compareAndSwapInt(person, ageOffset, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>);<br>        System.out.println(person);  <span class="hljs-comment">// Person&#123;name=&#x27;张三&#x27;, age=22&#125;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// 配合CAS操作，必须用volatile修饰</span><br>    <span class="hljs-keyword">volatile</span> String name;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以自己使用Unsafe去实现原子整数，此处略过</p>
<h1 id="六、不可变"><a href="#六、不可变" class="headerlink" title="六、不可变"></a>六、不可变</h1><h2 id="1-不可变"><a href="#1-不可变" class="headerlink" title="1. 不可变"></a>1. 不可变</h2><p>有很多数据类型是可变的，在并发过程中容易导致多线程问题。如果一个对象不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改。<strong>不可变对象，实际是另一种避免竞争的方式</strong>。</p>
<p>例如：<code>SimpleDateFormat</code>类是可变的，其在多线程日期转换时容易出现问题，如下代码会报异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>	 <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>	 <span class="hljs-keyword">try</span> &#123;<br>	 	log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, sdf.parse(<span class="hljs-string">&quot;1951-04-21&quot;</span>));<br>	 &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>	 	log.error(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, e);<br>	 &#125;<br>	 &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用同步锁<code>synchronized</code>可以解决线程安全问题，但损耗性能</p>
<p>jdk8之后，提供了<code>DateTimeFormatter</code>，这是一种不可变的日期格式化类。可以成功转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dtf</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-type">TemporalAccessor</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> dtf.parse(<span class="hljs-string">&quot;2020-12-29&quot;</span>);<br>                log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, date);<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="2-不可变的设计"><a href="#2-不可变的设计" class="headerlink" title="2. 不可变的设计"></a>2. 不可变的设计</h2><h3 id="1-使用final"><a href="#1-使用final" class="headerlink" title="(1)使用final"></a>(1)使用final</h3><p>Integer、Double、String、DateTimeFormatter以及基本类型包装类, 都是使用<code>final</code>来修饰的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];	<span class="hljs-comment">// 在JDK9 使用了byte[] 数组</span><br>    <span class="hljs-comment">/** Cache the hash code for the string */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hash; <span class="hljs-comment">// Default to 0</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>发现该类、类中所有属性都是 final 的，属性用 final 修饰保证了该属性是<strong>只读</strong>的，不能修改，类用 final 修饰保证了<strong>该类中的方法不能被覆盖</strong>，防止子类无意间破坏不可变性。</p>
<h4 id="final的原理："><a href="#final的原理：" class="headerlink" title="final的原理："></a>final的原理：</h4><p>发现 final 变量的赋值也会通过 <strong>putfield</strong> 指令来完成，同样在这条指令之后也会加入<strong>写屏障</strong>，保证在其它线程读到它的值时不会出现为 0 的情况</p>
<h3 id="2-保护性拷贝"><a href="#2-保护性拷贝" class="headerlink" title="(2)保护性拷贝"></a>(2)保护性拷贝</h3><p>使用字符串时，也有一些跟修改相关的方法，在最后返回时都是调用String 的构造方法创建了一个新字符串，这个方法内部构造新字符串对象时，会生成新的 <code>char[] value</code>，对内容进行复制。而不是对 <code>final char[] value</code> 做出修改</p>
<p>这种通过创建副本对象来避免共享的手段称之为【保护性拷贝（defensive copy）】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">String</span><span class="hljs-params">(<span class="hljs-type">char</span> value[], <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> count)</span> &#123;<br>    <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(offset);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(count);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (offset &lt;= value.length) &#123;<br>            <span class="hljs-built_in">this</span>.value = <span class="hljs-string">&quot;&quot;</span>.value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span><br>    <span class="hljs-keyword">if</span> (offset &gt; value.length - count) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(offset + count);<br>    &#125;<br>    <span class="hljs-comment">// 上面是一些安全性的校验，下面是给String对象的value赋值，新创建了一个数组来保存String对象的值</span><br>    <span class="hljs-built_in">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="3-不可变线程安全辨析"><a href="#3-不可变线程安全辨析" class="headerlink" title="3. 不可变线程安全辨析"></a>3. 不可变线程安全辨析</h2><p>上文提到的不可变均指类对象的单个方法是原子的，是不可变的，但多个方法的组合就不一定了。</p>
<p>例如<code>BigDecimal</code>类中的add方法是原子的，按理说是线程安全的，但在第五章讲解原子引用<code>AtomicReference</code>时，加操作并不是直接使用add方法，这是因为当时还用到了get方法，多种方法的组合可能并不是原子的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev.subtract(amount);<br>        <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, next)) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="七、并发工具"><a href="#七、并发工具" class="headerlink" title="七、并发工具"></a>七、并发工具</h1><h2 id="1-线程池"><a href="#1-线程池" class="headerlink" title="1. 线程池"></a>1. 线程池</h2><p>池化技术有很多, 比如线程池、数据库连接池、HTTP连接池等等都是对这个思想的应用。池化技术的思想主要是为了<strong>减少每次获取资源的消耗，提高对资源的利用率</strong>。线程池提供了一种 <strong>限制和管理资源</strong>（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p>
<p>线程池的好处：</p>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。(创建的线程,实际最后要和操作系统的线程做映射,很消耗资源)</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h3 id="1-1-自定义一个简单的线程池"><a href="#1-1-自定义一个简单的线程池" class="headerlink" title="1.1 自定义一个简单的线程池"></a>1.1 自定义一个简单的线程池</h3><p>略</p>
<p>java线程池的常用创建方式主要有两种，（1）通过new ThreadPoolExecutor方法创建。（2）通过Executors工厂方法创建</p>
<h3 id="1-2-创建线程池的两种方法"><a href="#1-2-创建线程池的两种方法" class="headerlink" title="1.2 创建线程池的两种方法"></a>1.2 创建线程池的两种方法</h3><h4 id="1-2-1-ThreadPoolExecutor方法创建线程池"><a href="#1-2-1-ThreadPoolExecutor方法创建线程池" class="headerlink" title="1.2.1 ThreadPoolExecutor方法创建线程池"></a>1.2.1 ThreadPoolExecutor方法创建线程池</h4><h5 id="1-线程池状态"><a href="#1-线程池状态" class="headerlink" title="(1) 线程池状态"></a>(1) 线程池状态</h5><p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 线程池状态</span><br><span class="hljs-comment">// runState is stored in the high-order bits</span><br><span class="hljs-comment">// RUNNING 高3位为111</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// SHUTDOWN 高3位为000</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 高3位 001</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 高3位 010</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 高3位 011</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br></code></pre></td></tr></table></figure>

<p>从数字上比较（第一位是符号位），<code>TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING</code></p>
<table>
<thead>
<tr>
<th align="center">状态名称</th>
<th align="center">高3位的值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">RUNNING</td>
<td align="center">111</td>
<td align="center">接收新任务，同时处理任务队列中的任务</td>
</tr>
<tr>
<td align="center">SHUTDOWN</td>
<td align="center">000</td>
<td align="center">不接受新任务，但是处理任务队列中的任务</td>
</tr>
<tr>
<td align="center">STOP</td>
<td align="center">001</td>
<td align="center">中断正在执行的任务，同时抛弃阻塞队列中的任务</td>
</tr>
<tr>
<td align="center">TIDYING</td>
<td align="center">010</td>
<td align="center">任务执行完毕，活动线程为0时，即将进入终结阶段</td>
</tr>
<tr>
<td align="center">TERMINATED</td>
<td align="center">011</td>
<td align="center">终结状态</td>
</tr>
</tbody></table>
<p>线程池状态和线程池中线程的数量 <strong>由一个原子整型ctl来共同表示</strong>。使用一个数来表示两个值的主要原因是：<strong>可以通过一次CAS同时更改两个属性的值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// c 为旧值， ctlOf 返回结果为新值</span><br>ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));<br><span class="hljs-comment">// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctlOf</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> wc)</span> &#123; <span class="hljs-keyword">return</span> rs | wc; &#125;<br></code></pre></td></tr></table></figure>

<h5 id="2-线程池构造方法"><a href="#2-线程池构造方法" class="headerlink" title="(2) 线程池构造方法"></a>(2) 线程池构造方法</h5><p>ThreadPoolExecutor最全面的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure>

<p><strong>参数解释：</strong></p>
<ul>
<li><code>corePoolSize</code>：核心线程数，定义了最小可以同时运行的线程数量</li>
<li><code>maximumPoolSize</code>：最大线程数，线程池里的线程分为两种：核心线程和救急线程<ul>
<li>maximumPoolSize - corePoolSize &#x3D; 救急线程数</li>
</ul>
</li>
<li><code>keepAliveTime</code>：救急线程空闲时的最大生存时间。超过时间会销毁救急线程</li>
<li><code>unit</code>：救急线程的时间单位</li>
<li><code>workQueue</code>：存放任务的阻塞队列。新来的任务会先判断当前运行的线程数是否到达核心线程数，如果到达的话，任务就会先放到阻塞队列。<ul>
<li>有界阻塞队列 ArrayBlockingQueue</li>
<li>无界阻塞队列 LinkedBlockingQueue</li>
<li>最多只有一个同步元素的 SynchronousQueue</li>
<li>优先队列 PriorityBlockingQueue</li>
</ul>
</li>
<li><code>threadFactory</code>线程工厂：可以给线程取个好名字，取名时要取清晰，区别于非线程池方法创建的线程</li>
<li><code>handler</code>：拒绝策略，阻塞队列满了，线程池使用什么样的拒绝策略拒绝新任务</li>
</ul>
<h5 id="3-线程池工作方式"><a href="#3-线程池工作方式" class="headerlink" title="(3) 线程池工作方式"></a>(3) 线程池工作方式</h5><p>当一个任务传给线程池以后，</p>
<ul>
<li>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新的核心线程来执行任务。</li>
<li>当线程数达到 <code>corePoolSize</code> 并且没有线程空闲，这时再加入任务，新加的任务会被加入<code>workQueue</code> 队列排队，直到有空闲的线程。</li>
<li>如果阻塞队列选择了有界阻塞队列并且阻塞队列满了，使用救急线程来执行任务。救急线程用完以后，超过生存时间（keepAliveTime）后会被释放。<strong>如果不是有界队列，则不会创建救急线程，都是核心线程</strong></li>
<li>任务总数大于了 最大线程数<code>maximumPoolSize</code>与阻塞队列容量的最大值<code>workQueue.capacity</code>，使用拒接策略</li>
</ul>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F.png" srcset="/img/loading.gif" lazyload alt="image-20220126222039262"></p>
<h5 id="4-拒绝策略"><a href="#4-拒绝策略" class="headerlink" title="(4) 拒绝策略"></a>(4) 拒绝策略</h5><p>拒绝策略 jdk 提供了 4 种实现：</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5.png" srcset="/img/loading.gif" lazyload alt="image-20220126220755917"></p>
<ul>
<li><code>AbortPolicy 中止策略</code>：丢弃任务并抛出RejectedExecutionException异常。<strong>这是默认策略</strong></li>
<li><code>CallerRunsPolicy 调用者运行策略</code>：当线程池无法处理当前任务时，会将该任务交由提交任务的线程来执行</li>
<li><code>DiscardOldestPolicy 弃老策略</code>：丢弃队列最前面的任务，然后重新提交被拒绝的任务。</li>
<li><code>DiscardPolicy 丢弃策略</code>：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。</li>
</ul>
<p>其它著名框架也提供了诸多拒绝策略：</p>
<ul>
<li>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li>
<li>Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题</li>
<li>ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略</li>
</ul>
<h4 id="1-2-2-Executors工厂方法创建线程池"><a href="#1-2-2-Executors工厂方法创建线程池" class="headerlink" title="1.2.2 Executors工厂方法创建线程池"></a>1.2.2 Executors工厂方法创建线程池</h4><p>根据这个<code>ThreadPoolExecutor</code>构造方法，JDK <code>Executors</code> 类中提供了众多工厂方法来创建各种用途的线程池，它们的底层还是调用<code>ThreadPoolExecutor</code>构造方法。<code>Executors</code> 是Executor 框架的工具类</p>
<h5 id="1-newFixedThreadPool"><a href="#1-newFixedThreadPool" class="headerlink" title="(1) newFixedThreadPool"></a>(1) newFixedThreadPool</h5><p><code>newFixedThreadPool</code>是这个工具类中的一个方法，其源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>特点</strong></p>
<ul>
<li>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间</li>
<li>阻塞队列是无界的，可以放任意数量的任务</li>
<li><strong>适用于任务量已知，相对耗时的任务</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><br>    pool.execute(()-&gt;&#123;<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;);<br><br>    pool.execute(()-&gt;&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;);<br><br>    pool.execute(()-&gt;&#123;<br>        log.debug(<span class="hljs-string">&quot;3&quot;</span>);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">11:09:22.021 [pool-1-thread-1] <span class="hljs-built_in">DEBUG</span> Test - 1<br>11:09:22.021 [pool-1-thread-2] <span class="hljs-built_in">DEBUG</span> Test - 2<br>11:09:22.023 [pool-1-thread-1] <span class="hljs-built_in">DEBUG</span> Test - 3<br></code></pre></td></tr></table></figure>

<p>程序不会自动结束，创建的都是非守护线程，所以会一直等待任务到来</p>
<p><code>newFixedThreadPool</code>还有一种带线程工厂参数的构造形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),<br>                                  threadFactory);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>线程工厂是为了统一在创建线程时设置一些参数，如是否守护线程。线程一些特性等，如优先级等。也可以指定默认的线程池和线程命名方法，线程工厂方法可以传入JDK默认的（ThreadPoolExecutor就是这样干的），也可以传自己写的，比如更改一些线程命名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 自定义线程工厂</span><br>    <span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactory</span>() &#123;<br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">&quot;myThread_&quot;</span> + atomicInteger.getAndIncrement());<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// 创建核心线程数量为2的线程池</span><br>    <span class="hljs-comment">// 通过 ThreadFactory可以给线程添加名字</span><br><br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>, factory);<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="2-newCachedThreadPool"><a href="#2-newCachedThreadPool" class="headerlink" title="(2) newCachedThreadPool"></a>(2) newCachedThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>特点</strong>:</p>
<ul>
<li>没有核心线程，最大线程数为Integer.MAX_VALUE，所有创建的线程都是救急线程 (可以无限创建)，空闲时生存时间为60秒</li>
<li>阻塞队列使用的是SynchronousQueue<ul>
<li>SynchronousQueue是一种特殊的队列，没有容量，没有线程来取是放不进去的，只有当线程取任务时，才会将任务放入该阻塞队列中</li>
</ul>
</li>
<li>整个线程池表现为<strong>线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程</strong>。 适合<strong>任务数比较密集，但每个任务执行时间较短</strong>的情况</li>
</ul>
<h5 id="3-newSingleThreadExecutor"><a href="#3-newSingleThreadExecutor" class="headerlink" title="(3) newSingleThreadExecutor"></a>(3) newSingleThreadExecutor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>特点：</p>
<p>Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改</p>
<p>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。 任务执行完毕，这唯一的线程也不会被释放。</p>
<p>区别：</p>
<ul>
<li>和自己创建单线程执行任务的区别：<ul>
<li>自己创建一个单线程串行执行任务，如果任务执行<strong>失败而终止那么没有任何补救措施</strong>，而newSingleThreadExecutor线程池还会<strong>新建一个线程</strong>，保证池的正常工作</li>
</ul>
</li>
<li>和使用<code>Executors.newFixedThreadPool(1) </code>初始时为1时的区别：<ul>
<li>Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改，对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</li>
<li>FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法，不能修改核心线程数等参数</li>
</ul>
</li>
</ul>
<h5 id="4-工厂方法的缺点"><a href="#4-工厂方法的缺点" class="headerlink" title="(4) 工厂方法的缺点"></a>(4) 工厂方法的缺点</h5><p>Executors 返回线程池对象有一些缺点：</p>
<ul>
<li>FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE (无界阻塞队列)，可能堆积大量的请求，从而导致 OOM（内存溢出，Out Of Memory）。</li>
<li>CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM</li>
<li><strong>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。</strong></li>
<li>我们应该显示地给我们的线程池命名，这样有助于我们定位问题。</li>
</ul>
<p>所以实际生产环境里建议使用<code>ThreadPoolExecutor</code>方法来创建线程，<strong>使用有界队列，控制线程创建数量。</strong></p>
<blockquote>
<p>阿里巴巴开发手册<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B&spm=1001.2101.3001.7020">并发编程</a>这块有一条：线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，通过源码分析禁用的原因</p>
</blockquote>
<h3 id="1-3-线程池执行-x2F-提交任务"><a href="#1-3-线程池执行-x2F-提交任务" class="headerlink" title="1.3 线程池执行&#x2F;提交任务"></a>1.3 线程池执行&#x2F;提交任务</h3><p>主要有 execute() 方法和 submit() 方法， execute() 方法用于提交不需要返回值的任务， submit() 方法用于需要提交返回值的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 执行任务</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span>;<br><br><span class="hljs-comment">// 提交任务 task，用返回值 Future 获得任务执行结果，Future的原理就是利用我们之前讲到的保护性暂停模式来接受返回结果的，主线程可以执行 FutureTask.get()方法来等待任务执行完成</span><br>&lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span>;<br></code></pre></td></tr></table></figure>

<h4 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute()方法"></a>execute()方法</h4><ul>
<li>传入一个Runnable对象，执行其中的run方法</li>
</ul>
<h4 id="submit-方法"><a href="#submit-方法" class="headerlink" title="submit()方法"></a>submit()方法</h4><ul>
<li><p>传入一个Callable对象，用Future来<strong>捕获返回值</strong>。跟Runnable的区别就是多了返回值</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 通过submit执行Callable中的call方法</span><br><span class="hljs-comment">// 通过Future来捕获返回值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>    <br>    <span class="hljs-comment">// 也可以用lamda表达式简化</span><br>    Future&lt;String&gt; future = pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;String&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>            log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 查看捕获的返回值</span><br>    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,future.get());<br>&#125;<br></code></pre></td></tr></table></figure>

  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">12:35:50.353 [pool-1-thread-1] <span class="hljs-built_in">DEBUG</span> Test - running<br>12:35:51.362 [main] <span class="hljs-built_in">DEBUG</span> Test - ok<br></code></pre></td></tr></table></figure></li>
</ul>
<p>还有其他一些提交任务的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 提交 tasks 中所有任务</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br> <br><span class="hljs-comment">// 提交 tasks 中所有任务，带超时时间</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span><br>&lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br><br><span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span><br>&lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;<br></code></pre></td></tr></table></figure>



<h3 id="1-4-关闭线程池"><a href="#1-4-关闭线程池" class="headerlink" title="1.4 关闭线程池"></a>1.4 关闭线程池</h3><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h4><ul>
<li>将线程池的状态改为 SHUTDOWN</li>
<li>不再接受新任务，但是会将阻塞队列中的任务执行完</li>
<li>此方法不会阻塞调用线程的执行</li>
</ul>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestShutDown</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><br>        Future&lt;Integer&gt; result1 = pool.submit(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;task 1 running...&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            log.debug(<span class="hljs-string">&quot;task 1 finish...&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;);<br><br>        Future&lt;Integer&gt; result2 = pool.submit(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;task 2 running...&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            log.debug(<span class="hljs-string">&quot;task 2 finish...&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;);<br><br>        <span class="hljs-comment">// 任务3能够执行</span><br>        Future&lt;Integer&gt; result3 = pool.submit(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;task 3 running...&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            log.debug(<span class="hljs-string">&quot;task 3 finish...&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        &#125;);<br><br>        log.debug(<span class="hljs-string">&quot;shutdown&quot;</span>);<br>        pool.shutdown();<br>        <span class="hljs-comment">// 并不会阻塞主线程后面的内容</span><br>        log.debug(<span class="hljs-string">&quot;other....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">13:23:21.260 [pool-1-thread-1] <span class="hljs-built_in">DEBUG</span> Test - task 1 running<span class="hljs-built_in">..</span>.<br>13:23:21.260 [pool-1-thread-2] <span class="hljs-built_in">DEBUG</span> Test - task 2 running<span class="hljs-built_in">..</span>.<br>13:23:21.260 [main] <span class="hljs-built_in">DEBUG</span> Test - shutdown<br>13:23:21.261 [main] <span class="hljs-built_in">DEBUG</span> Test - other<span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><br>13:23:22.269 [pool-1-thread-2] <span class="hljs-built_in">DEBUG</span> Test - task 2 finish<span class="hljs-built_in">..</span>.<br>13:23:22.269 [pool-1-thread-1] <span class="hljs-built_in">DEBUG</span> Test - task 1 finish<span class="hljs-built_in">..</span>.<br>13:23:22.270 [pool-1-thread-2] <span class="hljs-built_in">DEBUG</span> Test - task 3 running<span class="hljs-built_in">..</span>.<br>13:23:23.278 [pool-1-thread-2] <span class="hljs-built_in">DEBUG</span> Test - task 3 finish<span class="hljs-built_in">..</span>.<br></code></pre></td></tr></table></figure>

<h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a>shutdownNow()</h4><ul>
<li>将线程池的状态改为 STOP</li>
<li>以 interrupt 的方式中断正在执行的任务</li>
<li>不再接受新任务，也不会在执行阻塞队列中的任务</li>
<li>会将阻塞队列中未执行的任务返回给调用者</li>
</ul>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><br>    Future&lt;Integer&gt; result1 = pool.submit(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;task 1 running...&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;task 1 finish...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;);<br><br>    Future&lt;Integer&gt; result2 = pool.submit(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;task 2 running...&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;task 2 finish...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;);<br><br>    Future&lt;Integer&gt; result3 = pool.submit(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;task 3 running...&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;task 3 finish...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;);<br><br>    log.debug(<span class="hljs-string">&quot;shutdown&quot;</span>);<br>    List&lt;Runnable&gt; runnables = pool.shutdownNow();<br>    log.debug(<span class="hljs-string">&quot;other.... &#123;&#125;&quot;</span> , runnables);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">13:27:34.809 [main] <span class="hljs-built_in">DEBUG</span> Test - shutdown<br>13:27:34.809 [pool-1-thread-1] <span class="hljs-built_in">DEBUG</span> Test - task 1 running<span class="hljs-built_in">..</span>.<br>13:27:34.809 [pool-1-thread-2] <span class="hljs-built_in">DEBUG</span> Test - task 2 running<span class="hljs-built_in">..</span>.<br>13:27:34.811 [main] <span class="hljs-built_in">DEBUG</span> Test - other<span class="hljs-built_in">..</span><span class="hljs-built_in">..</span> [java.util.concurrent.FutureTask@6073f712[<span class="hljs-keyword">Not</span> completed, task = Test$<span class="hljs-variable">$Lambda</span><span class="hljs-variable">$30</span>/0x0000000800c0f4c8@277c0f21]]<br></code></pre></td></tr></table></figure>

<p>任务1和2都被打断，没执行完，返回的任务3是否再执行就由具体业务决定。调用线程即主线程可以执行结束</p>
<h6 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 不在 RUNNING 状态的线程池，此方法就返回 true</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isShutdown</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 线程池状态是否是 TERMINATED</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isTerminated</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 调用 shutdown 后，由于调用使线程结束线程的方法是异步的并不会等待所有任务运行结束就返回，因此如果它想在线程池 TERMINATED 后做些其它事情，可以利用此方法等待</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitTermination</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure>



<h3 id="1-5-延时-x2F-定时线程池"><a href="#1-5-延时-x2F-定时线程池" class="headerlink" title="1.5 延时&#x2F;定时线程池"></a>1.5 延时&#x2F;定时线程池</h3><p><code>ScheduledExecutorService</code>类的主要作用就是可以<strong>将定时任务与线程池功能结合使用</strong>。</p>
<p>语法上它是继承自<code>ExecutorService</code>的接口，使用时需要调用<code>Executors</code>工具类的<code>newScheduledThreadPool</code>方法，它继承自<code>ThreadPoolExecutor</code>类和<code>ScheduledExecutorService</code>接口</p>
<p><code>ScheduledExecutorService</code>类主要有三个方法：</p>
<h4 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 在指定delay（延时）之后，执行提交Runnable的任务，返回一个ScheduledFuture，</span><br><span class="hljs-comment">* 任务执行完成后ScheduledFuture的get()方法返回为null，ScheduledFuture的作用是可以cancel任务</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<br>                                   <span class="hljs-type">long</span> delay, TimeUnit unit);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 在指定delay（延时）之后，执行提交Callable的任务，返回一个ScheduledFuture</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> &lt;V&gt; ScheduledFuture&lt;V&gt; <span class="hljs-title function_">schedule</span><span class="hljs-params">(Callable&lt;V&gt; callable,</span><br><span class="hljs-params">                                       <span class="hljs-type">long</span> delay, TimeUnit unit)</span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    log.debug(<span class="hljs-string">&quot;start&quot;</span>);<br>    <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);<br><br>    executor.schedule(() -&gt; log.debug(<span class="hljs-string">&quot;任务1执行&quot;</span>), <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);<br><br>    executor.schedule(() -&gt; log.debug(<span class="hljs-string">&quot;任务2执行&quot;</span>), <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">23:41:15.486 [main] <span class="hljs-built_in">DEBUG</span> Test - start<br>23:41:16.505 [pool-1-thread-2] <span class="hljs-built_in">DEBUG</span> Test - 任务2执行<br>23:41:16.505 [pool-1-thread-1] <span class="hljs-built_in">DEBUG</span> Test - 任务1执行<br></code></pre></td></tr></table></figure>



<h4 id="scheduleAtFixedRate"><a href="#scheduleAtFixedRate" class="headerlink" title="scheduleAtFixedRate"></a>scheduleAtFixedRate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 提交一个Runnable任务延迟了initialDelay时间后，开始周期性的执行该任务，每period时间执行一次</span><br><span class="hljs-comment">* 如果任务异常则退出。如果取消任务或者关闭线程池，任务也会退出。</span><br><span class="hljs-comment">* 如果任务执行一次的时间大于周期时间，则任务执行将会延后执行，而不会并发执行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<br>                                              <span class="hljs-type">long</span> initialDelay,<br>                                              <span class="hljs-type">long</span> period,<br>                                              TimeUnit unit);<br></code></pre></td></tr></table></figure>

<p>scheduleAtFixedRate 例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br>    log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>    pool.scheduleAtFixedRate(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>    &#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-number">23</span>:<span class="hljs-number">43</span>:<span class="hljs-number">27.738</span> [main] <span class="hljs-symbol">DEBUG</span> <span class="hljs-symbol">Test</span> - start...<br><span class="hljs-number">23</span>:<span class="hljs-number">43</span>:<span class="hljs-number">28.753</span> [pool<span class="hljs-number">-1</span>-thread<span class="hljs-number">-1</span>] <span class="hljs-symbol">DEBUG</span> <span class="hljs-symbol">Test</span> - running...<br><span class="hljs-number">23</span>:<span class="hljs-number">43</span>:<span class="hljs-number">29.751</span> [pool<span class="hljs-number">-1</span>-thread<span class="hljs-number">-1</span>] <span class="hljs-symbol">DEBUG</span> <span class="hljs-symbol">Test</span> - running...<br><span class="hljs-number">23</span>:<span class="hljs-number">43</span>:<span class="hljs-number">30.749</span> [pool<span class="hljs-number">-1</span>-thread<span class="hljs-number">-1</span>] <span class="hljs-symbol">DEBUG</span> <span class="hljs-symbol">Test</span> - running...<br><span class="hljs-number">23</span>:<span class="hljs-number">43</span>:<span class="hljs-number">31.743</span> [pool<span class="hljs-number">-1</span>-thread<span class="hljs-number">-1</span>] <span class="hljs-symbol">DEBUG</span> <span class="hljs-symbol">Test</span> - running...<br></code></pre></td></tr></table></figure>

<p>scheduleAtFixedRate 例子（任务执行时间超过了间隔时间）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br>    log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>    pool.scheduleAtFixedRate(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>        sleep(<span class="hljs-number">2</span>);<br>    &#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-number">23</span>:<span class="hljs-number">45</span>:<span class="hljs-number">24.888</span> [main] <span class="hljs-symbol">DEBUG</span> <span class="hljs-symbol">Test</span> - start...<br><span class="hljs-number">23</span>:<span class="hljs-number">45</span>:<span class="hljs-number">25.906</span> [pool<span class="hljs-number">-1</span>-thread<span class="hljs-number">-1</span>] <span class="hljs-symbol">DEBUG</span> <span class="hljs-symbol">Test</span> - running...<br><span class="hljs-number">23</span>:<span class="hljs-number">45</span>:<span class="hljs-number">27.914</span> [pool<span class="hljs-number">-1</span>-thread<span class="hljs-number">-1</span>] <span class="hljs-symbol">DEBUG</span> <span class="hljs-symbol">Test</span> - running...<br><span class="hljs-number">23</span>:<span class="hljs-number">45</span>:<span class="hljs-number">29.928</span> [pool<span class="hljs-number">-1</span>-thread<span class="hljs-number">-1</span>] <span class="hljs-symbol">DEBUG</span> <span class="hljs-symbol">Test</span> - running...<br><span class="hljs-number">23</span>:<span class="hljs-number">45</span>:<span class="hljs-number">31.943</span> [pool<span class="hljs-number">-1</span>-thread<span class="hljs-number">-1</span>] <span class="hljs-symbol">DEBUG</span> <span class="hljs-symbol">Test</span> - running...<br></code></pre></td></tr></table></figure>

<p>一开始，延时 1s，接下来，由于任务执行时间 &gt; 间隔时间，间隔被“撑”到了 2s</p>
<h4 id="scheduleWithFixedDelay"><a href="#scheduleWithFixedDelay" class="headerlink" title="scheduleWithFixedDelay"></a>scheduleWithFixedDelay</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 提交一个Runnable任务延迟了initialDelay时间后，开始周期性的执行该任务，以后每两次任务执行的间隔是delay</span><br><span class="hljs-comment">* 如果任务异常则退出。如果取消任务或者关闭线程池，任务也会退出。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,<br>                                                 <span class="hljs-type">long</span> initialDelay,<br>                                                 <span class="hljs-type">long</span> delay,<br>                                                 TimeUnit unit);<br></code></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br>    log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>    pool.scheduleWithFixedDelay(()-&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            sleep(<span class="hljs-number">2</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一开始，延时 1s，scheduleWithFixedDelay 的间隔是 上一个任务结束 -&gt; 延时 -&gt; 下一个任务开始 所以间隔都是 3s</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-number">23</span>:<span class="hljs-number">47</span>:<span class="hljs-number">30.579</span> [main] <span class="hljs-symbol">DEBUG</span> <span class="hljs-symbol">Test</span> - start...<br><span class="hljs-number">23</span>:<span class="hljs-number">47</span>:<span class="hljs-number">31.586</span> [pool<span class="hljs-number">-1</span>-thread<span class="hljs-number">-1</span>] <span class="hljs-symbol">DEBUG</span> <span class="hljs-symbol">Test</span> - running...<br><span class="hljs-number">23</span>:<span class="hljs-number">47</span>:<span class="hljs-number">34.607</span> [pool<span class="hljs-number">-1</span>-thread<span class="hljs-number">-1</span>] <span class="hljs-symbol">DEBUG</span> <span class="hljs-symbol">Test</span> - running...<br><span class="hljs-number">23</span>:<span class="hljs-number">47</span>:<span class="hljs-number">37.608</span> [pool<span class="hljs-number">-1</span>-thread<span class="hljs-number">-1</span>] <span class="hljs-symbol">DEBUG</span> <span class="hljs-symbol">Test</span> - running...<br></code></pre></td></tr></table></figure>



<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>如何让每周四 18:00:00 定时执行任务?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSchedule</span> &#123;<br>    <span class="hljs-comment">// 如何让每周四 18:00:00 定时执行任务？</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//  获取当前时间</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        System.out.println(now);<br>        <span class="hljs-comment">// 获取周四时间</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> now.withHour(<span class="hljs-number">18</span>).withMinute(<span class="hljs-number">0</span>).withSecond(<span class="hljs-number">0</span>).withNano(<span class="hljs-number">0</span>).with(DayOfWeek.THURSDAY);<br>        <span class="hljs-comment">// 如果 当前时间 &gt; 本周周四，必须找到下周周四</span><br>        <span class="hljs-keyword">if</span>(now.compareTo(time) &gt; <span class="hljs-number">0</span>) &#123;<br>            time = time.plusWeeks(<span class="hljs-number">1</span>);<br>        &#125;<br>        System.out.println(time);<br>        <span class="hljs-comment">// initailDelay 代表当前时间和周四的时间差</span><br>        <span class="hljs-comment">// period 一周的间隔时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">initailDelay</span> <span class="hljs-operator">=</span> Duration.between(now, time).toMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">period</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">7</span>;<br>        <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br>        pool.scheduleAtFixedRate(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);<br>        &#125;, initailDelay, period, TimeUnit.MILLISECONDS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="1-6-正确处理执行任务异常"><a href="#1-6-正确处理执行任务异常" class="headerlink" title="1.6 正确处理执行任务异常"></a>1.6 正确处理执行任务异常</h3><p>线程池中的线程执行任务时，<strong>如果任务抛出了异常，默认是中断执行该任务而不是抛出异常或者打印异常信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>    Future&lt;Boolean&gt; f = pool.submit(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;task1&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出就是只有下面这一行，然后卡住</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">11</span>:<span class="hljs-number">37</span>:<span class="hljs-number">56</span>.<span class="hljs-number">205</span><span class="hljs-meta"> [pool-1-thread-1] DEBUG Test - task1</span><br></code></pre></td></tr></table></figure>



<p>方法1：<strong>主动捉异常</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>pool.submit(() -&gt; &#123;<br>	 <span class="hljs-keyword">try</span> &#123;<br>	 log.debug(<span class="hljs-string">&quot;task1&quot;</span>);<br>	 <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br>	 &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>	 log.error(<span class="hljs-string">&quot;error:&quot;</span>, e);<br>	 &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">11:39:39.300 [pool-1-thread-1] DEBUG <span class="hljs-keyword">Test</span> - task1<br>11:39:39.304 [pool-1-thread-1] <span class="hljs-keyword">ERROR</span> <span class="hljs-keyword">Test</span> - <span class="hljs-keyword">error</span>:<br>java.lang.ArithmeticException: / <span class="hljs-keyword">by</span> zero<br>	at <span class="hljs-keyword">Test</span>.lambda<span class="hljs-variable">$main</span><span class="hljs-variable">$0</span>(<span class="hljs-keyword">Test</span>.java:21)<br>	...<br></code></pre></td></tr></table></figure>



<p>方法2：<strong>使用 Future，错误信息都被封装进submit方法的返回方法中！</strong> 推荐使用此方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>Future&lt;Boolean&gt; f = pool.submit(() -&gt; &#123;<br>	 log.debug(<span class="hljs-string">&quot;task1&quot;</span>);<br>	 <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br>	 <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;);<br>log.debug(<span class="hljs-string">&quot;result:&#123;&#125;&quot;</span>, f.get());<br></code></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">11</span>:<span class="hljs-number">42</span>:<span class="hljs-number">51.035</span> <span class="hljs-selector-attr">[pool-1-thread-1]</span> DEBUG Test - task1<br>Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.ExecutionException</span>: java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ArithmeticException</span>: / by zero<br>	at java.base/java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.FutureTask</span><span class="hljs-selector-class">.report</span>(FutureTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">122</span>)<br>	at java.base/java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.FutureTask</span><span class="hljs-selector-class">.get</span>(FutureTask<span class="hljs-selector-class">.java</span>:<span class="hljs-number">191</span>)<br>	at Test<span class="hljs-selector-class">.main</span>(Test<span class="hljs-selector-class">.java</span>:<span class="hljs-number">24</span>)<br>Caused by: java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ArithmeticException</span>: / by zero<br>	...<br></code></pre></td></tr></table></figure>



<h3 id="1-7-Fork-x2F-Join-线程池"><a href="#1-7-Fork-x2F-Join-线程池" class="headerlink" title="1.7 Fork&#x2F;Join 线程池"></a>1.7 Fork&#x2F;Join 线程池</h3><p>Fork&#x2F;Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型运算。所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列、都可以用分治思想进行求解</p>
<p>Fork&#x2F;Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率。它默认会创建与 cpu 核心数大小相同的线程池</p>
<p>使用特点：</p>
<ul>
<li>提交给 Fork&#x2F;Join 线程池的任务需要继承 <code>RecursiveTask</code>（有返回值）或 <code>RecursiveAction</code>（没有返回值）</li>
<li>当调用<code>fork</code>，会重新执行<code>compute</code>方法，进行递归运算</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.TestForkJoin2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestForkJoin2</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<span class="hljs-number">4</span>);<br>        System.out.println(pool.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>(<span class="hljs-number">5</span>)));<br><br>        <span class="hljs-comment">// new MyTask(5)  5+ new MyTask(4)  4 + new MyTask(3)  3 + new MyTask(2)  2 + new MyTask(1)</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 1~n 之间整数的和</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyTask</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&quot;</span> + n + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 如果 n 已经为 1，可以求得结果了</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            log.debug(<span class="hljs-string">&quot;join() &#123;&#125;&quot;</span>, n);<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br><br>        <span class="hljs-comment">// 将任务进行拆分(fork)</span><br>        <span class="hljs-type">MyTask</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>(n - <span class="hljs-number">1</span>);<br>        t1.fork();<br>        log.debug(<span class="hljs-string">&quot;fork() &#123;&#125; + &#123;&#125;&quot;</span>, n, t1);<br><br>        <span class="hljs-comment">// 合并(join)结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> n + t1.join();<br>        log.debug(<span class="hljs-string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, n, t1, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">12:12:33.977 [ForkJoinPool-1-worker-4] <span class="hljs-built_in">DEBUG</span> MyTask - fork() 2 + &#123;1&#125;<br>12:12:33.977 [ForkJoinPool-1-worker-3] <span class="hljs-built_in">DEBUG</span> MyTask - fork() 3 + &#123;2&#125;<br>12:12:33.977 [ForkJoinPool-1-worker-2] <span class="hljs-built_in">DEBUG</span> MyTask - fork() 4 + &#123;3&#125;<br>12:12:33.985 [ForkJoinPool-1-worker-4] <span class="hljs-built_in">DEBUG</span> MyTask - join() 1<br>12:12:33.977 [ForkJoinPool-1-worker-1] <span class="hljs-built_in">DEBUG</span> MyTask - fork() 5 + &#123;4&#125;<br>12:12:33.985 [ForkJoinPool-1-worker-4] <span class="hljs-built_in">DEBUG</span> MyTask - join() 2 + &#123;1&#125; = 3<br>12:12:33.985 [ForkJoinPool-1-worker-3] <span class="hljs-built_in">DEBUG</span> MyTask - join() 3 + &#123;2&#125; = 6<br>12:12:33.985 [ForkJoinPool-1-worker-2] <span class="hljs-built_in">DEBUG</span> MyTask - join() 4 + &#123;3&#125; = 10<br>12:12:33.985 [ForkJoinPool-1-worker-1] <span class="hljs-built_in">DEBUG</span> MyTask - join() 5 + &#123;4&#125; = 15<br>15<br></code></pre></td></tr></table></figure>



<h2 id="2-AQS"><a href="#2-AQS" class="headerlink" title="2. AQS"></a>2. AQS</h2><h3 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h3><p>AQS 的全称为 <code>AbstractQueuedSynchronizer</code> ，翻译过来的意思就是抽象队列同步器。这个类在 <code>java.util.concurrent.locks</code> 包下面。它是一个抽象类，主要用来构建锁和同步器。是JDK1.5提供的一套用于实现<strong>阻塞锁</strong>和一系列依赖FIFO等待队列的同步器(First Input First Output先进先出)的框架实现。是除了java自带的synchronized关键字之外的锁机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <br><span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractOwnableSynchronizer</span> <br><span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们常用的ReentrantLock、Semaphore、CountDownLatch、CyclicBarrier等并发类均是基于AQS来实现的。具体用法是通过继承AQS，并实现其模板方法，来达到同步状态的管理。</p>
<p>AQS的功能在使用中可以分为两种：独占锁和共享锁</p>
<ul>
<li>独占锁：每次只能有一个线程持有锁。eg: ReentrantLock就是独占锁</li>
<li>共享锁：允许多个线程同时获得锁，并发访问共享资源。eg: ReentrantReadWriteLock中的读锁、CountDownLatch</li>
</ul>
<h3 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h3><p>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态；如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH (Craig,Landin,and Hagersten) 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<p>CLH队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-AQS%E5%8E%9F%E7%90%86-CLH%E9%98%9F%E5%88%97.png" srcset="/img/loading.gif" lazyload alt="image-20220213114641095"></p>
<p>AQS 使用一个 int 成员变量来表示同步状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<span class="hljs-comment">//共享变量，使用volatile修饰保证线程可见性</span><br></code></pre></td></tr></table></figure>

<p>通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。状态信息通过 <code>protected</code> 类型的<code>getState()</code>，<code>setState()</code>，<code>compareAndSetState()</code> 进行操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//返回同步状态的当前值</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state;<br>&#125;<br> <span class="hljs-comment">// 设置同步状态的值</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(<span class="hljs-type">int</span> newState)</span> &#123;<br>        state = newState;<br>&#125;<br><span class="hljs-comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSetState</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;<br>        <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, expect, update);<br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="3-ThreadLocal"><a href="#3-ThreadLocal" class="headerlink" title="3. ThreadLocal"></a>3. ThreadLocal</h2><p>并发编程是一项非常重要的技术，它让我们的程序变得更加高效。</p>
<p>但在并发的场景中，如果有多个线程同时修改公共变量，可能会出现线程安全问题，即该变量最终结果可能出现异常。</p>
<p>为了解决线程安全问题，<code>JDK</code>出现了很多技术手段，比如：使用<code>synchronized</code>或<code>Lock</code>，给访问公共资源的代码上锁，保证了代码的<code>原子性</code>。</p>
<p>但在高并发的场景中，如果多个线程同时竞争一把锁，这时会存在大量的锁等待，可能会浪费很多时间，让系统的响应时间一下子变慢。</p>
<p>因此，<code>JDK</code>还提供了另外一种用空间换时间的新思路：<code>ThreadLocal</code>。</p>
<p>它的核心思想是：共享变量在每个<code>线程</code>都有一个<code>副本</code>，每个线程操作的都是自己的副本，对另外的线程没有影响。</p>
<p><strong><code>ThreadLocal</code>作用</strong></p>
<p>ThreadLocal 可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】，避免争用引发的线程安全问题。ThreadLocal 同时实现了线程内的资源共享</p>
<p><code>ThreadLocal</code>的内部有一个静态的内部类叫：<code>ThreadLocalMap</code>。<code>ThreadLocal</code>的<code>get</code>方法、<code>set</code>方法和<code>setInitialValue</code>方法，其实最终操作的都是<code>ThreadLocalMap</code>类中的数据。</p>
<p><code>ThreadLocalMap</code>里面包含一个静态的内部类<code>Entry</code>，该类继承于<code>WeakReference</code>类，说明<code>Entry</code>是一个弱引用。</p>
<p><code>ThreadLocalMap</code>内部还包含了一个<code>Entry</code>数组，其中：<code>Entry</code> &#x3D; <code>ThreadLocal</code> + <code>value</code>。</p>
<p>而<code>ThreadLocalMap</code>被定义成了<code>Thread</code>类的成员变量。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eab84b4f8b6e44d9950063d18e2b07c8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>从上图中看出，在每个<code>Thread</code>类中，都有一个<code>ThreadLocalMap</code>的成员变量，该变量包含了一个<code>Entry数组</code>，该数组真正保存了ThreadLocal类set的数据。</p>
<p><code>Entry</code>是由threadLocal和value组成，其中threadLocal对象是弱引用，在<code>GC</code>的时候，会被自动回收。而value就是ThreadLocal类set的数据。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3aa72af4fe2433a9a6c411f3fc99731~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p>图源：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7097754858593189901#heading-1">ThreadLocal夺命11连问 - 掘金 (juejin.cn)</a></p>
</blockquote>
<p>上图中除了Entry的key对ThreadLocal对象是<code>弱引用</code>，其他的引用都是<code>强引用</code>。</p>
<p>需要特别说明的是，上图中ThreadLocal对象我画到了堆上，其实在实际的业务场景中不一定在堆上。因为如果ThreadLocal被定义成了static的，ThreadLocal的对象是类共用的，可能出现在方法区。</p>
<p>* </p>
<p><strong>原理</strong></p>
<p>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p>
<ul>
<li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</li>
<li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</li>
<li>调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li>
</ul>
<p>ThreadLocalMap 的一些特点</p>
<ul>
<li>key 的 hash 值统一分配</li>
<li>初始容量 16，扩容因子 2&#x2F;3，扩容容量翻倍</li>
<li>key 索引冲突后用开放寻址法解决冲突</li>
</ul>
<p><strong>弱引用 key</strong></p>
<p>ThreadLocalMap 中的 key 被设计为弱引用，原因如下</p>
<ul>
<li>Thread 可能需要长时间运行（如线程池中的线程），如果 key 不再使用，需要在内存不足（GC）时释放其占用的内存</li>
</ul>
<p><strong>内存释放时机</strong></p>
<ul>
<li>被动 GC 释放 key<ul>
<li>仅是让 key 的内存释放，关联 value 的内存并不会释放</li>
</ul>
</li>
<li>懒惰被动释放 value<ul>
<li>get key 时，发现是 null key，则释放其 value 内存</li>
<li>set key 时，会使用启发式扫描，清除临近的 null key 的 value 内存，启发次数与元素个数，是否发现 null key 有关</li>
</ul>
</li>
<li>主动 remove 释放 key，value<ul>
<li>会同时释放 key，value 的内存，也会清除临近的 null key 的 value 内存</li>
<li>推荐使用它，因为一般使用 ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收</li>
</ul>
</li>
</ul>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>JUC：Java多线程</div>
      <div>http://jswanyu.github.io/2022/05/13/JUC/Java多线程/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>万宇</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年5月13日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>






<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
