

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="万宇">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、SpringBoot快速入门1. SpringBoot简介略 2. 搭建SpringBoot项目略 3. SpringBoot的简化Spring程序缺点：略 SpringBoot程序的核心功能及优点：  起步依赖（简化依赖配置） 自动配置（简化常用工程相关配置） 辅助功能（内置服务器，……） ……  简化操作都在哪些方面进行体现的：  parent：parent是定义了几百个依赖版本号，以前写">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot">
<meta property="og:url" content="http://jswanyu.github.io/2022/05/03/Spring/03-SpringBoot/index.html">
<meta property="og:site_name" content="Wynn&#39;s blog">
<meta property="og:description" content="一、SpringBoot快速入门1. SpringBoot简介略 2. 搭建SpringBoot项目略 3. SpringBoot的简化Spring程序缺点：略 SpringBoot程序的核心功能及优点：  起步依赖（简化依赖配置） 自动配置（简化常用工程相关配置） 辅助功能（内置服务器，……） ……  简化操作都在哪些方面进行体现的：  parent：parent是定义了几百个依赖版本号，以前写">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/icon/Spring%E5%9B%BE%E6%A0%87.jpeg">
<meta property="article:published_time" content="2022-05-03T08:19:56.000Z">
<meta property="article:modified_time" content="2022-06-20T01:46:11.148Z">
<meta property="article:author" content="万宇">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/icon/Spring%E5%9B%BE%E6%A0%87.jpeg">
  
  
  
  <title>SpringBoot - Wynn&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"jswanyu.github.io","root":"/","version":"1.9.1","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":false},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wynn&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                时间线
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/icon/Spring%E5%9B%BE%E6%A0%87.jpeg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="SpringBoot"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-05-03 16:19" pubdate>
          2022年5月3日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          53k 字
        
      </span>
    

    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">SpringBoot</h1>
            
            <div class="markdown-body">
              
              <h1 id="一、SpringBoot快速入门"><a href="#一、SpringBoot快速入门" class="headerlink" title="一、SpringBoot快速入门"></a>一、SpringBoot快速入门</h1><h2 id="1-SpringBoot简介"><a href="#1-SpringBoot简介" class="headerlink" title="1. SpringBoot简介"></a>1. SpringBoot简介</h2><p>略</p>
<h2 id="2-搭建SpringBoot项目"><a href="#2-搭建SpringBoot项目" class="headerlink" title="2. 搭建SpringBoot项目"></a>2. 搭建SpringBoot项目</h2><p>略</p>
<h2 id="3-SpringBoot的简化"><a href="#3-SpringBoot的简化" class="headerlink" title="3. SpringBoot的简化"></a>3. SpringBoot的简化</h2><p>Spring程序缺点：略</p>
<p>SpringBoot程序的核心功能及优点：</p>
<ul>
<li>起步依赖（简化依赖配置）</li>
<li>自动配置（简化常用工程相关配置）</li>
<li>辅助功能（内置服务器，……）</li>
<li>……</li>
</ul>
<p>简化操作都在哪些方面进行体现的：</p>
<ul>
<li><p>parent：parent是定义了几百个依赖版本号，以前写依赖需要自己手工控制版本，现在由SpringBoot统一管理，这样就不存在版本冲突了，是用来减少依赖冲突的</p>
</li>
<li><p>starter：starter是一个坐标中定了若干个坐标，以前写多个的，现在写一个，是用来减少依赖配置的书写量的</p>
<p>  实际开发中如果需要用什么技术，先去找有没有这个技术对应的starter，如果有对应的starter，直接写starter，而且无需指定版本，版本由parent提供，如果没有对应的starter，手写坐标即可。实际开发中如果发现坐标出现了冲突现象，确认你要使用的可行的版本号，使用手工书写的方式添加对应依赖，覆盖SpringBoot提供给我们的配置管理</p>
</li>
<li><p>引导类：SpringBoot程序启动创建了一个Spring容器对象。这个类在SpringBoot程序中是所有功能的入口，称这个类为引导类。作为一个引导类最典型的特征就是当前类上方声明了一个注解<font color="#ff0000"><b>@SpringBootApplication</b></font></p>
</li>
<li><p>内嵌tomcat：tomcat服务器运行其实是以对象的形式在Spring容器中运行的</p>
</li>
</ul>
<h2 id="4-SpringBoot基础配置"><a href="#4-SpringBoot基础配置" class="headerlink" title="4. SpringBoot基础配置"></a>4. SpringBoot基础配置</h2><p>SpringBoot将所有配置信息集中在一个文件中，application.properties</p>
<p>具体有哪些配置信息可以见[官网说明文档](<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties">Common Application Properties (spring.io)</a>)</p>
<p>SpringBoot除了支持properties格式的配置文件，还支持另外两种格式的配置文件：yml格式、yaml格式，<strong>以后基本上都是用yml格式的</strong></p>
<p>yml格式的语法规则需要注意下，用多了也就熟悉了</p>
<p>读取yml文件的数据：</p>
<p>一般会将yml文件中的一组数据封装成一个对象，并将该对象纳入Spring管控的范围，也就是定义成一个bean，然后使用注解**@ConfigurationProperties**指定该对象加载哪一组yaml中配置的信息</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/SpringBoot-%E8%AF%BB%E5%8F%96yml%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE.png" srcset="/img/loading.gif" lazyload alt="image-20211126181126382"></p>
<h1 id="二、SpringBoot整合常见框架"><a href="#二、SpringBoot整合常见框架" class="headerlink" title="二、SpringBoot整合常见框架"></a>二、SpringBoot整合常见框架</h1><h2 id="1-SpringBoot整合的核心"><a href="#1-SpringBoot整合的核心" class="headerlink" title="1. SpringBoot整合的核心"></a>1. SpringBoot整合的核心</h2><p>整合第三方技术分为如下步骤：</p>
<ol>
<li>导入对应技术的starter坐标</li>
</ol>
<table>
<thead>
<tr>
<th>starter所属</th>
<th>命名规则</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>官方提供</td>
<td>spring-boot-starter-技术名称</td>
<td>spring-boot-starter-web <br/>spring-boot-starter-test</td>
</tr>
<tr>
<td>第三方提供</td>
<td>第三方技术名称-spring-boot-starter</td>
<td>druid-spring-boot-starter</td>
</tr>
<tr>
<td>第三方提供</td>
<td>第三方技术名称-boot-starter（第三方技术名称过长，简化命名）</td>
<td>mybatis-plus-boot-starter</td>
</tr>
</tbody></table>
<ol start="2">
<li>根据对应技术的要求做配置</li>
</ol>
<h2 id="2-整合JUnit"><a href="#2-整合JUnit" class="headerlink" title="2. 整合JUnit"></a>2. 整合JUnit</h2><p>使用SpringBoot整合JUnit需要保障导入test对应的starter，由于初始化项目时此项是<strong>默认导入</strong>的，SpringBoot的工程到底还是Maven工程，它是离不开测试的，所以Springboot默认整合了测试功能</p>
<p>整合步骤</p>
<ol>
<li>导入测试对应的starter</li>
<li>测试类使用@SpringBootTest修饰</li>
<li>使用自动装配的形式添加要测试的对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot04JunitApplicationTests</span> &#123;<br>    <span class="hljs-comment">//注入你要测试的对象</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> BookDao bookDao;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//执行要测试的对象对应的方法</span><br>        bookDao.save();<br>        System.out.println(<span class="hljs-string">&quot;two...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>多讲一些，Spring整合JUnit时主要靠两个注解，<strong>注解@RunWith</strong>是设置Spring专用于测试的类运行器，简单说就是Spring程序执行程序有自己的一套独立的运行程序的方式，不能使用JUnit提供的类运行方式了，必须指定一下，但是格式是固定的。第二个<strong>注解@ContextConfiguration</strong>是用来设置Spring核心配置文件或配置类的，简单说就是加载Spring的环境你要告诉Spring具体的环境配置是在哪里写的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//加载spring整合junit专用的类运行器</span><br><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-comment">//指定对应的配置信息</span><br><span class="hljs-meta">@ContextConfiguration(classes = SpringConfig.class)</span><br></code></pre></td></tr></table></figure>

<p>由于这两个注解每次都是一样的东西，SpringBoot进行开发简化，用一个注解@SpringBootTest替换了前面两个注解。</p>
<p>加载的配置类或者配置文件是哪一个？就是我们前面启动程序使用的引导类。如果想手工指定引导类有两种方式，第一种方式使用属性的形式进行，在注解@SpringBootTest中添加classes属性指定配置类</p>
<p>但测试类如果存在于引导类所在包或子包中无需指定引导类；测试类如果不存在于引导类所在的包或子包中需要通过classes属性指定引导类</p>
<p><font color="#ff0000"><b>注意让pom.xml里不要再额外导入Junit坐标，否则@Test会按照JUnit的来，而不是按照SpringBootTest的来</b></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@SpringBootTest(classes = Springboot04JunitApplication.class)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot04JunitApplicationTests</span> &#123;<br>    <span class="hljs-comment">//注入你要测试的对象</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> BookDao bookDao;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//执行要测试的对象对应的方法</span><br>        bookDao.save();<br>        System.out.println(<span class="hljs-string">&quot;two...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    第二种方式回归原始配置方式，仍然使用@ContextConfiguration注解进行，效果是一样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-meta">@ContextConfiguration(classes = Springboot04JunitApplication.class)</span><br></code></pre></td></tr></table></figure>



<h2 id="3-整合MyBatis"><a href="#3-整合MyBatis" class="headerlink" title="3. 整合MyBatis"></a>3. 整合MyBatis</h2><p>整合步骤：</p>
<ol>
<li>创建模块时勾选要使用的技术，MyBatis，由于要操作数据库，还要勾选对应数据库MySQL。或者手工导入坐标</li>
</ol>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/SpringBoot-%E6%95%B4%E5%90%88Mybatis-%E5%8B%BE%E9%80%89%E6%8A%80%E6%9C%AF.png" srcset="/img/loading.gif" lazyload alt="image-20211129092210993"></p>
<ol start="2">
<li>配置数据源相关信息</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/ssm</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">12</span><br></code></pre></td></tr></table></figure>

<ol start="3">
<li><p>数据库SQL映射需要添加@Mapper被容器识别到。即构建DAO接口，并添加@Mapper注解</p>
</li>
<li><p>使用自动装配的形式添加要测试的对象</p>
</li>
</ol>
<h2 id="4-整合MyBatis-Plus"><a href="#4-整合MyBatis-Plus" class="headerlink" title="4. 整合MyBatis-Plus"></a>4. 整合MyBatis-Plus</h2><p>MyBaitsPlus（简称MP），中国人开发的技术</p>
<p>整合步骤：</p>
<ol>
<li><p>导入对应的starter</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>配置数据源相关信息</p>
 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/ssm</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">12</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>数据库SQL映射需要添加@Mapper被容器识别到。即构建DAO接口，并添加@Mapper注解。这里涉及到MP的最核心功能：就是<strong>MP预定了若干个常用的API接口，简化了通用API接口的开发工作</strong>。即让自己构建的DAO接口继承</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;Book&gt; &#123;&#125;<br></code></pre></td></tr></table></figure>

<p> 这个BaseMapper预定了若干个常用的API接口，比如增删改查</p>
<p> <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/SpringBoot-%E6%95%B4%E5%90%88MP-BaseMapper.png" srcset="/img/loading.gif" lazyload alt="image-20211129100313919"></p>
</li>
<li><p>使用自动装配的形式添加要测试的对象</p>
</li>
</ol>
<h2 id="5-整合数据源"><a href="#5-整合数据源" class="headerlink" title="5. 整合数据源"></a>5. 整合数据源</h2><p>这里整合数据源的指的其实是指定整合第三方的数据库连接池技术</p>
<p>注意区分JDBC、数据库连接池、Mybatis的区别：</p>
<ul>
<li><p>JDBC(Java Database Connectivity)是一个<strong>独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口</strong>，它是直接访问数据库。JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可</p>
</li>
<li><p>数据库连接池技术：负责分配、管理和释放数据库连接，它<strong>允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</strong>。JDBC 的数据库连接池使用 javax.sql.DataSource来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat) 提供实现，也有一些开源组织提供实现，比如：DBCP 、C3P0 、Druid等。</p>
</li>
<li><p>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。但注意JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。MyBatis是可以选择数据库连接方式的，可以选择每请求一次就连接再关闭，也可以选择连接池的开源技术，比如DBCP 、C3P0 、Druid等。</p>
</li>
</ul>
<p>前面整合MyBatis和MP的时候，使用的数据源对象都是SpringBoot默认的数据源对象，即HiKari</p>
<p>黑马的教程里是整合了Druid，这里就暂时用默认的了</p>
<h1 id="三、SSMP初步整合综合案例"><a href="#三、SSMP初步整合综合案例" class="headerlink" title="三、SSMP初步整合综合案例"></a>三、SSMP初步整合综合案例</h1><p>简单的图书管理系统，实现基本的增删改查功能。代码以IDEA工程文件里为主，有些业务层的方法名称和黑马教程里没有统一</p>
<h2 id="0-架构设计"><a href="#0-架构设计" class="headerlink" title="0. 架构设计"></a>0. 架构设计</h2><p>略</p>
<h2 id="1-实体类开发"><a href="#1-实体类开发" class="headerlink" title="1. 实体类开发"></a>1. 实体类开发</h2><p>springboot_05_ssmp-main-java-com-itheima-domain-Book.java</p>
<p>这里用到一个小工具，lombok。一个Java类库，提供了一组注解，简化POJO实体类开发，SpringBoot目前默认集成了lombok技术，并提供了对应的版本控制，所以只需在pom.xml中添加lombok的坐标。</p>
<p>使用lombok可以通过一个<strong>注解@Data</strong>完成一个实体类对应的getter，setter，toString，equals，hashCode等操作的快速添加</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String type;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String description;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="2-数据层开发——基础CRUD"><a href="#2-数据层开发——基础CRUD" class="headerlink" title="2. 数据层开发——基础CRUD"></a>2. 数据层开发——基础CRUD</h2><p>springboot_05_ssmp-main-java-com-itheima-dao-BookDao.java</p>
<p>数据层开发本次使用MyBatisPlus技术，导入starter，配置数据库连接，使用MP的标准通用接口BaseMapper加速开发，指定**@Mapper**和泛型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;Book&gt; &#123; &#125;<br></code></pre></td></tr></table></figure>

<p>MP技术默认的主键生成策略为雪花算法，生成的主键ID长度较大，本案例中设置自增即可，在application.yml中添加对应配置。</p>
<p>同时配置查阅执行期SQL语句</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">db-config:</span><br>      <span class="hljs-attr">table-prefix:</span> <span class="hljs-string">tbl_</span> <span class="hljs-comment">#设置表名通用前缀</span><br>      <span class="hljs-attr">id-type:</span> <span class="hljs-string">auto</span>      <span class="hljs-comment">#设置主键id字段的生成策略为参照数据库设定的策略，当前数据库设置id生成策略为自增</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span>  <span class="hljs-comment"># 打印sql语句日志</span><br></code></pre></td></tr></table></figure>

<p>随后应该制作测试类测试结果，这个测试类制作是个好习惯</p>
<p>其中最重要的一步便是注入Bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> BookDao bookDao;<br></code></pre></td></tr></table></figure>





<h2 id="3-数据层开发——分页功能制作"><a href="#3-数据层开发——分页功能制作" class="headerlink" title="3. 数据层开发——分页功能制作"></a>3. 数据层开发——分页功能制作</h2><p>MP给我们提供了几乎所有的基础操作，包括了分页操作</p>
<p>主要是用一个<code>selectPage()</code>方法，它需要传入一个封装分页数据的对象，可以通过new的形式创建这个对象，当然这个对象也是MP提供的。创建此对象时就需要指定分页的两个基本数据</p>
<ul>
<li>当前显示第几页</li>
<li>每页显示几条数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">IPage</span> <span class="hljs-variable">page</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure>

<p>将该对象传入到查询方法selectPage后，可以得到查询结果，但是我们会发现当前操作查询结果返回值仍然是一个IPage对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">IPage</span> <span class="hljs-variable">page</span> <span class="hljs-operator">=</span> bookDao.selectPage(page, <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure>

<p>这个IPage对象中又封装了若干个数据，而查询的结果作为IPage对象封装的一个数据存在的，可以理解为查询结果得到后，又塞到了这个IPage对象中，其实还是为了高度的封装，一个IPage描述了分页所有的信息。下面5个操作就是IPage对象中封装的所有信息了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetPage</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">IPage</span> <span class="hljs-variable">page</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>);<br>    bookDao.selectPage(page, <span class="hljs-literal">null</span>);<br>    System.out.println(page.getCurrent());		<span class="hljs-comment">//当前页码值</span><br>    System.out.println(page.getSize());			<span class="hljs-comment">//每页显示数</span><br>    System.out.println(page.getTotal());		<span class="hljs-comment">//数据总量</span><br>    System.out.println(page.getPages());		<span class="hljs-comment">//总页数</span><br>    System.out.println(page.getRecords());		<span class="hljs-comment">//详细数据</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上这个分页当前是无效的，因为在这之前还有一步</p>
<p>MySQL的分页操作使用limit关键字进行，而其他数据库可能使用别的关键字，这个时候MP为了制作的兼容性强，将分页操作设置为基础查询操作的升级版，基础操作中有查询全部的功能，而在这个基础上只需要升级一下就可以得到分页操作。所以MP将分页操作做成了一个开关，你用分页功能就把开关开启，不用就不需要开启这个开关。而我们现在没有开启这个开关，所以分页操作是没有的。这个开关是通过<strong>MP的拦截器</strong>的形式存在的。具体设置方式如下</p>
<p><strong>定义MP拦截器并将其设置为Spring管控的bean</strong>，使用@Bean即可，不加此注解，MP便无法打开分页功能开关</p>
<p>springboot_05_ssmp-main-java-com-itheima-config-MPconfig.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MPConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 创建MP的拦截器栈，这个时候拦截器栈中没有具体的拦截器</span><br>        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>        <span class="hljs-comment">// 初始化了分页拦截器，并添加到拦截器栈中</span><br>        interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>());<br>        <span class="hljs-keyword">return</span> interceptor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果后期开发其他功能，需要添加全新的拦截器，按照第二行的格式继续add进去新的拦截器就可以了。</p>
<p>后续的分页操作还要和服务器传入的参数配合使用</p>
<h2 id="4-数据层开发——条件查询功能制作"><a href="#4-数据层开发——条件查询功能制作" class="headerlink" title="4. 数据层开发——条件查询功能制作"></a>4. 数据层开发——条件查询功能制作</h2><p>MP还提供有强大的条件查询功能，<code>QueryWrapper</code>对象是一个用于封装查询条件的对象，该对象可以动态使用API调用的方法添加条件，最终转化成对应的SQL语句。添加的条件可以有很多，需要什么条件，使用QueryWapper对象直接调用对应操作即可。比如做大于小于关系，就可以使用lt或gt方法，等于使用eq方法，等等。下面的操作就是执行一个模糊匹配对应的操作，由like条件书写变为了like方法的调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetBy</span><span class="hljs-params">()</span>&#123;<br>    QueryWrapper&lt;Book&gt; qw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    qw.like(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;Spring&quot;</span>);<br>    bookDao.selectList(qw);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是这组API使用关于属性字段名的书写存在着安全隐患，比如查询字段name，当前是以字符串的形态书写的，万一写错，编译器还没有办法发现，只能将问题抛到运行器通过异常堆栈告诉开发者，不太友好。MP针对字段检查进行了功能升级，全面支持Lambda表达式，就有了下面这组API。由QueryWrapper对象升级为<code>LambdaQueryWrapper</code>对象，这下就变了上述问题的出现，<strong>以后更推荐使用这种对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetBy2</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Spring&quot;</span>;<br>    LambdaQueryWrapper&lt;Book&gt; lqw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;Book&gt;();<br>    lqw.like(Book::getName,name);<br>    bookDao.selectList(lqw);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>为了便于开发者动态拼写SQL，防止将null数据作为条件使用（经常会过滤掉null数据），MP还提供了动态拼装SQL的快捷书写方式。其实就是个格式，没有区别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetBy2</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>;<br>    LambdaQueryWrapper&lt;Book&gt; lqw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;Book&gt;();<br>    <span class="hljs-comment">//if(name != null) lqw.like(Book::getName,name);		//方式一：JAVA代码控制</span><br>    lqw.like(name != <span class="hljs-literal">null</span>,Book::getName,name);				<span class="hljs-comment">//方式二：API接口提供控制开关</span><br>    bookDao.selectList(lqw);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>更详细的操作可以去MP知识点里学习</p>
<h2 id="5-业务层开发"><a href="#5-业务层开发" class="headerlink" title="5. 业务层开发"></a>5. 业务层开发</h2><p>业务层开发是组织业务逻辑功能，并根据业务需求，对数据持久层发起调用。先补充下常识性知识：</p>
<p>业务层的方法名定义<font color="#ff0000"><b>一定要与业务有关</b></font>，例如登录操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">login(String username,String password);<br></code></pre></td></tr></table></figure>

<p>而数据层的方法名定义<font color="#ff0000"><b>一定与业务无关</b></font>，是一定，不是可能，也不是有可能，例如根据用户名密码查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">selectByUserNameAndPassword(String username,String password);<br></code></pre></td></tr></table></figure>

<p>我们在开发的时候是可以根据完成的工作不同划分成不同职能的开发团队的。比如一个哥们制作数据层，他就可以不知道业务是什么样子，拿到的需求文档要求可能是这样的</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">接口：传入用户名与密码字段，查询出对应结果，结果是单条数据<br>接口：传入ID字段，查询出对应结果，结果是单条数据<br>接口：传入离职字段，查询出对应结果，结果是多条数据<br></code></pre></td></tr></table></figure>

<p>但是进行业务功能开发的哥们，拿到的需求文档要求差别就很大</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">接口：传入用户名与密码字段，对用户名字段做长度校验，4-15位，对密码字段做长度校验，8到24位，对喵喵喵字段做特殊字符校验，不允许存在空格，查询结果为对象。如果为null，返回BusinessException，封装消息码INFO<span class="hljs-built_in">_</span>LOGON<span class="hljs-built_in">_</span>USERNAME<span class="hljs-built_in">_</span>PASSWORD<span class="hljs-built_in">_</span>ERROR<br></code></pre></td></tr></table></figure>

<p>你比较一下，能是一回事吗？差别太大了，所以说业务层方法定义与数据层方法定义差异化很大，只不过有些入门级的开发者手懒或者没有使用过公司相关的ISO标准化文档而已。</p>
<p>但此案例的功能还是CRUD为主，可能不太能体会到其中的差距，慢慢来吧。</p>
<p>业务层接口定义如下，注意业务层和数据层的命名区分：save&#x3D;&gt;insert, delete&#x3D;&gt;remove, getXxx&#x3D;&gt;selectXxx</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookService</span> &#123;<br>    Boolean <span class="hljs-title function_">save</span><span class="hljs-params">(Book book)</span>;<br>    Boolean <span class="hljs-title function_">update</span><span class="hljs-params">(Book book)</span>;<br>    Boolean <span class="hljs-title function_">remove</span><span class="hljs-params">(Integer id)</span>;<br>    Book <span class="hljs-title function_">getById</span><span class="hljs-params">(Integer id)</span>;<br>    List&lt;Book&gt; <span class="hljs-title function_">getAll</span><span class="hljs-params">()</span>;<br>    IPage&lt;Book&gt; <span class="hljs-title function_">getPage</span><span class="hljs-params">(<span class="hljs-type">int</span> currentPage,<span class="hljs-type">int</span> pageSize)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于是CRUD为主，所以业务层实现类转调数据层方法即可，这里数据层的方法都是MP提供的，详见springboot_05_ssmp-main-java-com-itheima-service-impl-BookServiceImpl.java</p>
<p>补充：业务层快速开发</p>
<p>其实MP技术不仅提供了数据层快速开发方案，业务层MP也给了一个通用接口，但<strong>不推荐使用</strong>，大多是数据层类似的方法。真正开发时业务层比较复杂，需求不可能是通用的，建议自己开发更好一点。具体见项目里：</p>
<p>springboot_05_ssmp-main-java-com-itheima-service-BookService2.java</p>
<p>springboot_05_ssmp-main-java-com-itheima-service-impl-BookServiceImpl2.java</p>
<h2 id="6-表现层开发"><a href="#6-表现层开发" class="headerlink" title="6. 表现层开发"></a>6. 表现层开发</h2><p>表现层的开发使用基于Restful的表现层接口开发，功能测试通过Postman工具进行（在使用Postman测试时关注提交类型，对应上即可，不然就会报405的错误码了）。在初学时其实主要是注解的使用</p>
<blockquote>
<p>RESTful 不是一种规范，而是一种风格，它不具有强制性。REST – REpresentational State Transfer，表现层状态转移</p>
<p>总结来说，就是URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。</p>
<p>GET 用来获取资源，POST 用来新建资源（也可以用于更新资源），PUT 用来更新资源，DELETE 用来删除资源。</p>
</blockquote>
<p>基本的CRUD表现层开发是很简单的，基本就是调用业务层的方法，创建一个controller包，用于放置表现层代码，具体见：</p>
<p>springboot_05_ssmp-main-java-com-itheima-controller-Bookcontroller.java</p>
<p>表现层的重点是如何获取前端发送的请求，这需要使用诸多注解（以下的注解都是简单介绍，没有写每一个注解非常详细的语法，用到再查）</p>
<h3 id="注解-RestController"><a href="#注解-RestController" class="headerlink" title="注解@RestController"></a>注解@RestController</h3><p>（1）如何让Spring知道这段代码是表现层代码。使用<strong>注解@RestController</strong></p>
<p>@RestController可以理解为Springmvc学习时的@Controller 加上 @ResponseBody，使用<strong>此注解此次请求将不再走视图处理器，而是直接将此响应结果写入到输入流中，其效果等同于使用response对象输出指定格式的数据</strong>。@RestController主要用于更加方便的构建 RESTful Web 服务。它将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。在 RESTful 的服务中，我们大部分情况是使用 JSON 为返回数据的，所以你可以直接使用  @RestController 替换掉 @Controller 和 @ResponseBody。</p>
<h3 id="注解-ResponseBody"><a href="#注解-ResponseBody" class="headerlink" title="注解@ResponseBody"></a>注解@ResponseBody</h3><p>上面提到的@ResponseBody也是使用在controller层的方法上，当方法上面没有写@ResponseBody，底层会将方法的返回值封装为<strong>ModelAndView对象</strong>（可以简单理解为返回的是html文件）。如果加上了@ResponseBody，会将方法的返回值，以特定的格式写入到response的body区域，进而将<strong>数据</strong>返回给客户端。 如果返回值是字符串，那么<strong>直接将字符串</strong>写到客户端；如果是一个对象，会将<strong>对象转化为json串</strong>，然后写到客户端。</p>
<h3 id="注解-RequestMapping"><a href="#注解-RequestMapping" class="headerlink" title="注解@RequestMapping"></a>注解@RequestMapping</h3><p>（2）定义处理请求的 URL 地址，使用<strong>注解@RequestMapping</strong></p>
<p>我们希望访问不同表现层代码的时候使用不同的URL 地址，这就用到了注解@RequestMapping，该注解可以定义请求的 URL 地址和 http method 类型，如 GET、POST 等，其他的不常用的操作包括可以定义请求的 URL 中必须包含的参数。或者不包含某些参数、定义请求中 Request Headers 必须包含的参数。或者不包含某些参数</p>
<p>@RequestMapping 有两种标注方式，一种是标注在类级别上，相当于一个命名空间，即访问该 Controller 下的任意方法都需要带上这个命名空间。比如本次的BookController类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/books&quot;)</span>  <span class="hljs-comment">// 请求此控制器的URL地址为“根目录/books”</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookController</span> &#123;...&#125;<br></code></pre></td></tr></table></figure>

<p>一种是标注在方法级别上，用于进一步指定到处理方法的映射关系（本案例中没有用到）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RequestMapping(&quot;/todo&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;example_todo_page&quot;</span>; <span class="hljs-comment">// 请求此表现层类的URL地址一定为“根目录/books/todo”</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>后续的具体RequestMapping注解，改为对应的方法Mapping注解，比如@GetMapping、@PostMapping、@PutMapping、@DeleteMapping()</strong></p>
<p>（3）注入业务层对象，使用<strong>注解@Autowired</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> BookService bookService;<br></code></pre></td></tr></table></figure>



<h3 id="注解-PathVariable"><a href="#注解-PathVariable" class="headerlink" title="注解@PathVariable"></a>注解@PathVariable</h3><p>（4）增删改查中的查询操作，使用get方法，使用**@GetMapping注解**。查询有三个操作：查询全部，按照指定id查询，分页查询</p>
<p>对于查询全部的操作，不需要使用其他注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// postman选择get方法，测试url：http://localhost/books</span><br><span class="hljs-meta">@GetMapping</span><br><span class="hljs-keyword">public</span> List&lt;Book&gt; <span class="hljs-title function_">getAll</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">return</span> bookService.getAll();&#125;<br></code></pre></td></tr></table></figure>

<p>对于按照传入的id进行查询，需要使用**注解@PathVariable()**接受请求路径中占位参数的数据。</p>
<p>@PathVariable用来接收请求路径中占位符参数{xxx}的值，将其绑定到处理器类的方法形参中。</p>
<ul>
<li>只有一个参数的情况下，可以省略@PathVariable括号后的参数：如</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// postman选择get方法，测试url：http://localhost/books/3</span><br><span class="hljs-meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Book <span class="hljs-title function_">getById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span>&#123;<span class="hljs-keyword">return</span> bookService.getById(id);&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>有多个参数的情况下@PathVariable括号里的参数用双引号包起来，并且要和占位符参数相同，后面的形参可以随便起名字，比如下面这段分页的查询</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// postman选择get方法，测试url：http://localhost/books/1/5</span><br><span class="hljs-meta">@GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)</span><br><span class="hljs-keyword">public</span> IPage&lt;Book&gt; <span class="hljs-title function_">getPage</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;currentPage&quot;)</span> <span class="hljs-type">int</span> a, <span class="hljs-meta">@PathVariable(&quot;pageSize&quot;)</span> <span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> bookService.getPage(a,b);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>但多个参数更规范的用法是形参命名保持和占位符相同，然后就可以省略@PathVariable的括号</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// postman选择get方法，测试url：http://localhost/books/1/5</span><br><span class="hljs-meta">@GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)</span><br><span class="hljs-keyword">public</span> IPage&lt;Book&gt; <span class="hljs-title function_">getPage</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> <span class="hljs-type">int</span> currentPage, <span class="hljs-meta">@PathVariable</span> <span class="hljs-type">int</span> pageSize)</span>&#123;<br>    <span class="hljs-keyword">return</span> bookService.getPage(currentPage,pageSize);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="注解-RequestParam"><a href="#注解-RequestParam" class="headerlink" title="注解@RequestParam"></a>注解@RequestParam</h3><p>控制器获取请求参数用到的注解除了上面的@PathVariable，还有一个<strong>注解@RequestParam</strong>，不同于@PathVariable是接受请求路径中<strong>占位符</strong>参数的值，@RequestParam适用于URL里带上了参数名，并指定了数值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 体会下两个URL的区别</span><br>http:<span class="hljs-comment">//localhost/books/1       //使用 @PathVariable</span><br>http:<span class="hljs-comment">//localhost/books?id=1    //使用 @RequestParam</span><br><br>测试URL：http:<span class="hljs-comment">//localhost/books/testRequestParam?id=1</span><br><span class="hljs-meta">@GetMapping(&quot;/testRequestParam&quot;)</span><br><span class="hljs-keyword">public</span> Book <span class="hljs-title function_">getById</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;id&quot;)</span> Integer id)</span>&#123;<span class="hljs-keyword">return</span> bookService.getById(id);&#125;<br></code></pre></td></tr></table></figure>

<p><strong>但一般控制器获取简单的请求参数还是用@PathVariable搭配GET方法</strong></p>
<h3 id="注解-RequestBody"><a href="#注解-RequestBody" class="headerlink" title="注解@RequestBody"></a>注解@RequestBody</h3><p>（5）增删改查中的增加操作，使用post方法，使用注解@PostMapping。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@PostMapping</span><br><span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Book book)</span>&#123;<span class="hljs-keyword">return</span> bookService.save(book);&#125;<br></code></pre></td></tr></table></figure>

<p>最常用的请求体传参的无疑是POST请求了，毕竟GET方法明文传参，并且URL有长度限制</p>
<p>此处暂时略过简单的post请求获取方式，其实就是定义一个方法获取html文件中相同参数的属性值，此处不过多介绍</p>
<p>JSON数据广泛的应用在axios异步请求中（在网页上什么都没干，但其实已经与后端交互了，比如注册时输入用户名，页面没有刷新，但后台会验证用户名是否重复）。它能够把Java对象通过JSON字符串解析，转为JS对象</p>
<p>如果是获取复杂的JSON数据，则是用@RequestBody注解。@RequestParam和@PathVariable都不利于传递JSON数据，@RequestBody主要用来接收前端传递给后端的JSON字符串中的数据（请求体中的数据）。使用@RequestBody接收数据时，一般都用POST方式进行提交（PUT也可以）</p>
<p>（6）增删改查中的修改操作，使用put方法，使用注解@PutMapping。同样使用@RequestBody传递JSON数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@PutMapping</span><br><span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Book book)</span>&#123;<span class="hljs-keyword">return</span> bookService.update(book);&#125;<br></code></pre></td></tr></table></figure>



<p>（7）增删改查中的删除操作，使用delete方法，使用注解@DeleteMapping。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span>&#123;<span class="hljs-keyword">return</span> bookService.remove(id);&#125;<br></code></pre></td></tr></table></figure>





<h2 id="7-表现层消息一致性处理"><a href="#7-表现层消息一致性处理" class="headerlink" title="7.表现层消息一致性处理"></a>7.表现层消息一致性处理</h2><p>此前通过Postman测试后业务层接口功能是通的，但是这样的结果给到前端开发者会出现一个小问题。不同的操作结果所展示的数据格式差异化严重。必须将所有操作的操作结果数据格式统一起来，需要设计表现层返回结果的模型类，用于后端与前端进行数据格式统一，也称为<strong>前后端数据协议</strong>。模型类如下所示，注意还需要为其生成各种构造器，相关代码在</p>
<p>springboot_05_ssmp-main-java-com-itheima-controller-utils-R.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">R</span> &#123;<br>    <span class="hljs-keyword">private</span> Boolean flag;<br>    <span class="hljs-keyword">private</span> Object data;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对应的表现层各个方法返回类型也需要修改下</p>
<p>springboot_05_ssmp-main-java-com-itheima-controller-Bookcontroller2.java</p>
<p>设计统一的返回值结果类型便于前端开发读取数据，返回值结果类型可以根据需求自行设定，没有固定格式。返回值结果模型类用于后端与前端进行数据格式统一，也称为前后端数据协议</p>
<h2 id="8-前后端联通性测试"><a href="#8-前后端联通性测试" class="headerlink" title="8.前后端联通性测试"></a>8.前后端联通性测试</h2><p>后端的表现层接口开发完毕，就可以进行前端的开发了。将前端人员开发的页面保存到lresources目录下的static目录中，建议<strong>执行maven的clean生命周期，避免缓存的问题出现。</strong>这点非常重要！！！很多网站响应问题都是idea的bug导致的</p>
<p>在进行具体的功能开发之前，先做联通性的测试，通过页面发送异步提交（axios），这一步调试通过后再进行进一步的功能开发。</p>
<p>在vue的钩子函数中，执行getAll()操作，进行联通性的测试。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAll</span>();<br>&#125;,<br></code></pre></td></tr></table></figure>

<p>getAll()内容是用axios发送异步请求，获取数据后确认前后端是否联通</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//列表</span><br><span class="hljs-title function_">getAll</span>(<span class="hljs-params"></span>) &#123;<br>	axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/books&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>		<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>);<br>	&#125;);<br>&#125;,<br></code></pre></td></tr></table></figure>

<p>更多具体的axios细节可以其他地方进一步学习，此处略</p>
<h2 id="9-页面基础功能开发"><a href="#9-页面基础功能开发" class="headerlink" title="9.页面基础功能开发"></a>9.页面基础功能开发</h2><h3 id="9-1-列表功能（非分页版）"><a href="#9-1-列表功能（非分页版）" class="headerlink" title="9.1 列表功能（非分页版）"></a>9.1 列表功能（非分页版）</h3><p>列表功能主要操作就是加载完数据，将数据展示到页面上，此处要利用VUE的数据模型绑定，发送请求得到数据，然后页面上读取指定数据即可</p>
<p>​    <strong>页面数据模型定义</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">data:&#123;<br>	dataList: [],//当前页要展示的列表数据<br>	...<br>&#125;,<br></code></pre></td></tr></table></figure>

<p>​        异步请求获取数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">//列表</span><br><span class="hljs-title function_">getAll</span>(<span class="hljs-params"></span>) &#123;<br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/books&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataList</span> = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>;<br>    &#125;);<br>&#125;,<br></code></pre></td></tr></table></figure>

<p>​        这样在页面加载时就可以获取到数据，并且由VUE将数据展示到页面上了</p>
<h3 id="9-2-添加功能"><a href="#9-2-添加功能" class="headerlink" title="9.2 添加功能"></a>9.2 添加功能</h3><p>添加功能用于收集数据的表单是通过一个弹窗展示的，因此在添加操作前首先要进行弹窗的展示，添加后隐藏弹窗即可。因为这个弹窗一直存在，因此当页面加载时首先设置这个弹窗为不可显示状态，需要展示，切换状态即可</p>
<p>​        <strong>默认状态</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">data:&#123;<br>	dialogFormVisible: false,//添加表单是否可见<br>	...<br>&#125;,<br></code></pre></td></tr></table></figure>

<p>​        <strong>切换为显示状态</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-attr">methods</span>: &#123;<br>    ...<br>      <span class="hljs-comment">//弹出添加窗口</span><br>    <span class="hljs-title function_">handleCreate</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">dialogFormVisible</span> = <span class="hljs-literal">true</span>;<br>    &#125;,  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        由于每次添加数据都是使用同一个弹窗录入数据，所以每次操作的痕迹将在下一次操作时展示出来，需要在每次操作之前清理掉上次操作的痕迹</p>
<p>​        <strong>定义清理数据操作</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>: &#123;<br>    ...<br>    <span class="hljs-comment">//重置表单</span><br>    <span class="hljs-title function_">resetForm</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">formData</span> = &#123;&#125;;<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        <strong>切换弹窗状态时清理数据</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>: &#123;<br>    ...<br>      <span class="hljs-comment">//弹出添加窗口</span><br>    <span class="hljs-title function_">handleCreate</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">dialogFormVisible</span> = <span class="hljs-literal">true</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">resetForm</span>();<br>    &#125;,  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        至此准备工作完成，下面就要调用后台完成添加操作了</p>
<p>​        <strong>添加操作</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//添加</span><br>handleAdd () &#123;<br>    <span class="hljs-comment">//发送异步请求</span><br>    axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/books&quot;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">formData</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>        <span class="hljs-comment">//如果操作成功，关闭弹层，显示数据</span><br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-property">data</span>.<span class="hljs-property">flag</span>)&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">dialogFormVisible</span> = <span class="hljs-literal">false</span>;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">$message</span>.<span class="hljs-title function_">success</span>(<span class="hljs-string">&quot;添加成功&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">$message</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;添加失败&quot;</span>);<br>        &#125;<br>    &#125;).<span class="hljs-title function_">finally</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAll</span>();<br>    &#125;);<br>&#125;,<br></code></pre></td></tr></table></figure>

<ol>
<li>将要保存的数据传递到后台，通过post请求的第二个参数传递json数据到后台</li>
<li>根据返回的操作结果决定下一步操作<ul>
<li>如何是true就关闭添加窗口，显示添加成功的消息</li>
<li>如果是false保留添加窗口，显示添加失败的消息</li>
</ul>
</li>
<li>无论添加是否成功，页面均进行刷新，动态加载数据（对getAll操作发起调用）</li>
</ol>
<p>​        <strong>取消添加操作</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">//取消</span><br><span class="hljs-title function_">cancel</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dialogFormVisible</span> = <span class="hljs-literal">false</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$message</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;操作取消&quot;</span>);<br>&#125;,<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>请求方式使用POST调用后台对应操作</li>
<li>添加操作结束后动态刷新页面加载数据</li>
<li>根据操作结果不同，显示对应的提示信息</li>
<li>弹出添加Div时清除表单数据</li>
</ol>
<h3 id="9-3-删除功能"><a href="#9-3-删除功能" class="headerlink" title="9.3 删除功能"></a>9.3 删除功能</h3><p>模仿添加操作制作删除功能，差别之处在于删除操作仅传递一个待删除的数据id到后台即可</p>
<p><strong>删除操作</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// 删除</span><br><span class="hljs-title function_">handleDelete</span>(<span class="hljs-params">row</span>) &#123;<br>    axios.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&quot;/books/&quot;</span>+row.<span class="hljs-property">id</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-property">data</span>.<span class="hljs-property">flag</span>)&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">$message</span>.<span class="hljs-title function_">success</span>(<span class="hljs-string">&quot;删除成功&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">$message</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;删除失败&quot;</span>);<br>        &#125;<br>    &#125;).<span class="hljs-title function_">finally</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAll</span>();<br>    &#125;);<br>&#125;,<br></code></pre></td></tr></table></figure>

<p>​        <strong>删除操作提示信息</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// 删除</span><br><span class="hljs-title function_">handleDelete</span>(<span class="hljs-params">row</span>) &#123;<br>    <span class="hljs-comment">//1.弹出提示框</span><br>    <span class="hljs-variable language_">this</span>.$confirm(<span class="hljs-string">&quot;此操作永久删除当前数据，是否继续？&quot;</span>,<span class="hljs-string">&quot;提示&quot;</span>,&#123;<br>        <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;info&#x27;</span><br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-comment">//2.做删除业务</span><br>        axios.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&quot;/books/&quot;</span>+row.<span class="hljs-property">id</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>       		<span class="hljs-keyword">if</span>(res.<span class="hljs-property">data</span>.<span class="hljs-property">flag</span>)&#123;<br>            	<span class="hljs-variable language_">this</span>.<span class="hljs-property">$message</span>.<span class="hljs-title function_">success</span>(<span class="hljs-string">&quot;删除成功&quot;</span>);<br>        	&#125;<span class="hljs-keyword">else</span>&#123;<br>            	<span class="hljs-variable language_">this</span>.<span class="hljs-property">$message</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;删除失败&quot;</span>);<br>        	&#125;<br>        &#125;).<span class="hljs-title function_">finally</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAll</span>();<br>        &#125;);<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-comment">//3.取消删除</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$message</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;取消删除操作&quot;</span>);<br>    &#125;);<br>&#125;，	<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>请求方式使用Delete调用后台对应操作</li>
<li>删除操作需要传递当前行数据对应的id值到后台</li>
<li>删除操作结束后动态刷新页面加载数据</li>
<li>根据操作结果不同，显示对应的提示信息</li>
<li>删除操作前弹出提示框避免误操作</li>
</ol>
<h3 id="9-4-修改功能"><a href="#9-4-修改功能" class="headerlink" title="9.4 修改功能"></a>9.4 修改功能</h3><p>修改功能可以说是列表功能、删除功能与添加功能的合体。几个相似点如下：</p>
<ol>
<li><p>页面也需要有一个弹窗用来加载修改的数据，这一点与添加相同，都是要弹窗</p>
</li>
<li><p>弹出窗口中要加载待修改的数据，而数据需要通过查询得到，这一点与查询全部相同，都是要查数据</p>
</li>
<li><p>查询操作需要将要修改的数据id发送到后台，这一点与删除相同，都是传递id到后台</p>
</li>
<li><p>查询得到数据后需要展示到弹窗中，这一点与查询全部相同，都是要通过数据模型绑定展示数据</p>
</li>
<li><p>修改数据时需要将被修改的数据传递到后台，这一点与添加相同，都是要传递数据</p>
<p> 所以整体上来看，修改功能就是前面几个功能的大合体</p>
</li>
<li><p><strong>查询并展示数据</strong></p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">//弹出编辑窗口</span><br><span class="hljs-title function_">handleUpdate</span>(<span class="hljs-params">row</span>) &#123;<br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/books/&quot;</span>+row.<span class="hljs-property">id</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-property">data</span>.<span class="hljs-property">flag</span>)&#123;<br>            <span class="hljs-comment">//展示弹层，加载数据</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">formData</span> = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">dialogFormVisible4Edit</span> = <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">$message</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;数据同步失败，自动刷新&quot;</span>);<br>        &#125;<br>    &#125;);<br>&#125;,<br></code></pre></td></tr></table></figure>

<p>​        <strong>修改操作</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">//修改</span><br><span class="hljs-title function_">handleEdit</span>(<span class="hljs-params"></span>) &#123;<br>    axios.<span class="hljs-title function_">put</span>(<span class="hljs-string">&quot;/books&quot;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">formData</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>        <span class="hljs-comment">//如果操作成功，关闭弹层并刷新页面</span><br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-property">data</span>.<span class="hljs-property">flag</span>)&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">dialogFormVisible4Edit</span> = <span class="hljs-literal">false</span>;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">$message</span>.<span class="hljs-title function_">success</span>(<span class="hljs-string">&quot;修改成功&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">$message</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;修改失败，请重试&quot;</span>);<br>        &#125;<br>    &#125;).<span class="hljs-title function_">finally</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAll</span>();<br>    &#125;);<br>&#125;,<br></code></pre></td></tr></table></figure>





<h2 id="10-业务异常消息处理"><a href="#10-业务异常消息处理" class="headerlink" title="10.业务异常消息处理"></a>10.业务异常消息处理</h2><p>目前的功能制作基本上达成了正常使用的情况，什么叫正常使用呢？也就是这个程序不出BUG，如果我们搞一个BUG出来，你会发现程序马上崩溃掉。比如后台手工抛出一个异常，看看前端接收到的数据什么样子</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;timestamp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2021-09-15T03:27:31.038+00:00&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">500</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;error&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Internal Server Error&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/books&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>

<p>​    面对这种情况，前端的同学又不会了，这又是什么格式？怎么和之前的格式不一样？</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;flag&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;计算机理论&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Spring实战 第5版&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Spring入门经典教程&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>

<p>​    看来不仅要对正确的操作数据格式做处理，还要对错误的操作数据格式做同样的格式处理</p>
<p>​    首先在当前的数据结果中添加消息字段，用来兼容后台出现的操作消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">R</span>&#123;<br>    <span class="hljs-keyword">private</span> Boolean flag;<br>    <span class="hljs-keyword">private</span> Object data;<br>    <span class="hljs-keyword">private</span> String msg;		<span class="hljs-comment">//用于封装消息</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    后台代码也要根据情况做处理，此处手动模拟异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@PostMapping</span><br><span class="hljs-keyword">public</span> R <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Book book)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 模拟异常：传入的getDescription内容为error时，手动抛出异常</span><br>    <span class="hljs-keyword">if</span> (book.getDescription().equals(<span class="hljs-string">&quot;error&quot;</span>)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(); <span class="hljs-comment">// 由于配置了异常处理增强，此句后面并不会执行</span><br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> bookService.insert(book);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">R</span>(flag , flag ? <span class="hljs-string">&quot;添加成功^_^&quot;</span> : <span class="hljs-string">&quot;添加失败-_-!&quot;</span>); <span class="hljs-comment">// 这种相当于把返回的错误信息放到后台</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    然后在表现层做统一的异常处理，使用SpringMVC提供的异常处理器做统一的异常处理，这里用到了关键的注解</p>
<h4 id="注解-RestControllerAdvice和-ExceptionHandler"><a href="#注解-RestControllerAdvice和-ExceptionHandler" class="headerlink" title="注解@RestControllerAdvice和@ExceptionHandler"></a>注解@RestControllerAdvice和@ExceptionHandler</h4><p>控制器增强以及异常处理器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProjectExceptionAdvice</span> &#123;<br>    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span>  <span class="hljs-comment">// 处理什么异常，此处写一个父类</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">doOtherException</span><span class="hljs-params">(Exception ex)</span>&#123;  <br>        <span class="hljs-comment">//记录日志</span><br>        <span class="hljs-comment">//发送消息给运维</span><br>        <span class="hljs-comment">//发送邮件给开发人员,ex对象发送给开发人员</span><br>        ex.printStackTrace();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">R</span>(<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;系统错误，请稍后再试！&quot;</span>); <span class="hljs-comment">// 所有的异常都会提示一下这个，上面是父类</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    页面上得到数据后，先判定是否有后台传递过来的消息，标志就是当前操作是否成功，如果返回操作结果false，就读取后台传递的消息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">//添加</span><br>handleAdd () &#123;<br>	<span class="hljs-comment">//发送ajax请求</span><br>    axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/books&quot;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">formData</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>        <span class="hljs-comment">//如果操作成功，关闭弹层，显示数据</span><br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-property">data</span>.<span class="hljs-property">flag</span>)&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">dialogFormVisible</span> = <span class="hljs-literal">false</span>;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">$message</span>.<span class="hljs-title function_">success</span>(<span class="hljs-string">&quot;添加成功&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">$message</span>.<span class="hljs-title function_">error</span>(res.<span class="hljs-property">data</span>.<span class="hljs-property">msg</span>);			<span class="hljs-comment">//消息来自于后台传递过来，而非固定内容</span><br>        &#125;<br>    &#125;).<span class="hljs-title function_">finally</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAll</span>();<br>    &#125;);<br>&#125;,<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>使用注解@RestControllerAdvice定义SpringMVC异常处理器用来处理异常的</li>
<li>异常处理器必须被扫描加载，否则无法生效</li>
<li>表现层返回结果的模型类中添加消息属性用来传递消息到页面，目的：国际化</li>
</ol>
<h2 id="11-页面功能开发"><a href="#11-页面功能开发" class="headerlink" title="11.页面功能开发"></a>11.页面功能开发</h2><h4 id="11-1-分页功能"><a href="#11-1-分页功能" class="headerlink" title="11.1 分页功能"></a>11.1 分页功能</h4><p>​        分页功能的制作用于替换前面的查询全部，其中要使用到elementUI提供的分页组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!--分页组件--&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pagination-container&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-pagination</span></span></span><br><span class="hljs-tag"><span class="language-xml">		<span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pagiantion&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">		@<span class="hljs-attr">current-change</span>=<span class="hljs-string">&quot;handleCurrentChange&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">		<span class="hljs-attr">:current-page</span>=<span class="hljs-string">&quot;pagination.currentPage&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">		<span class="hljs-attr">:page-size</span>=<span class="hljs-string">&quot;pagination.pageSize&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">		<span class="hljs-attr">layout</span>=<span class="hljs-string">&quot;total, prev, pager, next, jumper&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">		<span class="hljs-attr">:total</span>=<span class="hljs-string">&quot;pagination.total&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">el-pagination</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>​        为了配合分页组件，封装分页对应的数据模型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">data:&#123;<br>	pagination: &#123;	<br>		//分页相关模型数据<br>		currentPage: 1,	//当前页码<br>		pageSize:10,	//每页显示的记录数<br>		total:0,		//总记录数<br>	&#125;<br>&#125;,<br></code></pre></td></tr></table></figure>

<p>​        修改查询全部功能为分页查询，通过路径变量传递页码信息参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-title function_">getAll</span>(<span class="hljs-params"></span>) &#123;<br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/books/&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">currentPage</span>+<span class="hljs-string">&quot;/&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">pageSize</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    &#125;);<br>&#125;,<br></code></pre></td></tr></table></figure>

<p>​        后台提供对应的分页功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@GetMapping(&quot;/&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)</span><br><span class="hljs-keyword">public</span> R <span class="hljs-title function_">getAll</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer currentPage,<span class="hljs-meta">@PathVariable</span> Integer pageSize)</span>&#123;<br>    IPage&lt;Book&gt; pageBook = bookService.getPage(currentPage, pageSize);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">R</span>(<span class="hljs-literal">null</span> != pageBook ,pageBook);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        页面根据分页操作结果读取对应数据，并进行数据模型绑定</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-title function_">getAll</span>(<span class="hljs-params"></span>) &#123;<br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/books/&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">currentPage</span>+<span class="hljs-string">&quot;/&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">pageSize</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">total</span> = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">total</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">currentPage</span> = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">current</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">pagesize</span> = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">size</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataList</span> = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">records</span>;<br>    &#125;);<br>&#125;,<br></code></pre></td></tr></table></figure>

<p>​        对切换页码操作设置调用当前分页操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">//切换页码</span><br><span class="hljs-title function_">handleCurrentChange</span>(<span class="hljs-params">currentPage</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">currentPage</span> = currentPage;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAll</span>();<br>&#125;,<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>使用el分页组件</li>
<li>定义分页组件绑定的数据模型</li>
<li>异步调用获取分页数据</li>
<li>分页数据页面回显</li>
</ol>
<h4 id="11-2-删除功能维护"><a href="#11-2-删除功能维护" class="headerlink" title="11.2 删除功能维护"></a>11.2 删除功能维护</h4><p>​        由于使用了分页功能，当最后一页只有一条数据时，删除操作就会出现BUG，最后一页无数据但是独立展示，对分页查询功能进行后台功能维护，如果当前页码值大于最大页码值，重新执行查询。其实这个问题解决方案很多，这里给出比较简单的一种处理方案</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)</span><br><span class="hljs-keyword">public</span> R <span class="hljs-title function_">getPage</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> <span class="hljs-type">int</span> currentPage,<span class="hljs-meta">@PathVariable</span> <span class="hljs-type">int</span> pageSize)</span>&#123;<br>    IPage&lt;Book&gt; page = bookService.getPage(currentPage, pageSize);<br>    <span class="hljs-comment">//如果当前页码值大于了总页码值，那么重新执行查询操作，使用最大页码值作为当前页码值</span><br>    <span class="hljs-keyword">if</span>( currentPage &gt; page.getPages())&#123;<br>        page = bookService.getPage((<span class="hljs-type">int</span>)page.getPages(), pageSize);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">R</span>(<span class="hljs-literal">true</span>, page);<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="11-3-条件查询功能"><a href="#11-3-条件查询功能" class="headerlink" title="11.3 条件查询功能"></a>11.3 条件查询功能</h4><p>​        最后一个功能来做条件查询，其实条件查询可以理解为分页查询的时候除了携带分页数据再多带几个数据的查询。这些多带的数据就是查询条件。比较一下不带条件的分页查询与带条件的分页查询差别之处，这个功能就好做了</p>
<ul>
<li><p>页面封装的数据：带不带条件影响的仅仅是一次性传递到后台的数据总量，由传递2个分页相关的数据转换成2个分页数据加若干个条件</p>
</li>
<li><p>后台查询功能：查询时由不带条件，转换成带条件，反正不带条件的时候查询条件对象使用的是null，现在换成具体条件，差别不大</p>
</li>
<li><p>查询结果：不管带不带条件，出来的数据只是有数量上的差别，其他都差别，这个可以忽略</p>
<p>  经过上述分析，看来需要在页面发送请求的格式方面做一定的修改，后台的调用数据层操作时发送修改，其他没有区别</p>
<p>  页面发送请求时，两个分页数据仍然使用路径变量，其他条件采用动态拼装url参数的形式传递</p>
<p>  <strong>页面封装查询条件字段</strong></p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">pagination: &#123;		<br>//分页相关模型数据<br>	currentPage: 1,		//当前页码<br>	pageSize:10,		//每页显示的记录数<br>	total:0,			//总记录数<br>	name: &quot;&quot;,<br>	type: &quot;&quot;,<br>	description: &quot;&quot;<br>&#125;,<br></code></pre></td></tr></table></figure>

<p>  页面添加查询条件字段对应的数据模型绑定名称</p>
  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;filter-container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;图书类别&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;pagination.type&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;filter-item&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;图书名称&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;pagination.name&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;filter-item&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;图书描述&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;pagination.description&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;filter-item&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;getAll()&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dalfBut&quot;</span>&gt;</span>查询<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;butT&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleCreate()&quot;</span>&gt;</span>新建<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>  将查询条件组织成url参数，添加到请求url地址中，这里可以借助其他类库快速开发，当前使用手工形式拼接，降低学习要求</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-title function_">getAll</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//1.获取查询条件,拼接查询条件</span><br>    param = <span class="hljs-string">&quot;?name=&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">name</span>;<br>    param += <span class="hljs-string">&quot;&amp;type=&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">type</span>;<br>    param += <span class="hljs-string">&quot;&amp;description=&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">description</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;-----------------&quot;</span>+ param);<br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/books/&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">currentPage</span>+<span class="hljs-string">&quot;/&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">pageSize</span>+param).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataList</span> = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">records</span>;<br>    &#125;);<br>&#125;,<br></code></pre></td></tr></table></figure>

<p>  后台代码中定义实体类封查询条件</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)</span><br><span class="hljs-keyword">public</span> R <span class="hljs-title function_">getAll</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> <span class="hljs-type">int</span> currentPage,<span class="hljs-meta">@PathVariable</span> <span class="hljs-type">int</span> pageSize,Book book)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;参数=====&gt;&quot;</span>+book);<br>    IPage&lt;Book&gt; pageBook = bookService.getPage(currentPage,pageSize);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">R</span>(<span class="hljs-literal">null</span> != pageBook ,pageBook);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  对应业务层接口与实现类进行修正</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IBookService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IService</span>&lt;Book&gt; &#123;<br>    IPage&lt;Book&gt; <span class="hljs-title function_">getPage</span><span class="hljs-params">(Integer currentPage,Integer pageSize,Book queryBook)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookServiceImpl2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;BookDao,Book&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IBookService</span> &#123;<br>    <span class="hljs-keyword">public</span> IPage&lt;Book&gt; <span class="hljs-title function_">getPage</span><span class="hljs-params">(Integer currentPage,Integer pageSize,Book queryBook)</span>&#123;<br>        <span class="hljs-type">IPage</span> <span class="hljs-variable">page</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>(currentPage,pageSize);<br>        LambdaQueryWrapper&lt;Book&gt; lqw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;Book&gt;();<br>        lqw.like(Strings.isNotEmpty(queryBook.getName()),Book::getName,queryBook.getName());<br>        lqw.like(Strings.isNotEmpty(queryBook.getType()),Book::getType,queryBook.getType());<br>        lqw.like(Strings.isNotEmpty(queryBook.getDescription()),Book::getDescription,queryBook.getDescription());<br>        <span class="hljs-keyword">return</span> bookDao.selectPage(page,lqw);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  页面回显数据</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">getAll</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//1.获取查询条件,拼接查询条件</span><br>    param = <span class="hljs-string">&quot;?name=&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">name</span>;<br>    param += <span class="hljs-string">&quot;&amp;type=&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">type</span>;<br>    param += <span class="hljs-string">&quot;&amp;description=&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">description</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;-----------------&quot;</span>+ param);<br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/books/&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">currentPage</span>+<span class="hljs-string">&quot;/&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">pageSize</span>+param).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">total</span> = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">total</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">currentPage</span> = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">current</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">pagesize</span> = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">size</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataList</span> = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">records</span>;<br>    &#125;);<br>&#125;,<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>总结</strong></p>
<ol>
<li>定义查询条件数据模型（当前封装到分页数据模型中）</li>
<li>异步调用分页功能并通过请求参数传递数据到后台</li>
</ol>
<h1 id="四、运维实用篇"><a href="#四、运维实用篇" class="headerlink" title="四、运维实用篇"></a>四、运维实用篇</h1><h2 id="1-SpringBoot程序的打包与运行"><a href="#1-SpringBoot程序的打包与运行" class="headerlink" title="1. SpringBoot程序的打包与运行"></a>1. SpringBoot程序的打包与运行</h2><p>企业项目上线为了保障环境适配性会采用下面流程发布项目，这里不讨论此过程。</p>
<ol>
<li>开发部门使用Git、SVN等版本控制工具上传工程到版本服务器</li>
<li>服务器使用版本控制工具下载工程</li>
<li>服务器上使用Maven工具在当前真机环境下重新构建项目</li>
<li>启动服务</li>
</ol>
<p>我们的程序要先组织成一个文件，然后将这个文件传输到这台服务器上。这里面就存在两个过程，一个是打包的过程，另一个是运行的过程。</p>
<h3 id="程序打包"><a href="#程序打包" class="headerlink" title="程序打包"></a><strong>程序打包</strong></h3><p>​        SpringBoot程序是基于Maven创建的，在Maven中提供有打包的指令，叫做package。本操作可以在Idea环境下执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">mvn <span class="hljs-keyword">package</span><br></code></pre></td></tr></table></figure>

<p>​        打包后会产生一个与工程名类似的jar文件，其名称是由模块名+版本号+.jar组成的。</p>
<h3 id="程序运行"><a href="#程序运行" class="headerlink" title="程序运行"></a><strong>程序运行</strong></h3><p>​        程序包打好以后，就可以直接执行了。在程序包所在路径下，执行指令。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">java -jar 工程包名.jar<br></code></pre></td></tr></table></figure>

<p>​        执行程序打包指令后，程序正常运行，与在Idea下执行程序没有区别。</p>
<p>​        <font color="#ff0000"><b>特别关注</b></font>：如果你的计算机中没有安装java的jdk环境，是无法正确执行上述操作的，因为程序执行使用的是java指令。</p>
<p>​        <font color="#ff0000"><b>特别关注</b></font>：在使用向导创建SpringBoot工程时，pom.xml文件中会有如下配置，这一段配置千万不能删除，否则打包后无法正常执行程序。（spring-boot-maven-plugin插件用于将当前程序打包成一个可以独立运行的程序包）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>SpringBoot工程可以基于java环境下独立运行jar文件启动服务</li>
<li>SpringBoot工程执行mvn命令package进行打包</li>
<li>执行jar命令：java –jar 工程名.jar</li>
</ol>
<h3 id="命令行启动常见问题及解决方案"><a href="#命令行启动常见问题及解决方案" class="headerlink" title="命令行启动常见问题及解决方案"></a>命令行启动常见问题及解决方案</h3><p>​        各位小伙伴在DOS环境下启动SpringBoot工程时，可能会遇到端口占用的问题。给大家一组命令，不用深入学习，备用吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"># 查询端口<br>netstat -ano<br># 查询指定端口<br>netstat -ano |findstr <span class="hljs-string">&quot;端口号&quot;</span><br># 根据进程PID查询进程名称<br>tasklist |findstr <span class="hljs-string">&quot;进程PID号&quot;</span><br># 根据PID杀死任务<br>taskkill /F /PID <span class="hljs-string">&quot;进程PID号&quot;</span><br># 根据进程名称杀死任务<br>taskkill -f -t -im <span class="hljs-string">&quot;进程名称&quot;</span><br></code></pre></td></tr></table></figure>

<p>​        关于打包与运行程序其实还有一系列的配置和参数，下面的内容中遇到再说，这里先开个头，知道如何打包和运行程序。</p>
<h2 id="2-配置高级"><a href="#2-配置高级" class="headerlink" title="2. 配置高级"></a>2. 配置高级</h2><h3 id="2-1-临时属性设置"><a href="#2-1-临时属性设置" class="headerlink" title="2.1 临时属性设置"></a>2.1 临时属性设置</h3><p>SpringBoot提供了灵活的配置方式，如果你发现你的项目中有个别属性需要重新配置，可以使用临时属性的方式快速修改某些配置。方法也特别简单，在启动的时候添加上对应参数就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">java –jar springboot.jar –-server.port=<span class="hljs-number">80</span><br></code></pre></td></tr></table></figure>

<p>​        上面的命令是启动SpringBoot程序包的命令，在命令输入完毕后，空一格，然后输入两个-号。下面按照属性名&#x3D;属性值的形式添加对应参数就可以了。记得，这里的格式不是yaml中的书写格式，当属性存在多级名称时，中间使用点分隔，和properties文件中的属性格式完全相同。</p>
<p>​        如果你发现要修改的属性不止一个，可以按照上述格式继续写，属性与属性之间使用空格分隔。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">java –jar springboot.jar –-server.port=<span class="hljs-number">80</span> --logging.level.root=debug<br></code></pre></td></tr></table></figure>



<h4 id="属性加载优先级"><a href="#属性加载优先级" class="headerlink" title="属性加载优先级"></a>属性加载优先级</h4><p>​        现在我们的程序配置受两个地方控制了，第一配置文件，第二临时属性。并且我们发现临时属性的加载优先级要高于配置文件的。那是否还有其他的配置方式呢？其实是有的，而且还不少，打开官方文档中对应的内容，就可以查看配置读取的优先顺序。地址奉上：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config">https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config</a></p>
<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Spring/Springboot%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%85%88%E7%BA%A7.png" srcset="/img/loading.gif" lazyload alt="image-20211206100859236" style="zoom:67%;" />

<p>打开文档发现居然有14种配置的位置，而我们现在使用的是这里面的2个。第3条Config data说的就是使用配置文件，第11条Command line arguments说的就是使用命令行临时参数。而这14种配置的顺序就是SpringBoot加载配置的顺序，言外之意，命令行临时属性比配置文件的加载优先级高，所以这个列表上面的优先级低，下面的优先级高。其实这个东西不用背的，你就记得一点，你最终要什么效果，你自己是知道的，不管这个顺序是怎么个高低排序，开发时一定要配置成你要的顺序为准。这个顺序只是在你想不明白问题的时候帮助你分析罢了。</p>
<p>​        比如你现在加载了一个user.name属性。结果你发现<strong>出来的结果和你想的不一样，那肯定是别的优先级比你高的属性覆盖你的配置属性了，那你就可以看着这个顺序挨个排查。</strong>哪个位置有可能覆盖了你的属性。</p>
<p>​        比如在yaml中配置了user.name属性值，然后读取出来的时候居然不是自己的配置值，因为在系统属性中有一个属性叫做user.name，两个相互冲突了。而系统属性的加载优先顺序在上面这个列表中是5号，高于3号，所以SpringBoot最终会加载系统配置属性user.name。</p>
<p><strong>总结</strong></p>
<ol>
<li>使用jar命令启动SpringBoot工程时可以使用临时属性替换配置文件中的属性</li>
<li>临时属性添加方式：java –jar 工程名.jar –-属性名&#x3D;值</li>
<li>多个临时属性之间使用空格分隔</li>
<li>临时属性必须是当前boot工程支持的属性，否则设置无效</li>
</ol>
<h4 id="开发环境中使用临时属性"><a href="#开发环境中使用临时属性" class="headerlink" title="开发环境中使用临时属性"></a>开发环境中使用临时属性</h4><p>​        临时使用目前是有了，但是上线的时候通过命令行输入的临时属性必须是正确的啊，那这些属性配置值我们必须在开发环境中测试好才行。下面说一下开发环境中如何使用临时属性，其实就是Idea界面下如何操作了。</p>
<p>​        打开SpringBoot引导类的运行界面，在里面找到配置项。其中Program arguments对应的位置就是添加临时属性的，可以加几个试试效果。</p>
<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Spring/Springboot%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83IDEA%E4%BD%BF%E7%94%A8%E4%B8%B4%E6%97%B6%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7.png" srcset="/img/loading.gif" lazyload alt="image-20211206101947622" style="zoom:80%;" />

<p>​    做到这里其实可以产生一个思考了，如果对java编程熟悉的小伙伴应该知道，我们运行main方法的时候，如果想使用main方法的参数，也就是下面的args参数，就是在上面这个位置添加的参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        原来是这样，通过这个args就可以获取到参数。再来看我们的引导类是如何书写的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    SpringApplication.run(SSMPApplication.class,args);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        这个args参数居然传递给了run方法，看来在Idea中配置的临时参数就是通过这个位置传递到我们的程序中的。言外之意，这里如果不用这个args是不是就断开了外部传递临时属性的入口呢？是这样的，我们可以使用下面的调用方式，这样外部临时属性就无法进入到SpringBoot程序中了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    SpringApplication.run(SSMPApplication.class);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        或者还可以使用如下格式来玩这个操作，就是将配置不写在配置文件中，直接写成一个字符串数组，传递给程序入口。当然，这种做法并没有什么实际开发意义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    String[] arg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">1</span>];<br>    arg[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;--server.port=8082&quot;</span>;<br>    SpringApplication.run(SSMPApplication.class, arg);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>启动SpringBoot程序时，可以选择是否使用命令行属性为SpringBoot程序传递启动属性</li>
</ol>
<p><strong>思考</strong></p>
<p>​        现在使用临时属性可以在启动项目前临时更改配置了，但是新的问题又出来了。临时属性好用是好用，就是写的多了会很麻烦。比如我现在有个需求，上线的时候使用临时属性配置20个值，这下可麻烦了，能不能搞得简单点，集中管理一下呢？比如说搞个文件，加载指定文件？还真可以。</p>
<h3 id="2-2-配置文件分类"><a href="#2-2-配置文件分类" class="headerlink" title="2.2 配置文件分类"></a>2.2 配置文件分类</h3><p>​    SpringBoot提供了配置文件和临时属性的方式来对程序进行配置。前面一直说的是临时属性，这一节要说说配置文件了。其实这个配置文件我们一直在使用，只不过我们用的是SpringBoot提供的4级配置文件中的其中一个级别。4个级别分别是：</p>
<ul>
<li>类路径下配置文件（一直使用的是这个，也就是resources目录中的application.yml文件）</li>
<li>类路径下config目录下配置文件</li>
<li>程序包所在目录中配置文件</li>
<li>程序包所在目录中config目录下配置文件</li>
</ul>
<p>​        好复杂，一个一个说。其实上述4种文件是提供给你了4种配置文件书写的位置，功能都是一样的，都是做配置的。那大家关心的就是差别了，没错，就是因为位置不同，产生了差异。总体上来说，4种配置文件如果都存在的话，有一个优先级的问题，说白了就是加入4个文件我都有，里面都有一样的配置，谁生效的问题。上面4个文件的加载优先顺序为</p>
<ol>
<li>file ：config&#x2F;application.yml <strong>【最高】</strong></li>
<li>file ：application.yml</li>
<li>classpath：config&#x2F;application.yml</li>
<li>classpath：application.yml  <strong>【最低】</strong></li>
</ol>
<p>​        那为什么设计这种多种呢？说一个最典型的应用吧。</p>
<ul>
<li>场景A：你作为一个开发者，你做程序的时候为了方便自己写代码，配置的数据库肯定是连接你自己本机的，咱们使用4这个级别，也就是之前一直用的application.yml。</li>
<li>场景B：现在项目开发到了一个阶段，要联调测试了，连接的数据库是测试服务器的数据库，肯定要换一组配置吧。你可以选择把你之前的文件中的内容都改了，目前还不麻烦。</li>
<li>场景C：测试完了，一切OK。你继续写你的代码，你发现你原来写的配置文件被改成测试服务器的内容了，你要再改回来。现在明白了不？场景B中把你的内容都改掉了，你现在要重新改回来，以后呢？改来改去吗？</li>
</ul>
<p>​        解决方案很简单，用上面的3这个级别的配置文件就可以快速解决这个问题，再写一个配置就行了。两个配置文件共存，因为config目录中的配置加载优先级比你的高，所以配置项如果和级别4里面的内容相同就覆盖了，这样是不是很简单？</p>
<p>​        级别1和2什么时候使用呢？程序打包以后就要用这个级别了，管你程序里面配置写的是什么？我的级别高，可以轻松覆盖你，就不用考虑这些配置冲突的问题了。</p>
<p><strong>总结</strong></p>
<ol>
<li><p>配置文件分为4种</p>
<ul>
<li>项目类路径配置文件：服务于开发人员本机开发与测试</li>
<li>项目类路径config目录中配置文件：服务于项目经理整体调控</li>
<li>工程路径配置文件：服务于运维人员配置涉密线上环境</li>
<li>工程路径config目录中配置文件：服务于运维经理整体调控</li>
</ul>
</li>
<li><p>多层级配置文件间的属性采用叠加并覆盖的形式作用于程序</p>
</li>
</ol>
<h2 id="3-多环境开发"><a href="#3-多环境开发" class="headerlink" title="3. 多环境开发"></a>3. 多环境开发</h2><p>每个计算机环境不一样，这就是多环境。常见的多环境开发主要兼顾3种环境设置，开发环境——自己用的，测试环境——自己公司用的，生产环境——甲方爸爸用的。因为这是绝对不同的三台电脑，所以环境肯定有所不同，比如连接的数据库不一样，设置的访问端口不一样等等。多环境开发就是针对不同的环境设置不同的配置属性</p>
<h3 id="3-1-yaml单一文件版"><a href="#3-1-yaml单一文件版" class="headerlink" title="3.1 yaml单一文件版"></a>3.1 yaml单一文件版</h3><p>​        比如你自己开发时，配置你的端口如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure>

<p>​        如何想设计两组环境呢？中间使用三个减号分隔开</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">81</span><br></code></pre></td></tr></table></figure>

<p>​        如何区分两种环境呢？起名字呗</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>	<span class="hljs-attr">profiles:</span> <span class="hljs-string">pro</span><br><span class="hljs-attr">server:</span><br>	<span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">spring:</span><br>	<span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">server:</span><br>	<span class="hljs-attr">port:</span> <span class="hljs-number">81</span><br></code></pre></td></tr></table></figure>

<p>​        那用哪一个呢？设置默认启动哪个就可以了</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>	<span class="hljs-attr">profiles:</span><br>		<span class="hljs-attr">active:</span> <span class="hljs-string">pro</span>		<span class="hljs-comment"># 启动pro</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">spring:</span><br>	<span class="hljs-attr">profiles:</span> <span class="hljs-string">pro</span><br><span class="hljs-attr">server:</span><br>	<span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">spring:</span><br>	<span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">server:</span><br>	<span class="hljs-attr">port:</span> <span class="hljs-number">81</span><br></code></pre></td></tr></table></figure>

<p>​        就这么简单，再多来一组环境也OK</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>	<span class="hljs-attr">profiles:</span><br>		<span class="hljs-attr">active:</span> <span class="hljs-string">pro</span>		<span class="hljs-comment"># 启动pro</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">spring:</span><br>	<span class="hljs-attr">profiles:</span> <span class="hljs-string">pro</span><br><span class="hljs-attr">server:</span><br>	<span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">spring:</span><br>	<span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">server:</span><br>	<span class="hljs-attr">port:</span> <span class="hljs-number">81</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">spring:</span><br>	<span class="hljs-attr">profiles:</span> <span class="hljs-string">test</span><br><span class="hljs-attr">server:</span><br>	<span class="hljs-attr">port:</span> <span class="hljs-number">82</span><br></code></pre></td></tr></table></figure>

<p>​        其中关于环境名称定义上述格式是过时格式，标准格式如下</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>	<span class="hljs-attr">config:</span><br>    	<span class="hljs-attr">activate:</span><br>        	<span class="hljs-attr">on-profile:</span> <span class="hljs-string">pro</span><br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>多环境开发需要设置若干种常用环境，例如开发、生产、测试环境</li>
<li>yaml格式中设置多环境使用—区分环境设置边界</li>
<li>每种环境的区别在于加载的配置属性不同</li>
<li>启用某种环境时需要指定启动时使用该环境</li>
</ol>
<h3 id="3-2-yaml多文件版"><a href="#3-2-yaml多文件版" class="headerlink" title="3.2 yaml多文件版"></a>3.2 yaml多文件版</h3><p>将所有的配置都放在一个配置文件中，尤其是每一个配置应用场景都不一样，这显然不合理，于是就有了将一个配置文件拆分成多个配置文件的想法。拆分后，每个配置文件中写自己的配置，主配置文件中写清楚用哪一个配置文件就好了。</p>
<p><strong>主配置文件</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>	<span class="hljs-attr">profiles:</span><br>		<span class="hljs-attr">active:</span> <span class="hljs-string">pro</span>		<span class="hljs-comment"># 启动pro</span><br></code></pre></td></tr></table></figure>

<p><strong>环境配置文件</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>	<span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure>

<p>​        环境配置文件因为每一个都是配置自己的项，所以连名字都不用写里面了。那问题是如何区分这是哪一组配置呢？使用文件名区分。</p>
<p><strong>application-pro.yaml</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>	<span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure>

<p><strong>application-dev.yaml</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>	<span class="hljs-attr">port:</span> <span class="hljs-number">81</span><br></code></pre></td></tr></table></figure>

<p>​        文件的命名规则为：application-环境名.yml。</p>
<p>​        在配置文件中，如果某些配置项所有环境都一样，可以将这些项写入到主配置中，只有哪些有区别的项才写入到环境配置文件中。</p>
<ul>
<li>主配置文件中设置公共配置（全局）</li>
<li>环境分类配置文件中常用于设置冲突属性（局部）</li>
</ul>
<p><strong>总结</strong></p>
<ol>
<li><p>可以使用独立配置文件定义环境属性</p>
</li>
<li><p>独立配置文件便于线上系统维护更新并保障系统安全性</p>
</li>
</ol>
<h3 id="3-3-properties多文件版"><a href="#3-3-properties多文件版" class="headerlink" title="3.3 properties多文件版"></a>3.3 properties多文件版</h3><p>​        SpringBoot最早期提供的配置文件格式是properties格式的，这种格式的多环境配置也了解一下吧。</p>
<p><strong>主配置文件</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.profiles.active</span>=<span class="hljs-string">pro</span><br></code></pre></td></tr></table></figure>

<p><strong>环境配置文件</strong></p>
<p><strong>application-pro.properties</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">80</span><br></code></pre></td></tr></table></figure>

<p><strong>application-dev.properties</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">81</span><br></code></pre></td></tr></table></figure>

<p>​        文件的命名规则为：application-环境名.properties。</p>
<p><strong>总结</strong></p>
<ol>
<li>properties文件多环境配置仅支持多文件格式</li>
</ol>
<h3 id="3-4-多环境开发独立配置文件书写技巧"><a href="#3-4-多环境开发独立配置文件书写技巧" class="headerlink" title="3.4 多环境开发独立配置文件书写技巧"></a>3.4 多环境开发独立配置文件书写技巧</h3><p>​        作为程序员在搞配置的时候往往处于一种分久必合合久必分的局面。开始先写一起，后来为了方便维护就拆分。对于多环境开发也是如此，下面给大家说一下如何基于多环境开发做配置独立管理，务必掌握。</p>
<p><strong>准备工作</strong></p>
<p>​        将所有的配置根据功能对配置文件中的信息进行拆分，并制作成独立的配置文件，命名规则如下</p>
<ul>
<li>application-devDB.yml</li>
<li>application-devRedis.yml</li>
<li>application-devMVC.yml</li>
</ul>
<p><strong>使用</strong></p>
<p>​        使用include属性在激活指定环境的情况下，同时对多个环境进行加载使其生效，多个环境间使用逗号分隔</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>	<span class="hljs-attr">profiles:</span><br>    	<span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">devDB,devRedis,devMVC</span><br></code></pre></td></tr></table></figure>

<p>​        比较一下，现在相当于加载dev配置时，再加载对应的3组配置，从结构上就很清晰，用了什么，对应的名称是什么</p>
<p><strong>注意</strong></p>
<p>​        当主环境dev与其他环境有相同属性时，主环境属性生效；其他环境中有相同属性时，最后加载的环境属性生效</p>
<p><strong>改良</strong></p>
<p>​        但是上面的设置也有一个问题，比如我要切换dev环境为pro时，include也要修改。因为include属性只能使用一次，这就比较麻烦了。SpringBoot从2.4版开始使用group属性替代include属性，降低了配置书写量。简单说就是我先写好，你爱用哪个用哪个。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>	<span class="hljs-attr">profiles:</span><br>    	<span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br>        <span class="hljs-attr">group:</span><br>        	<span class="hljs-attr">&quot;dev&quot;:</span> <span class="hljs-string">devDB,devRedis,devMVC</span><br>      		<span class="hljs-attr">&quot;pro&quot;:</span> <span class="hljs-string">proDB,proRedis,proMVC</span><br>      		<span class="hljs-attr">&quot;test&quot;:</span> <span class="hljs-string">testDB,testRedis,testMVC</span><br></code></pre></td></tr></table></figure>

<p>​        现在再来看，如果切换dev到pro，只需要改一下是不是就结束了？完美！</p>
<p><strong>总结</strong></p>
<ol>
<li>多环境开发使用group属性设置配置文件分组，便于线上维护管理</li>
</ol>
<h3 id="3-5-多环境开发控制"><a href="#3-5-多环境开发控制" class="headerlink" title="3.5 多环境开发控制"></a>3.5 多环境开发控制</h3><p>​        多环境开发到这里基本上说完了，最后说一个冲突问题。就是maven和SpringBoot同时设置多环境的话怎么搞。</p>
<p>​        要想处理这个冲突问题，你要先理清一个关系，究竟谁在多环境开发中其主导地位。也就是说如果现在都设置了多环境，谁的应该是保留下来的，另一个应该遵从相同的设置。</p>
<p>​        maven是做什么的？项目构建管理的，最终生成代码包的，SpringBoot是干什么的？简化开发的。简化，又不是其主导作用。最终还是要靠maven来管理整个工程，所以SpringBoot应该听maven的。整个确认后下面就好做了。大体思想如下：</p>
<ul>
<li>先在maven环境中设置用什么具体的环境</li>
<li>在SpringBoot中读取maven设置的环境即可</li>
</ul>
<p><strong>maven中设置多环境（使用属性方式区分环境）</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>env_dev<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">profile.active</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">profile.active</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span>		<span class="hljs-comment">&lt;!--默认启动环境--&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>env_pro<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">profile.active</span>&gt;</span>pro<span class="hljs-tag">&lt;/<span class="hljs-name">profile.active</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>SpringBoot中读取maven设置值</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>	<span class="hljs-attr">profiles:</span><br>    	<span class="hljs-attr">active:</span> <span class="hljs-string">@profile.active@</span><br></code></pre></td></tr></table></figure>

<p>​        上面的@属性名@就是读取maven中配置的属性值的语法格式。</p>
<p><strong>总结</strong></p>
<ol>
<li>当Maven与SpringBoot同时对多环境进行控制时，以Mavn为主，SpringBoot使用@..@占位符读取Maven对应的配置属性值</li>
<li>基于SpringBoot读取Maven配置属性的前提下，如果在Idea下测试工程时pom.xml每次更新需要手动compile方可生效</li>
</ol>
<h2 id="4-日志"><a href="#4-日志" class="headerlink" title="4. 日志"></a>4. 日志</h2><p>日志其实就是记录程序日常运行的信息，主要作用如下：</p>
<ul>
<li>编程期调试代码</li>
<li>运营期记录信息</li>
<li>记录日常运营重要信息（峰值流量、平均响应时长……）</li>
<li>记录应用报错信息（错误堆栈）</li>
<li>记录运维过程数据（扩容、宕机、报警……）</li>
</ul>
<h3 id="4-1-代码中使用日志工具记录日志"><a href="#4-1-代码中使用日志工具记录日志" class="headerlink" title="4.1 代码中使用日志工具记录日志"></a>4.1 代码中使用日志工具记录日志</h3><p>​        日志的使用格式非常固定，直接上操作步骤：</p>
<p><strong>步骤①</strong>：添加日志记录操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/books&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseClass</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(BookController.class);<br>    <span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getById</span><span class="hljs-params">()</span>&#123;<br>        log.debug(<span class="hljs-string">&quot;debug...&quot;</span>);<br>        log.info(<span class="hljs-string">&quot;info...&quot;</span>);<br>        log.warn(<span class="hljs-string">&quot;warn...&quot;</span>);<br>        log.error(<span class="hljs-string">&quot;error...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;springboot is running...2&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        上述代码中log对象就是用来记录日志的对象，下面的log.debug，log.info这些操作就是写日志的API了。</p>
<p><strong>步骤②</strong>：设置日志输出级别</p>
<p>​        日志设置好以后可以根据设置选择哪些参与记录。这里是根据日志的级别来设置的。日志的级别分为6种，分别是：</p>
<ul>
<li>TRACE：运行堆栈信息，使用率低</li>
<li>DEBUG：程序员调试代码使用</li>
<li>INFO：记录运维过程数据</li>
<li>WARN：记录运维过程报警数据</li>
<li>ERROR：记录错误堆栈信息</li>
<li>FATAL：灾难信息，合并计入ERROR</li>
</ul>
<p>​        一般情况下，开发时候使用DEBUG，上线后使用INFO，运维信息记录使用WARN即可。下面就设置一下日志级别：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 开启debug模式，输出调试信息，常用于检查系统运行状况</span><br><span class="hljs-attr">debug:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<p>​        这么设置太简单粗暴了，日志系统通常都提供了细粒度的控制</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 开启debug模式，输出调试信息，常用于检查系统运行状况</span><br><span class="hljs-attr">debug:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># 设置日志级别，root表示根节点，即整体应用日志级别</span><br><span class="hljs-attr">logging:</span><br>	<span class="hljs-attr">level:</span><br>    	<span class="hljs-attr">root:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure>

<p>​        还可以再设置更细粒度的控制</p>
<p><strong>步骤③</strong>：设置日志组，控制指定包对应的日志输出级别，也可以直接控制指定包对应的日志输出级别</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>	<span class="hljs-comment"># 设置日志组</span><br>    <span class="hljs-attr">group:</span><br>    	<span class="hljs-comment"># 自定义组名，设置当前组中所包含的包</span><br>        <span class="hljs-attr">ebank:</span> <span class="hljs-string">com.itheima.controller</span><br>    <span class="hljs-attr">level:</span><br>    	<span class="hljs-attr">root:</span> <span class="hljs-string">warn</span><br>        <span class="hljs-comment"># 为对应组设置日志级别</span><br>        <span class="hljs-attr">ebank:</span> <span class="hljs-string">debug</span><br>    	<span class="hljs-comment"># 为对包设置日志级别</span><br>        <span class="hljs-attr">com.itheima.controller:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure>

<p>​        说白了就是总体设置一下，每个包设置一下，如果感觉设置的麻烦，就先把包分个组，对组设置，没了，就这些。</p>
<p><strong>总结</strong></p>
<ol>
<li>日志用于记录开发调试与运维过程消息</li>
<li>日志的级别共6种，通常使用4种即可，分别是DEBUG，INFO,WARN,ERROR</li>
<li>可以通过日志组或代码包的形式进行日志显示级别的控制</li>
</ol>
<h3 id="教你一招：优化日志对象创建代码"><a href="#教你一招：优化日志对象创建代码" class="headerlink" title="教你一招：优化日志对象创建代码"></a>教你一招：优化日志对象创建代码</h3><p>​        写代码的时候每个类都要写创建日志记录对象，这个可以优化一下，使用前面用过的lombok技术给我们提供的工具类即可。</p>
<p>​        导入lombok后使用注解搞定，日志对象名为log</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Slf4j</span>		<span class="hljs-comment">//这个注解替代了下面那一行</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/books&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseClass</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(BookController.class);	<span class="hljs-comment">//这一句可以不写了</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>基于lombok提供的@Slf4j注解为类快速添加日志对象</li>
</ol>
<h3 id="4-2-日志输出格式控制"><a href="#4-2-日志输出格式控制" class="headerlink" title="4.2 日志输出格式控制"></a>4.2 日志输出格式控制</h3><p>​        日志已经能够记录了，但是目前记录的格式是SpringBoot给我们提供的，如果想自定义控制就需要自己设置了。先分析一下当前日志的记录格式。</p>
<p>​    对于单条日志信息来说，日期，触发位置，记录信息是最核心的信息。级别用于做筛选过滤，PID与线程名用于做精准分析。了解这些信息后就可以DIY日志格式了。本课程不做详细的研究，有兴趣的小伙伴可以学习相关的知识。下面给出课程中模拟的官方日志模板的书写格式，便于大家学习。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>	<span class="hljs-attr">pattern:</span><br>    	<span class="hljs-attr">console:</span> <span class="hljs-string">&quot;%d %clr(%p) --- [%16t] %clr(%-40.40c)&#123;cyan&#125; : %m %n&quot;</span><br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>日志输出格式设置规则</li>
</ol>
<h3 id="4-3-日志文件"><a href="#4-3-日志文件" class="headerlink" title="4.3 日志文件"></a>4.3 日志文件</h3><p>​        日志信息显示，记录已经控制住了，下面就要说一下日志的转存了。日志不能仅显示在控制台上，要把日志记录到文件中，方便后期维护查阅。</p>
<p>​        对于日志文件的使用存在各种各样的策略，例如每日记录，分类记录，报警后记录等。这里主要研究日志文件如何记录。</p>
<p>​        记录日志到文件中格式非常简单，设置日志文件名即可。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">logging:</span><br>	<span class="hljs-attr">file:</span><br>    	<span class="hljs-attr">name:</span> <span class="hljs-string">server.log</span><br></code></pre></td></tr></table></figure>

<p>​        虽然使用上述格式可以将日志记录下来了，但是面对线上的复杂情况，一个文件记录肯定是不能够满足运维要求的，通常会每天记录日志文件，同时为了便于维护，还要限制每个日志文件的大小。下面给出日志文件的常用配置方式：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">logging:</span><br>	<span class="hljs-attr">logback:</span><br>    	<span class="hljs-attr">rollingpolicy:</span><br>        	<span class="hljs-attr">max-file-size:</span> <span class="hljs-string">3KB</span><br>            <span class="hljs-attr">file-name-pattern:</span> <span class="hljs-string">server.%d&#123;yyyy-MM-dd&#125;.%i.log</span><br></code></pre></td></tr></table></figure>

<p>​        以上格式是基于logback日志技术设置每日日志文件的设置格式，要求容量到达3KB以后就转存信息到第二个文件中。文件命名规则中的%d标识日期，%i是一个递增变量，用于区分日志文件。</p>
<p><strong>总结</strong></p>
<ol>
<li>日志记录到文件</li>
<li>日志文件格式设置</li>
</ol>
<h1 id="五、开发实用篇"><a href="#五、开发实用篇" class="headerlink" title="五、开发实用篇"></a>五、开发实用篇</h1><h2 id="1-热部署"><a href="#1-热部署" class="headerlink" title="1. 热部署"></a>1. 热部署</h2><p>热部署简单说就是你程序改了，现在要重新启动服务器，嫌麻烦？不用重启，服务器会自己悄悄的把更新后的程序给重新加载一遍，这就是热部署。</p>
<p>热部署的功能是如何实现的呢？这就要分两种情况来说了，非springboot工程和springboot工程的热部署实现方式完全不一样。先说一下原始的非springboot项目是如何实现热部署的。</p>
<p><strong>非springboot项目热部署实现原理</strong></p>
<p>​        开发非springboot项目时，我们要制作一个web工程并通过tomcat启动，通常需要先安装tomcat服务器到磁盘中，开发的程序配置发布到安装的tomcat服务器上。如果想实现热部署的效果，这种情况其实有两种做法，一种是在tomcat服务器的配置文件中进行配置，这种做法与你使用什么IDE工具无关，不管你使用eclipse还是idea都行。还有一种做法是通过IDE工具进行配置，比如在idea工具中进行设置，这种形式需要依赖IDE工具，每款IDE工具不同，对应的配置也不太一样。但是核心思想是一样的，就是使用服务器去监控其中加载的应用，发现产生了变化就重新加载一次。</p>
<p>​        上面所说的非springboot项目实现热部署看上去是一个非常简单的过程，几乎每个小伙伴都能自己写出来。如果你不会写，我给你个最简单的思路，但是实际设计要比这复杂一些。例如启动一个定时任务，任务启动时记录每个文件的大小，以后每5秒比对一下每个文件的大小是否有改变，或者是否有新文件。如果没有改变，放行，如果有改变，刷新当前记录的文件信息，然后重新启动服务器，这就可以实现热部署了。当然，这个过程肯定不能这么做，比如我把一个打印输出的字符串”abc”改成”cba”，比对大小是没有变化的，但是内容缺实变了，所以这么做肯定不行，只是给大家打个比方，而且重启服务器这就是冷启动了，不能算热部署，领会精神吧。</p>
<p>​        看上去这个过程也没多复杂，在springboot项目中难道还有其他的弯弯绕吗？还真有。</p>
<p><strong>springboot项目热部署实现原理</strong></p>
<p>​        基于springboot开发的web工程其实有一个显著的特征，就是tomcat服务器内置了，还记得内嵌服务器吗？服务器是以一个对象的形式在spring容器中运行的。本来我们期望于tomcat服务器加载程序后由tomcat服务器盯着程序，你变化后我就重新启动重新加载，但是现在tomcat和我们的程序是平级的了，都是spring容器中的组件，这下就麻烦了，缺乏了一个直接的管理权，那该怎么做呢？简单，再搞一个程序X在spring容器中盯着你原始开发的程序A不就行了吗？确实，搞一个盯着程序A的程序X就行了，如果你自己开发的程序A变化了，那么程序X就命令tomcat容器重新加载程序A就OK了。并且这样做有一个好处，spring容器中东西不用全部重新加载一遍，只需要重新加载你开发的程序那一部分就可以了，这下效率又高了，挺好。</p>
<p>​    下面就说说，怎么搞出来这么一个程序X，肯定不是我们自己手写了，springboot早就做好了，搞一个坐标导入进去就行了。</p>
<h3 id="1-1-手动启动热部署"><a href="#1-1-手动启动热部署" class="headerlink" title="1.1 手动启动热部署"></a>1.1 手动启动热部署</h3><p><strong>步骤①</strong>：导入开发者工具对应的坐标</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>步骤②</strong>：构建项目，可以使用快捷键激活此功能</p>
<p>IDEA-Build-Build Project （Ctrl + F9）</p>
<p>以上过程就实现了springboot工程的热部署，是不是挺简单的。不过这里需要把底层的工作工程给普及一下。</p>
<p><strong>重启与重载</strong></p>
<p>​        一个springboot项目在运行时实际上是分两个过程进行的，根据加载的东西不同，划分成base类加载器与restart类加载器。</p>
<ul>
<li>base类加载器：用来加载jar包中的类，jar包中的类和配置文件由于不会发生变化，因此不管加载多少次，加载的内容不会发生变化</li>
<li>restart类加载器：用来加载开发者自己开发的类、配置文件、页面等信息，这一类文件受开发者影响</li>
</ul>
<p>​        当springboot项目启动时，base类加载器执行，加载jar包中的信息后，restart类加载器执行，加载开发者制作的内容。当执行构建项目后，由于jar中的信息不会变化，因此base类加载器无需再次执行，所以仅仅运行restart类加载即可，也就是将开发者自己制作的内容重新加载就行了，这就完成了一次热部署的过程，也可以说热部署的过程实际上是重新加载restart类加载器中的信息。</p>
<p><strong>总结</strong></p>
<ol>
<li>使用开发者工具可以为当前项目开启热部署功能</li>
<li>使用构建项目操作对工程进行热部署</li>
</ol>
<h3 id="1-2-自动启动热部署"><a href="#1-2-自动启动热部署" class="headerlink" title="1.2 自动启动热部署"></a>1.2 自动启动热部署</h3><p>​        自动热部署其实就是设计一个开关，打开这个开关后，IDE工具就可以自动热部署。因此这个操作和IDE工具有关，以下以idea为例设置idea中启动热部署</p>
<p><strong>步骤①</strong>：设置自动构建项目</p>
<p>​        打开【File】，选择【settings…】,在面板左侧的菜单中找到【Compile】选项，然后勾选【Build project automatically】，意思是自动构建项目</p>
<p><strong>步骤②</strong>：允许在程序运行时进行自动构建</p>
<p>​        使用快捷键【Ctrl】+【Alt】+【Shit】+【&#x2F;】打开维护面板，选择第1项【Registry…】在选项中搜索comple，然后勾选对应项<code>compiler.automake.allow.when.app.running</code>即可</p>
<p>​        （在更新的IDEA软件版本中，这个选项到了【settings…】–【Advanced Settings】–【Compiler】–【Allow auto-make to start even if developed application is currently running】）</p>
<p>这样程序在运行的时候就可以进行自动构建了，实现了热部署的效果。</p>
<p><font color="#ff0000"><b>关注</b></font>：如果你每敲一个字母，服务器就重新构建一次，这未免有点太频繁了，所以idea设置当idea工具失去焦点5秒后进行热部署。其实就是你从idea工具中切换到其他工具时进行热部署，比如改完程序需要到浏览器上去调试，这个时候idea就自动进行热部署操作。</p>
<p><strong>总结</strong></p>
<ol>
<li>自动热部署要开启自动构建项目</li>
<li>自动热部署要开启在程序运行时自动构建项目</li>
</ol>
<h3 id="1-3-参与热部署监控的文件范围配置"><a href="#1-3-参与热部署监控的文件范围配置" class="headerlink" title="1.3 参与热部署监控的文件范围配置"></a>1.3 参与热部署监控的文件范围配置</h3><p>​        通过修改项目中的文件，你可以发现其实并不是所有的文件修改都会激活热部署的，原因在于在开发者工具中有一组配置，当满足了配置中的条件后，才会启动热部署，配置中默认不参与热部署的目录信息如下</p>
<ul>
<li>&#x2F;META-INF&#x2F;maven</li>
<li>&#x2F;META-INF&#x2F;resources</li>
<li>&#x2F;resources</li>
<li>&#x2F;static</li>
<li>&#x2F;public</li>
<li>&#x2F;templates</li>
</ul>
<p>​        以上目录中的文件如果发生变化，是不参与热部署的。如果想修改配置，可以通过application.yml文件进行设定哪些文件不参与热部署操作</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">devtools:</span><br>    <span class="hljs-attr">restart:</span><br>      <span class="hljs-comment"># 设置不参与热部署的文件或文件夹</span><br>      <span class="hljs-attr">exclude:</span> <span class="hljs-string">static/**,public/**,config/application.yml</span><br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>通过配置可以修改不参与热部署的文件或目录</li>
</ol>
<p><strong>思考</strong></p>
<p>​        热部署功能是一个典型的开发阶段使用的功能，到了线上环境运行程序时，这个功能就没有意义了。能否关闭热部署功能呢？咱们下一节再说。</p>
<h3 id="1-4-关闭热部署"><a href="#1-4-关闭热部署" class="headerlink" title="1.4 关闭热部署"></a>1.4 关闭热部署</h3><p>​        线上环境运行时是不可能使用热部署功能的，所以需要强制关闭此功能，通过配置可以关闭此功能。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">devtools:</span><br>    <span class="hljs-attr">restart:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<p>​        如果当心配置文件层级过多导致相符覆盖最终引起配置失效，可以提高配置的层级，在更高层级中配置关闭热部署。例如在启动容器前通过系统属性设置关闭热部署功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SSMPApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.setProperty(<span class="hljs-string">&quot;spring.devtools.restart.enabled&quot;</span>,<span class="hljs-string">&quot;false&quot;</span>);<br>        SpringApplication.run(SSMPApplication.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        其实上述担心略微有点多余，因为线上环境的维护是不可能出现修改代码的操作的，这么做唯一的作用是降低资源消耗，毕竟那双盯着你项目是不是产生变化的眼睛只要闭上了，就不具有热部署功能了，这个开关的作用就是禁用对应功能。</p>
<p><strong>总结</strong></p>
<ol>
<li>通过配置可以关闭热部署功能降低线上程序的资源消耗</li>
</ol>
<h2 id="2-配置高级-1"><a href="#2-配置高级-1" class="headerlink" title="2. 配置高级"></a>2. 配置高级</h2><h3 id="2-1-ConfigurationProperties"><a href="#2-1-ConfigurationProperties" class="headerlink" title="2.1 @ConfigurationProperties"></a>2.1 @ConfigurationProperties</h3><p>​        在基础篇学习了@ConfigurationProperties注解，此注解的作用是用来为bean绑定属性的。开发者可以在yml配置文件中以对象的格式添加若干属性</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs YML"><span class="hljs-attr">servers:</span><br>  <span class="hljs-attr">ip-address:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <br>  <span class="hljs-attr">port:</span> <span class="hljs-number">2345</span><br>  <span class="hljs-attr">timeout:</span> <span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure>

<p>​        然后再开发一个用来封装数据的实体类，注意要提供属性对应的setter方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerConfig</span> &#123;<br>    <span class="hljs-keyword">private</span> String ipAddress;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> port;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> timeout;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        使用@ConfigurationProperties注解就可以将配置中的属性值关联到开发的模型类上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;servers&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerConfig</span> &#123;<br>    <span class="hljs-keyword">private</span> String ipAddress;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> port;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> timeout;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        这样加载对应bean的时候就可以直接加载配置属性值了。但是目前我们学的都是给自定义的bean使用这种形式加载属性值，如果是第三方的bean呢？能不能用这种形式加载属性值呢？为什么会提出这个疑问？原因就在于当前@ConfigurationProperties注解是写在类定义的上方，而第三方开发的bean源代码不是你自己书写的，你也不可能到源代码中去添加@ConfigurationProperties注解，这种问题该怎么解决呢？下面就来说说这个问题。</p>
<p>​        使用@ConfigurationProperties注解其实可以为第三方bean加载属性，格式特殊一点而已。</p>
<p><strong>步骤①</strong>：使用@Bean注解定义第三方bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> DruidDataSource <span class="hljs-title function_">datasource</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>    <span class="hljs-keyword">return</span> ds;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>步骤②</strong>：在yml中定义要绑定的属性，注意datasource此时全小写</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">datasource:</span><br>  <span class="hljs-attr">driverClassName:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br></code></pre></td></tr></table></figure>

<p><strong>步骤③</strong>：使用@ConfigurationProperties注解为第三方bean进行属性绑定，注意前缀是全小写的datasource</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;datasource&quot;)</span><br><span class="hljs-keyword">public</span> DruidDataSource <span class="hljs-title function_">datasource</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>    <span class="hljs-keyword">return</span> ds;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        操作方式完全一样，只不过@ConfigurationProperties注解不仅能添加到类上，还可以添加到方法上，添加到类上是为spring容器管理的当前类的对象绑定属性，添加到方法上是为spring容器管理的当前方法的返回值对象绑定属性，其实本质上都一样。</p>
<p>​        做到这其实就出现了一个新的问题，目前我们定义bean不是通过类注解定义就是通过@Bean定义，使用@ConfigurationProperties注解可以为bean进行属性绑定，那在一个业务系统中，哪些bean通过注解@ConfigurationProperties去绑定属性了呢？因为这个注解不仅可以写在类上，还可以写在方法上，所以找起来就比较麻烦了。为了解决这个问题，spring给我们提供了一个全新的注解，专门标注使用@ConfigurationProperties注解绑定属性的bean是哪些。这个注解叫做@EnableConfigurationProperties。具体如何使用呢？</p>
<p><strong>步骤①</strong>：在配置类上开启@EnableConfigurationProperties注解，并标注要使用@ConfigurationProperties注解绑定属性的类</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-string">@SpringBootApplication</span><br><span class="hljs-string">@EnableConfigurationProperties(ServerConfig.class)</span><br><span class="hljs-string">public</span> <span class="hljs-string">class</span> <span class="hljs-string">Springboot13ConfigurationApplication</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>步骤②</strong>：在对应的类上直接使用@ConfigurationProperties进行属性绑定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;servers&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerConfig</span> &#123;<br>    <span class="hljs-keyword">private</span> String ipAddress;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> port;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> timeout;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        有人感觉这没区别啊？注意观察，现在绑定属性的ServerConfig类并没有声明@Component注解。当使用@EnableConfigurationProperties注解时，spring会默认将其标注的类定义为bean，因此无需再次声明@Component注解了。</p>
<p>​        最后再说一个小技巧，使用@ConfigurationProperties注解时，会出现一个提示信息</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Spring/%40ConfigurationProperties%E6%B3%A8%E8%A7%A3%E6%8F%90%E7%A4%BA%E4%BF%A1%E6%81%AF.png" srcset="/img/loading.gif" lazyload alt="image-20220222145535749"></p>
<p>​        出现这个提示后只需要添加一个坐标此提醒就消失了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>使用@ConfigurationProperties可以为使用@Bean声明的第三方bean绑定属性</li>
<li>当使用@EnableConfigurationProperties声明进行属性绑定的bean后，无需使用@Component注解再次进行bean声明</li>
</ol>
<h3 id="2-2-宽松绑定-x2F-松散绑定"><a href="#2-2-宽松绑定-x2F-松散绑定" class="headerlink" title="2.2 宽松绑定&#x2F;松散绑定"></a>2.2 宽松绑定&#x2F;松散绑定</h3><p>​        在进行属性绑定时，可能会遇到如下情况，为了进行标准命名，开发者会将属性名严格按照驼峰命名法书写，在yml配置文件中将datasource修改为dataSource，如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">dataSource:</span><br>  <span class="hljs-attr">driverClassName:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br></code></pre></td></tr></table></figure>

<p>​        此时程序可以正常运行，然后又将代码中的前缀datasource修改为dataSource，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;dataSource&quot;)</span><br><span class="hljs-keyword">public</span> DruidDataSource <span class="hljs-title function_">datasource</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>    <span class="hljs-keyword">return</span> ds;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        此时就发生了编译错误，而且并不是idea工具导致的，运行后依然会出现问题，配置属性名dataSource是无效的</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CMD">Configuration property name &#x27;dataSource&#x27; is <span class="hljs-keyword">not</span> valid:<br><br>    Invalid characters: &#x27;S&#x27;<br><span class="hljs-function">    Bean: <span class="hljs-title">datasource</span></span><br><span class="hljs-function">    <span class="hljs-title">Reason</span>: <span class="hljs-title">Canonical</span> <span class="hljs-title">names</span> <span class="hljs-title">should</span> <span class="hljs-title">be</span> <span class="hljs-title">kebab</span>-<span class="hljs-title">case</span> (&#x27;-&#x27; <span class="hljs-title">separated</span>), <span class="hljs-title">lowercase</span> <span class="hljs-title">alpha</span>-<span class="hljs-title">numeric</span> <span class="hljs-title">characters</span> <span class="hljs-title">and</span> <span class="hljs-title">must</span> <span class="hljs-title">start</span> <span class="hljs-title">with</span> <span class="hljs-title">a</span> <span class="hljs-title">letter</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">Action</span>:</span><br><span class="hljs-function"><span class="hljs-title">Modify</span> &#x27;<span class="hljs-title">dataSource</span>&#x27; <span class="hljs-title">so</span> <span class="hljs-title">that</span> <span class="hljs-title">it</span> <span class="hljs-title">conforms</span> <span class="hljs-title">to</span> <span class="hljs-title">the</span> <span class="hljs-title">canonical</span> <span class="hljs-title">names</span> <span class="hljs-title">requirements</span>.</span><br></code></pre></td></tr></table></figure>

<p>​        为什么会出现这种问题，这就要来说一说springboot进行属性绑定时的一个重要知识点了，有关属性名称的宽松绑定，也可以称为宽松绑定。</p>
<p>​        什么是宽松绑定？实际上是springboot进行编程时人性化设计的一种体现，即配置文件中的命名格式与变量名的命名格式可以进行格式上的最大化兼容。兼容到什么程度呢？几乎主流的命名格式都支持，例如：</p>
<p>​        在ServerConfig中的ipAddress属性名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;servers&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerConfig</span> &#123;<br>    <span class="hljs-keyword">private</span> String ipAddress;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        可以与下面的配置属性名规则全兼容</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs YML"><span class="hljs-attr">servers:</span><br>  <span class="hljs-attr">ipAddress:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span>       <span class="hljs-comment"># 驼峰模式</span><br>  <span class="hljs-attr">ip_address:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span>      <span class="hljs-comment"># 下划线模式</span><br>  <span class="hljs-attr">ip-address:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span>      <span class="hljs-comment"># 烤肉串模式</span><br>  <span class="hljs-attr">IP_ADDRESS:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span>      <span class="hljs-comment"># 常量模式</span><br></code></pre></td></tr></table></figure>

<p>​        也可以说，以上4种模式最终都可以匹配到ipAddress这个属性名。为什么这样呢？原因就是在进行匹配时，配置中的名称要去掉中划线和下划线后，忽略大小写的情况下去与java代码中的属性名进行忽略大小写的等值匹配，以上4种命名去掉下划线中划线忽略大小写后都是一个词ipaddress，java代码中的属性名忽略大小写后也是ipaddress，这样就可以进行等值匹配了，这就是为什么这4种格式都能匹配成功的原因。不过springboot官方推荐使用烤肉串模式，也就是中划线模式。</p>
<p>​        到这里我们掌握了一个知识点，就是命名的规范问题。再来看开始出现的编程错误信息</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CMD">Configuration property name &#x27;dataSource&#x27; is <span class="hljs-keyword">not</span> valid:<br><br>    Invalid characters: &#x27;S&#x27;<br><span class="hljs-function">    Bean: <span class="hljs-title">datasource</span></span><br><span class="hljs-function">    <span class="hljs-title">Reason</span>: <span class="hljs-title">Canonical</span> <span class="hljs-title">names</span> <span class="hljs-title">should</span> <span class="hljs-title">be</span> <span class="hljs-title">kebab</span>-<span class="hljs-title">case</span> (&#x27;-&#x27; <span class="hljs-title">separated</span>), <span class="hljs-title">lowercase</span> <span class="hljs-title">alpha</span>-<span class="hljs-title">numeric</span> <span class="hljs-title">characters</span> <span class="hljs-title">and</span> <span class="hljs-title">must</span> <span class="hljs-title">start</span> <span class="hljs-title">with</span> <span class="hljs-title">a</span> <span class="hljs-title">letter</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">Action</span>:</span><br><span class="hljs-function"><span class="hljs-title">Modify</span> &#x27;<span class="hljs-title">dataSource</span>&#x27; <span class="hljs-title">so</span> <span class="hljs-title">that</span> <span class="hljs-title">it</span> <span class="hljs-title">conforms</span> <span class="hljs-title">to</span> <span class="hljs-title">the</span> <span class="hljs-title">canonical</span> <span class="hljs-title">names</span> <span class="hljs-title">requirements</span>.</span><br></code></pre></td></tr></table></figure>

<p>​        其中Reason描述了报错的原因，规范的名称应该是烤肉串(kebab)模式(case)，即使用-分隔，使用小写字母数字作为标准字符，且必须以字母开头。然后再看我们写的名称dataSource，就不满足上述要求。闹了半天，在书写前缀时，这个词不是随意支持的，必须使用上述标准。编程写了这么久，基本上编程习惯都养成了，到这里又被springboot教育了，没辙，谁让人家东西好用呢，按照人家的要求写吧。</p>
<p>​        最后说一句，以上规则仅针对springboot中@ConfigurationProperties注解进行属性绑定时有效，对@Value注解进行属性映射无效。有人就说，那我不用你不就行了？不用，你小看springboot的推广能力了，到原理篇我们看源码时，你会发现内部全是这玩意儿，算了，拿人手短吃人嘴短，认怂吧。</p>
<p><strong>总结</strong></p>
<ol>
<li>@ConfigurationProperties绑定属性时支持属性名宽松绑定，这个宽松体现在属性名的命名规则上</li>
<li>@Value注解不支持松散绑定规则</li>
<li><strong>绑定前缀名推荐采用烤肉串命名规则，即使用中划线做分隔符</strong></li>
</ol>
<h3 id="2-3-常用计量单位绑定"><a href="#2-3-常用计量单位绑定" class="headerlink" title="2.3 常用计量单位绑定"></a>2.3 常用计量单位绑定</h3><p>​        在前面的配置中，我们书写了如下配置值，其中第三项超时时间timeout描述了服务器操作超时时间，当前值是-1表示永不超时。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs YML"><span class="hljs-attr">servers:</span><br>  <span class="hljs-attr">ip-address:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <br>  <span class="hljs-attr">port:</span> <span class="hljs-number">2345</span><br>  <span class="hljs-attr">timeout:</span> <span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure>

<p>​        但是每个人都这个值的理解会产生不同，比如线上服务器完成一次主从备份，配置超时时间240，这个240如果单位是秒就是超时时间4分钟，如果单位是分钟就是超时时间4小时。面对一次线上服务器的主从备份，设置4分钟，简直是开玩笑，别说拷贝过程，备份之前的压缩过程4分钟也搞不定，这个时候问题就来了，怎么解决这个误会？</p>
<p>​        除了加强约定之外，springboot充分利用了JDK8中提供的全新的用来表示计量单位的新数据类型，从根本上解决这个问题。以下模型类中添加了两个JDK8中新增的类，分别是Duration和DataSize</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;servers&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerConfig</span> &#123;<br>    <span class="hljs-meta">@DurationUnit(ChronoUnit.HOURS)</span><br>    <span class="hljs-keyword">private</span> Duration serverTimeOut;<br>    <span class="hljs-meta">@DataSizeUnit(DataUnit.MEGABYTES)</span><br>    <span class="hljs-keyword">private</span> DataSize dataSize;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>Duration</strong>：表示时间间隔，可以通过@DurationUnit注解描述时间单位，例如上例中描述的单位为小时（ChronoUnit.HOURS）</p>
<p><strong>DataSize</strong>：表示存储空间，可以通过@DataSizeUnit注解描述存储空间单位，例如上例中描述的单位为MB（DataUnit.MEGABYTES）</p>
<p>​        使用上述两个单位就可以有效避免因沟通不同步或文档不健全导致的信息不对称问题，从根本上解决了问题，避免产生误读。</p>
<p>​        Druation、DataSize和常用单位有很多，用到时用.式结构选择即可</p>
<h3 id="2-4-校验"><a href="#2-4-校验" class="headerlink" title="2.4 校验"></a>2.4 校验</h3><p>​        目前我们在进行属性绑定时可以通过松散绑定规则在书写时放飞自我了，但是在书写时由于无法感知模型类中的数据类型，就会出现类型不匹配的问题，比如代码中需要int类型，配置中给了非法的数值，例如写一个“a”，这种数据肯定无法有效的绑定，还会引发错误。        SpringBoot给出了强大的数据校验功能，可以有效的避免此类问题的发生。在JAVAEE的JSR303规范中给出了具体的数据校验标准，开发者可以根据自己的需要选择对应的校验框架，此处使用Hibernate提供的校验框架来作为实现进行数据校验。书写应用格式非常固定，话不多说，直接上步骤</p>
<p><strong>步骤①</strong>：开启校验框架</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--1.导入JSR303规范--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.validation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>validation-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--使用hibernate框架提供的校验器做实现--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate.validator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-validator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>步骤②</strong>：在需要开启校验功能的类上使用注解@Validated开启校验功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;servers&quot;)</span><br><span class="hljs-comment">//开启对当前bean的属性注入校验</span><br><span class="hljs-meta">@Validated</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerConfig</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>步骤③</strong>：对具体的字段设置校验规则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;servers&quot;)</span><br><span class="hljs-comment">//开启对当前bean的属性注入校验</span><br><span class="hljs-meta">@Validated</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerConfig</span> &#123;<br>    <span class="hljs-comment">//设置具体的规则</span><br>    <span class="hljs-meta">@Max(value = 8888,message = &quot;最大值不能超过8888&quot;)</span><br>    <span class="hljs-meta">@Min(value = 202,message = &quot;最小值不能低于202&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> port;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        通过设置数据格式校验，就可以有效避免非法数据加载，其实使用起来还是挺轻松的，基本上就是一个格式。</p>
<p><strong>总结</strong></p>
<ol>
<li>开启Bean属性校验功能一共3步：导入JSR303与Hibernate校验框架坐标、使用@Validated注解启用校验功能、使用具体校验规则规范数据校验格式</li>
</ol>
<h3 id="2-5-数据类型转换"><a href="#2-5-数据类型转换" class="headerlink" title="2.5 数据类型转换"></a>2.5 数据类型转换</h3><p>​        有关spring属性注入的问题到这里基本上就讲完了，但是最近一名开发者向我咨询了一个问题，我觉得需要给各位学习者分享一下。在学习阶段其实我们遇到的问题往往复杂度比较低，单一性比较强，但是到了线上开发时，都是综合性的问题，而这个开发者遇到的问题就是由于bean的属性注入引发的灾难。</p>
<p>​        先把问题描述一下，这位开发者连接数据库正常操作，但是运行程序后显示的信息是密码错误。</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMD"><span class="hljs-function">java.sql.SQLException: <span class="hljs-title">Access</span> <span class="hljs-title">denied</span> <span class="hljs-title">for</span> <span class="hljs-title">user</span> &#x27;<span class="hljs-title">root</span>&#x27;@&#x27;<span class="hljs-title">localhost</span>&#x27; (<span class="hljs-title">using</span> <span class="hljs-title">password</span>: <span class="hljs-title">YES</span>)</span><br></code></pre></td></tr></table></figure>

<p>​        其实看到这个报错，几乎所有的学习者都能分辨出来，这是用户名和密码不匹配，就就是密码输入错了，但是问题就在于密码并没有输入错误，这就比较讨厌了。给的报错信息无法帮助你有效的分析问题，甚至会给你带到沟里。如果是初学者，估计这会心态就崩了，我密码没错啊，你怎么能说我有错误呢？来看看用户名密码的配置是如何写的：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">0127</span><br></code></pre></td></tr></table></figure>

<p>​        这名开发者的生日是1月27日，所以密码就使用了0127，其实问题就出在这里了。</p>
<p>​        之前在基础篇讲属性注入时，提到过类型相关的知识，在整数相关知识中有这么一句话，<strong>支持二进制，八进制，十六进制</strong></p>
<p>​        这个问题就处在这里了，因为0127在开发者眼中是一个字符串“0127”，但是在springboot看来，这就是一个数字，而且是一个八进制的数字。当后台使用String类型接收数据时，如果配置文件中配置了一个整数值，他是先安装整数进行处理，读取后再转换成字符串。巧了，0127撞上了八进制的格式，所以最终以十进制数字87的结果存在了。</p>
<p>​        这里提两个注意点，<strong>第一，字符串标准书写加上引号包裹，养成习惯，第二，遇到0开头的数据多注意吧。</strong></p>
<p><strong>总结</strong></p>
<ol>
<li>yaml文件中对于数字的定义支持进制书写格式，如需使用字符串请使用引号明确标注</li>
</ol>
<h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><p>测试是保障程序正确性的唯一屏障，在企业级开发中更是不可缺少，但是由于测试代码往往不产生实际效益，所以一些小型公司并不是很关注，导致一些开发者从小型公司进入中大型公司后，往往这一块比较短板，所以还是要拿出来把这一块知识好好说说，做一名专业的开发人员。</p>
<p>暂时略过，以后用到的时候再说</p>
<h2 id="4-数据层解决方案"><a href="#4-数据层解决方案" class="headerlink" title="4. 数据层解决方案"></a>4. 数据层解决方案</h2><h3 id="4-1-SQL"><a href="#4-1-SQL" class="headerlink" title="4.1 SQL"></a>4.1 SQL</h3><p>​        回忆一下之前做SSMP整合的时候数据层解决方案涉及到了哪些技术？MySQL数据库与MyBatisPlus框架，后面又学了Druid数据源的配置，所以现在数据层解决方案可以说是Mysql+Druid+MyBatisPlus。而三个技术分别对应了数据层操作的三个层面：</p>
<ul>
<li>数据源技术：Druid</li>
<li>持久化技术：MyBatisPlus</li>
<li>数据库技术：MySQL</li>
</ul>
<p>这三个层面Springboot也提供了默认的技术</p>
<p>（1）springboot提供了3款内嵌数据源技术，分别如下：</p>
<ul>
<li>HikariCP</li>
<li>Tomcat提供DataSource</li>
<li>Commons DBCP</li>
</ul>
<p>（2）springboot内置了1款持久化技术：JdbcTemplate</p>
<p>（3）springboot提供了3款内置的数据库，分别是</p>
<ul>
<li><p>H2</p>
</li>
<li><p>HSQL</p>
</li>
<li><p>Derby</p>
</li>
</ul>
<p>到这里SQL相关的数据层解决方案就讲完了，现在的可选技术就丰富的多了。</p>
<ul>
<li>数据源技术：Druid、Hikari、tomcat DataSource、DBCP</li>
<li>持久化技术：MyBatisPlus、MyBatis、JdbcTemplate</li>
<li>数据库技术：MySQL、H2、HSQL、Derby</li>
</ul>
<p>现在开发程序时就可以在以上技术中任选一种组织成一套数据库解决方案了。</p>
<h3 id="4-2-NoSQL"><a href="#4-2-NoSQL" class="headerlink" title="4.2 NoSQL"></a>4.2 NoSQL</h3><p>​        SQL数据层解决方案说完了，下面来说收NoSQL数据层解决方案。这个NoSQL是什么意思呢？从字面来看，No表示否定，NoSQL就是非关系型数据库解决方案，意思就是数据该存存该取取，只是这些数据不放在关系型数据库中了，那放在哪里？自然是一些能够存储数据的其他相关技术中了，比如Redis等。本节讲解的内容就是springboot如何整合这些技术，在springboot官方文档中提供了10种相关技术的整合方案，我们将讲解国内市场上最流行的几款NoSQL数据库整合方案，分别是Redis、MongoDB、ES。</p>
<p>​        因为每个小伙伴学习这门课程的时候起点不同，为了便于各位学习者更好的学习，每种技术在讲解整合前都会先讲一下安装和基本使用，然后再讲整合。如果对某个技术比较熟悉的小伙伴可以直接跳过安装的学习过程，直接看整合方案即可。此外上述这些技术最佳使用方案都是在Linux服务器上部署，但是考虑到各位小伙伴的学习起点差异过大，所以下面的课程都是以Windows平台作为安装基础讲解，如果想看Linux版软件安装，可以再找到对应技术的学习文档查阅学习。</p>
<h4 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h4><p>​        Redis是一款采用key-value数据存储格式的内存级NoSQL数据库，重点关注数据存储格式，是key-value格式，也就是键值对的存储形式。与MySQL数据库不同，MySQL数据库有表、有字段、有记录，Redis没有这些东西，就是一个名称对应一个值，并且数据以存储在内存中使用为主。什么叫以存储在内存中为主？其实Redis有它的数据持久化方案，分别是RDB和AOF，但是Redis自身并不是为了数据持久化而生的，主要是在内存中保存数据，加速数据访问的，所以说是一款内存级数据库。</p>
<p>​        Redis支持多种数据存储格式，比如可以直接存字符串，也可以存一个map集合，list集合，后面会涉及到一些不同格式的数据操作，这个需要先学习一下才能进行整合，所以在基本操作中会介绍一些相关操作。下面就先安装，再操作，最后说整合</p>
<h2 id="5-整合第三方技术"><a href="#5-整合第三方技术" class="headerlink" title="5. 整合第三方技术"></a>5. 整合第三方技术</h2><h3 id="5-1-缓存"><a href="#5-1-缓存" class="headerlink" title="5.1 缓存"></a>5.1 缓存</h3><h3 id="5-2-任务"><a href="#5-2-任务" class="headerlink" title="5.2 任务"></a>5.2 任务</h3><h3 id="5-3-邮件"><a href="#5-3-邮件" class="headerlink" title="5.3 邮件"></a>5.3 邮件</h3><p>经常在Java程序中开发发送邮件的需求，学习邮件发送之前先了解3个协议</p>
<ul>
<li>SMTP（Simple Mail Transfer Protocol）：简单邮件传输协议，用于<strong>发送</strong>电子邮件的传输协议</li>
<li>POP3（Post Office Protocol - Version 3）：用于<strong>接收</strong>电子邮件的标准协议</li>
<li>IMAP（Internet Mail Access Protocol）：互联网消息协议，是POP3的替代协议</li>
</ul>
<p>SMPT是发邮件的标准，POP3是收邮件的标准，IMAP是对POP3的升级。我们制作程序中操作邮件，通常是发邮件，所以SMTP是使用的重点，收邮件大部分都是通过邮件客户端完成，所以开发收邮件的代码极少。</p>
<h4 id="发送简单邮件"><a href="#发送简单邮件" class="headerlink" title="发送简单邮件"></a>发送简单邮件</h4><p><strong>步骤①</strong>：导入springboot整合javamail的starter</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>步骤②</strong>：配置邮箱的登录信息</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mail:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">smtp.163.com</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">xxxx@163.com</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">xxxx</span><br></code></pre></td></tr></table></figure>

<p>​        java程序仅用于发送邮件，邮件的功能还是邮件供应商提供的，所以这里是用别人的邮件服务，要配置对应信息。host配置的是提供邮件服务的主机协议，当前程序仅用于发送邮件，因此配置的是smtp的协议。password并不是邮箱账号的登录密码，是邮件供应商提供的一个加密后的密码，也是为了保障系统安全性。不然外部人员通过地址访问下载了配置文件，直接获取到了邮件密码就会有极大的安全隐患。有关该密码的获取每个邮件供应商提供的方式都不一样，此处略过。可以到邮件供应商的设置页面找POP3或IMAP这些关键词找到对应的获取位置。</p>
<p><strong>步骤③</strong>：使用JavaMailSender接口发送邮件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendMailServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SendMailService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JavaMailSender javaMailSender;<br><br>    <span class="hljs-comment">//发送人</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxxx@163.com&quot;</span>;<br>    <span class="hljs-comment">//接收人</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxxx@qq.com&quot;</span>;<br>    <span class="hljs-comment">//标题</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">subject</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;测试邮件&quot;</span>;<br>    <span class="hljs-comment">//正文</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;测试邮件正文内容&quot;</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMail</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">SimpleMailMessage</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleMailMessage</span>();<br>        message.setFrom(from+<span class="hljs-string">&quot;(发件人别名)&quot;</span>);<br>        message.setTo(to);<br>        message.setSubject(subject);<br>        message.setText(context);<br>        javaMailSender.send(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        将发送邮件的必要信息（发件人、收件人、标题、正文）封装到SimpleMailMessage对象中，可以根据规则设置发送人昵称等。</p>
<p>​        <strong>需要注意的是，邮件信息的对象为<code>SimpleMailMessage</code>，发邮件的对象为<code>JavaMailSender</code></strong></p>
<p><strong>步骤④</strong>：在测试类里写测试，发送邮件，去收件箱里查看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot20MailApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SendMailServiceImpl sendMailService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        sendMailService.sendMail();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="发送多组件邮件（附件、复杂正文）"><a href="#发送多组件邮件（附件、复杂正文）" class="headerlink" title="发送多组件邮件（附件、复杂正文）"></a>发送多组件邮件（附件、复杂正文）</h4><p>​    发送简单邮件仅需要提供对应的4个基本信息就可以了，使用的信息对象为<code>SimpleMailMessage</code>，如果想发送复杂的邮件，尤其是有附件等复杂邮件，需要更换邮件对象。使用信息对象<code>MimeMessage</code>可以发送特殊的邮件。</p>
<p>​    这个<code>MimeMessage</code>对象还不是new出来的，是通过发邮件对象<code>JavaMailSender</code>调用方法创建出来的。并且<code>MimeMessage</code>对象还不能像<code>SimpleMailMessage</code>那样直接就设置邮件内容了，还要再通过一个<code>MimeMessageHelper</code>去设置邮件内容，并且需要捕获异常，最后再通过对象<code>JavaMailSender</code>发送<code>MimeMessage</code>对象</p>
<p>​    还需要注意的是为了让邮件支持html格式的文本，helper.setText()第二个参数需要设置为true</p>
<p><strong>发送网页正文邮件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendMailServiceImpl2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SendMailService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JavaMailSender javaMailSender;<br><br>    <span class="hljs-comment">//发送人</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxxx@163.com&quot;</span>;<br>    <span class="hljs-comment">//接收人</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxxx@qq.com&quot;</span>;<br>    <span class="hljs-comment">//标题</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">subject</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;测试邮件&quot;</span>;<br>    <span class="hljs-comment">//正文（要想用html的格式去解析，helper.setText()得传入true）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&lt;a href=&#x27;https://www.itcast.cn&#x27;&gt;点开有惊喜&lt;/a&gt;&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMail</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">MimeMessage</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> javaMailSender.createMimeMessage();<br>        	<span class="hljs-type">MimeMessageHelper</span> <span class="hljs-variable">helper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MimeMessageHelper</span>(message);<br>            helper.setFrom(from+<span class="hljs-string">&quot;(发送人昵称)&quot;</span>);<br>            helper.setTo(to);<br>            helper.setSubject(subject);<br>            helper.setText(context,<span class="hljs-literal">true</span>);		<span class="hljs-comment">//此处设置正文支持html解析</span><br><br>            javaMailSender.send(message);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>发送带有附件的邮件</strong></p>
<p>此处和上面的不同点在于创建<code>MimeMessageHelper</code>的时候，还要设置传入第二个参数为true，这样才能支持附件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendMailServiceImpl2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SendMailService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JavaMailSender javaMailSender;<br><br>    <span class="hljs-comment">//发送人</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxxx@163.com&quot;</span>;<br>    <span class="hljs-comment">//接收人</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxxx@qq.com&quot;</span>;<br>    <span class="hljs-comment">//标题</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">subject</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;测试邮件&quot;</span>;<br>    <span class="hljs-comment">//正文</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;测试邮件正文&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMail</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">MimeMessage</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> javaMailSender.createMimeMessage();<br>            <span class="hljs-type">MimeMessageHelper</span> <span class="hljs-variable">helper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MimeMessageHelper</span>(message,<span class="hljs-literal">true</span>);  <span class="hljs-comment">//此处设置支持附件</span><br>            helper.setFrom(from+<span class="hljs-string">&quot;(发送人昵称)&quot;</span>);<br>            helper.setTo(to);<br>            helper.setSubject(subject);<br>            helper.setText(context,<span class="hljs-literal">true</span>);		<span class="hljs-comment">//此处设置正文支持html解析</span><br><br>            <span class="hljs-comment">//添加附件</span><br>            <span class="hljs-type">File</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;src/main/resources/logo.png&quot;</span>);<br>            helper.addAttachment(<span class="hljs-string">&quot;图标.png&quot;</span>,f1);<br><br>            javaMailSender.send(message);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>总结</strong>：springboot整合javamail其实就是简化了发送邮件的客户端对象JavaMailSender的初始化过程，通过配置的形式加载信息简化开发过程</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Spring/" class="category-chain-item">Spring</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>SpringBoot</div>
      <div>http://jswanyu.github.io/2022/05/03/Spring/03-SpringBoot/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>万宇</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年5月3日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>






<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
