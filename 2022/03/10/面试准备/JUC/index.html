

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="万宇">
  <meta name="keywords" content="">
  
    <meta name="description" content="多线程、互斥与同步什么是进程？是什么线程？进程和线程的关系？（区别）线程是处理器任务调度和执行的基本单位 进程是操作系统资源分配的基本单位。  进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）  进程是程序的一次执行过程，是系统运行的基本单位。线程是一个比进程更小的执行单位，一个进">
<meta property="og:type" content="article">
<meta property="og:title" content="面试准备：JUC">
<meta property="og:url" content="http://jswanyu.github.io/2022/03/10/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/JUC/index.html">
<meta property="og:site_name" content="Wynn&#39;s blog">
<meta property="og:description" content="多线程、互斥与同步什么是进程？是什么线程？进程和线程的关系？（区别）线程是处理器任务调度和执行的基本单位 进程是操作系统资源分配的基本单位。  进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）  进程是程序的一次执行过程，是系统运行的基本单位。线程是一个比进程更小的执行单位，一个进">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/icon/%E9%9D%A2%E8%AF%95-%E9%A6%96%E9%A1%B5%E5%B0%81%E9%9D%A2%E5%9B%BE.jpeg">
<meta property="article:published_time" content="2022-03-10T01:12:22.000Z">
<meta property="article:modified_time" content="2022-06-23T15:12:51.253Z">
<meta property="article:author" content="万宇">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/icon/%E9%9D%A2%E8%AF%95-%E9%A6%96%E9%A1%B5%E5%B0%81%E9%9D%A2%E5%9B%BE.jpeg">
  
  
  
  <title>面试准备：JUC - Wynn&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"jswanyu.github.io","root":"/","version":"1.9.1","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":false},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wynn&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/log/">
                <i class="iconfont icon-tags-fill"></i>
                日志
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                时间线
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/icon/%E9%9D%A2%E8%AF%95-%E6%96%87%E7%AB%A0%E9%A1%B5%E9%A1%B6%E9%83%A8%E5%9B%BE.jpeg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="面试准备：JUC"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-03-10 09:12" pubdate>
          2022年3月10日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          29k 字
        
      </span>
    

    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">面试准备：JUC</h1>
            
            <div class="markdown-body">
              
              <h2 id="多线程、互斥与同步"><a href="#多线程、互斥与同步" class="headerlink" title="多线程、互斥与同步"></a>多线程、互斥与同步</h2><h3 id="什么是进程？是什么线程？进程和线程的关系？（区别）"><a href="#什么是进程？是什么线程？进程和线程的关系？（区别）" class="headerlink" title="什么是进程？是什么线程？进程和线程的关系？（区别）"></a>什么是进程？是什么线程？进程和线程的关系？（区别）</h3><p>线程是处理器<strong>任务调度和执行</strong>的基本单位</p>
<p>进程是操作系统<strong>资源分配</strong>的基本单位。</p>
<blockquote>
<p><strong>进程就可以视为程序的一个实例</strong>。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</p>
</blockquote>
<p>进程是程序的一次执行过程，是系统运行的基本单位。线程是一个比进程更小的执行单位，一个进程可以包含多个线程，真正执行任务的是线程</p>
<p>从Java虚拟机的角度来理解：Java虚拟机的运行时数据区包含堆、方法区、虚拟机栈、本地方法栈、程序计数器。</p>
<p>各个进程之间是相互独立的，每个进程会包含多个线程，每个进程所包含的多个线程并不是相互独立的，这个线程会<strong>共享进程的堆和方法区</strong>，但这些线程不会共享虚拟机栈、本地方法栈、程序计数器。即每个进程所包含的多个线程共享进程的堆和方法区，并且具备私有的虚拟机栈、本地方法栈、程序计数器，如图所示，假设某个进程包含三个线程。</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java/JUC/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB.png" srcset="/img/loading.gif" lazyload alt="image-20220514233844593"></p>
<p>由上面可知以下进程和线程在以下几个方面的区别：</p>
<ul>
<li>内存分配：进程和进程之间的地址空间和资源是相互独立的，同一个进程里的线程会共享线程的地址空间和资源（堆和方法区）。</li>
<li>资源开销：每个进程具备各自的数据空间，进程之间的切换会有较大的开销。属于同一进程的线程会共享堆和方法区，同时具备私有的虚拟机栈、本地方法栈、程序计数器，线程之间的切换资源开销较小。</li>
<li>通信复杂程度：进程间通信较为复杂，同一台计算机的进程通信称为 IPC，不同计算机之间的进程通信，需要通过网络；线程通信相对简单，因为它们共享进程内的内存（比如多个线程可以访问同一个共享变量）</li>
</ul>
<h3 id="并行和并发的区别？"><a href="#并行和并发的区别？" class="headerlink" title="并行和并发的区别？"></a>并行和并发的区别？</h3><p>并发(concurrent)：一个单核CPU处理多个任务，在不同的时间轮流执行不同线程中的指令。并发</p>
<blockquote>
<p>虽然叫并发，但实际是串行执行，CPU的时间片切换非常快，给人一种同时运行的感觉。微观串行，宏观并行<br>（操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于cpu 在线程间（时间片很短）的切换非常快，给人的感觉是同时运行的 。）</p>
</blockquote>
<p>并行(concurrent)：系统有一个以上CPU（或者说是核）时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行</p>
<blockquote>
<p>并行中也可能存在并发，比如说2核cpu, 同时执行4个线程. 理论上同时可以有2个线程是并行执行的. 此时还是存在并发， 因为2个cpu也会同时切换不同的线程执行任务罢了</p>
</blockquote>
<p>并发，一个CPU看起来“同时”做多件事。</p>
<p>并行，多个CPU真的在同时做多件事。</p>
<h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>以调用方角度来讲，如果</p>
<ul>
<li>需要等待结果返回，才能继续运行就是<strong>同步</strong></li>
<li>不需要等待结果返回，就能继续运行就是<strong>异步</strong></li>
</ul>
<p>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如 果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停…</p>
<h3 id="多线程的优缺点（为什么使用多线程、多线程会引发什么问题）"><a href="#多线程的优缺点（为什么使用多线程、多线程会引发什么问题）" class="headerlink" title="多线程的优缺点（为什么使用多线程、多线程会引发什么问题）"></a>多线程的优缺点（为什么使用多线程、多线程会引发什么问题）</h3><p>优点：当一个线程进入等待状态或者阻塞时，CPU可以先去执行其他线程，提高CPU的利用率。</p>
<p>缺点：</p>
<ul>
<li>上下文切换：频繁的上下文切换会影响多线程的执行速度。</li>
<li>死锁</li>
<li>资源限制：在进行并发编程时，程序的执行速度受限于计算机的硬件或软件资源。并发编程中程序执行变快的原因是将程序中串行执行的部分变成并发执行，如果因为资源限制，并发执行的部分仍在串行执行，程序执行将会变得更慢，因为程序并发需要上下文切换和资源调度。</li>
</ul>
<p>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活</p>
<p>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的</p>
<ul>
<li><p>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分（阿姆达尔定律）</p>
</li>
<li><p>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</p>
</li>
</ul>
<p>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有【非阻塞 IO】和【异步 IO】优化</p>
<h3 id="线程的上下文切换（Thread-Context-Switch）"><a href="#线程的上下文切换（Thread-Context-Switch）" class="headerlink" title="线程的上下文切换（Thread Context Switch）"></a>线程的上下文切换（Thread Context Switch）</h3><p>所谓的上下文切换其实也就是<strong>线程切换</strong>，即cpu 不再执行当前的线程，转而执行另一个线程的代码。一般会是因为以下几种情况：分给线程的 cpu 时间片用完；垃圾回收；有更高优先级的线程需要运行；线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</p>
<p>当线程切换发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是<strong>程序计数器</strong>（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p>
<ul>
<li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li>
<li><strong>线程切换频繁发生会影响性能</strong></li>
</ul>
<p>即便是单核的处理器也会支持多线程，处理器会给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给每个线程的执行时间，一般来说时间片非常的短，所以处理器会不停地切换线程。CPU会通过时间片分配算法来循环执行任务，当前任务执行完一个时间片后会切换到下一个任务，但切换前会保存上一个任务的状态，因为下次切换回这个任务时还要加载这个任务的状态继续执行，从任务保存到再加载的过程就是一次上下文切换。</p>
<h3 id="什么是线程互斥？什么是线程同步？他们是如何实现的？"><a href="#什么是线程互斥？什么是线程同步？他们是如何实现的？" class="headerlink" title="什么是线程互斥？什么是线程同步？他们是如何实现的？"></a>什么是线程互斥？什么是线程同步？他们是如何实现的？</h3><p>线程的互斥：指某一个资源只能<strong>被一个访问者访问</strong>，具有唯一性和排他性。但访问者对资源访问的顺序是<strong>乱序</strong>的。</p>
<blockquote>
<p>一段代码块内如果存在对<strong>共享资源的多线程读写操作</strong>，称这段代码块为<strong>临界区</strong>，由于代码的执行序列不同而导致结果无法预测，称之为发生了<strong>竞态条件</strong>，为了避免临界区的竞态条件发生，要让他们互斥</p>
</blockquote>
<p>线程互斥的实现方法：</p>
<ul>
<li>阻塞式的解决方案：synchronized，Lock</li>
<li>非阻塞式的解决方案：原子变量</li>
</ul>
<p>线程的同步：指<strong>在互斥的基础上</strong>使得访问者对资源进行<strong>有序</strong>访问。</p>
<p>线程同步的实现方法：</p>
<ul>
<li>同步方法、同步代码块</li>
<li>wait() 和notify()</li>
<li>使用volatile实现线程同步</li>
<li>使用重入锁实现线程同步</li>
<li>使用局部变量实现线程同步</li>
<li>使用阻塞队列实现线程同步</li>
</ul>
<h3 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h3><p>（1）成员变量和静态变量</p>
<ul>
<li>如果它们没有共享，则线程安全</li>
<li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况<ul>
<li>如果只有读操作，则线程安全</li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li>
</ul>
</li>
</ul>
<p>（2）局部变量</p>
<ul>
<li><p><strong>基本数据类型</strong>的局部变量是线程安全的，每个线程的栈帧内存中局部变量会被创建多份，不会共享</p>
</li>
<li><p>局部变量<strong>引用的对象</strong>会被共享，如果执行了读写操作，则<strong>线程不安全</strong>。如果没被共享或者被共享但没读写，也可能是线程安全的</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadUnsafe</span> &#123;<br>    ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <span class="hljs-comment">// list是成员变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>        <span class="hljs-comment">// &#123; 临界区, 会产生竞态条件</span><br>            method2();<br>            method3();<br>        <span class="hljs-comment">// &#125; 临界区</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//注意此处方法定义为private</span><br>        list.add(<span class="hljs-string">&quot;666&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//注意此处方法定义为private</span><br>        list.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  碰到上面这种<strong>共享的成员变量</strong>情况，可以改成线程内<strong>私有的局部变量</strong>，则会在堆中创建每个线程自己对应的对象，不会存在线程安全问题。</p>
<p>  如下代码中，将成员变量 list 修改为方法1的局部变量，那么就不会有上述问题了。list 是局部变量，每个线程调用时会创建其不同实例，没有共享。而 method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象。method3 的参数分析与 method2 相同</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafe</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <span class="hljs-comment">//改为局部变量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            method2(list);<br>            method3(list);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;   <span class="hljs-comment">//局部变量传进来，</span><br>        list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;   <span class="hljs-comment">//注意此处方法定义为private</span><br>        list.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>（3）方法修饰符保护引用暴露</p>
<p>如果把上个例子的method2或method3访问修饰权限改为public，就可以有子类去继承ThreadSafe并覆盖method2或method3，那就可能存在线程安全问题，因为父类方法管不了子类覆盖方法的内容，子类对象单独调用method2或method3和父类调用method1的是同一个list，存在线程安全问题。</p>
<p>因此，得到的启发是，<strong>方法的访问修饰符是很有意义的，一定程度上能够保护线程安全，<code>private</code>修饰符限制了子类方法不能覆盖父类方法</strong>（一个类的private方法会隐式的被指定为final方法）。对于public修饰的公共方法如果不想让子类覆盖，加上<code>final</code>修饰符。</p>
<h3 id="常见的线程安全类"><a href="#常见的线程安全类" class="headerlink" title="常见的线程安全类"></a>常见的线程安全类</h3><p>String、Integer、StringBuﬀer、Random、Vector （List的线程安全实现类）、Hashtable （Hash的线程安全实现类）、java.util.concurrent 包下的类</p>
<p>这里说它们是线程安全的是指，多个线程调用它们<strong>同一个实例的某一个方法时</strong>，是线程安全的。因为它们的每个方法是原子的（都被加上了synchronized）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//不会有线程安全问题</span><br><span class="hljs-type">Hashtable</span> <span class="hljs-variable">table</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>	table.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>&#125;).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>	table.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>&#125;).start();<br></code></pre></td></tr></table></figure>

<p>但注意它们<strong>多个方法的组合不是原子的</strong>，所以可能会出现线程安全问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 可能有线程安全问题，线程1刚get完判断为null，随即线程2进入时间片，get判断为null，put了value2后，线程1得到时间片，其实已经不是null了，但它仍然会put value1</span><br><span class="hljs-type">Hashtable</span> <span class="hljs-variable">table</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>();<br><span class="hljs-keyword">if</span>( table.get(<span class="hljs-string">&quot;key&quot;</span>) == <span class="hljs-literal">null</span>) &#123;<br>	table.put(<span class="hljs-string">&quot;key&quot;</span>, value);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>String、Integer 等都是<strong>不可变类</strong>，因为其内部的状态不可以改变，因此它们的方法都是线程安全的。虽然他们有replace，substring 等方法可以”改变值“，那么这些方法又是如何保证线程安全的呢？这是因为这些方法的返回值都<strong>创建了一个新的对象</strong>，而不是直接改变String、Integer对象本身。</p>
<h3 id="线程死锁是如何产生的，如何避免"><a href="#线程死锁是如何产生的，如何避免" class="headerlink" title="线程死锁是如何产生的，如何避免"></a>线程死锁是如何产生的，如何避免</h3><p>死锁：由于两个或两个以上的线程相互竞争对方的资源，而同时不释放自己的资源，导致所有线程同时被阻塞。</p>
<p>死锁产生的条件：</p>
<ul>
<li>互斥条件：一个资源在同一时刻只由一个线程占用。</li>
<li>请求与保持条件：一个线程在请求被占资源时发生阻塞，并对已获得的资源保持不放。</li>
<li>循环等待条件：发生死锁时，所有的线程会形成一个死循环，一直阻塞。</li>
<li>不剥夺条件：线程已获得的资源在未使用完不能被其他线程剥夺，只能由自己使用完释放资源。</li>
</ul>
<p>避免死锁的方法主要是破坏死锁产生的条件。</p>
<ul>
<li><p>破坏互斥条件：这个条件无法进行破坏，锁的作用就是使他们互斥。</p>
</li>
<li><p>破坏请求与保持条件：一次性申请所有的资源。</p>
</li>
<li><p>破坏循环等待条件：按<strong>顺序</strong>来申请资源。不过也可能<strong>会导致饥饿</strong>问题</p>
</li>
<li><p>破坏不剥夺条件：线程一段时间申请不到所需资源时，主动放弃所持有的资源。</p>
<p>  ​</p>
</li>
</ul>
<h3 id="Java中的死锁、活锁、饥饿有什么区别？"><a href="#Java中的死锁、活锁、饥饿有什么区别？" class="headerlink" title="Java中的死锁、活锁、饥饿有什么区别？"></a>Java中的死锁、活锁、饥饿有什么区别？</h3><p>活锁：两个线程<strong>互相改变对方的结束条件</strong>，谁也无法结束。例如线程1一直–，减到0才退出，线程2一直++，加到20才退出，互相改变对方的结束条件，谁也无法结束</p>
<p>避免活锁：在线程执行时，中途给予<strong>不同的间隔时间</strong>即可</p>
<p>活锁和死锁的区别：活锁是在不断地尝试、死锁是在一直等待。活锁有可能自行解开、死锁无法自行解开。</p>
<p>饥饿：线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束。以打印机打印文件为例，当有多个线程需要打印文件，系统按照短文件优先的策略进行打印，但当短文件的打印任务一直不间断地出现，那长文件的打印任务会被一直推迟，导致饥饿。</p>
<p>产生饥饿的原因：高优先级的线程占用了低优先级线程的CPU时间，线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</p>
<p>死锁、饥饿的区别：饥饿可自行解开，死锁不行。</p>
<h3 id="Java内存的可见性问题"><a href="#Java内存的可见性问题" class="headerlink" title="Java内存的可见性问题"></a>Java内存的可见性问题</h3><p>Java内存模型规定，线程对共享变量的操作必须在自己的本地内存中进行，不能直接在主内存中操作共享变量。这会导致内存不可见的问题。如下图，一开始run是true，t1读到的也是true，但是t1是把他读到了自己线程的本地内存（高速缓存）里，这就导致主线程对run的修改对t1来说是不可见的</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%BB%E5%AD%98%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98.png" srcset="/img/loading.gif" lazyload alt="image-20220121221529370"></p>
<p>通过synchronized 关键字（重量级锁，性能低）和 volatile 关键字就可以解决（volatile 变量都是<strong>直接操作主存</strong>）。</p>
<h2 id="线程的创建、调度和状态"><a href="#线程的创建、调度和状态" class="headerlink" title="线程的创建、调度和状态"></a>线程的创建、调度和状态</h2><h3 id="创建线程一共有哪几种方法？"><a href="#创建线程一共有哪几种方法？" class="headerlink" title="创建线程一共有哪几种方法？"></a>创建线程一共有哪几种方法？</h3><p>继承 Thread 类创建线程</p>
<p>实现 Runnable 接口创建线程</p>
<p>使用Callable 和FutureTask 创建线程</p>
<p>使用线程池例如用Executor 框架</p>
<p>方法一：继承Thread 类创建线程，重写run方法，主函数里调用实例的start方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadDemo</span> <span class="hljs-variable">threadDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadDemo</span>();<br>        threadDemo.start();<br>        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-number">17</span>:<span class="hljs-number">52</span>:<span class="hljs-number">22.974</span> [main] <span class="hljs-symbol">DEBUG</span> <span class="hljs-symbol">Code01_CreateThread</span>.<span class="hljs-symbol">ThreadDemo</span> - running...<br><span class="hljs-number">17</span>:<span class="hljs-number">52</span>:<span class="hljs-number">22.974</span> [<span class="hljs-symbol">Thread</span><span class="hljs-number">-0</span>] <span class="hljs-symbol">DEBUG</span> <span class="hljs-symbol">Code01_CreateThread</span>.<span class="hljs-symbol">ThreadDemo</span> - running...<br></code></pre></td></tr></table></figure>

<p>或者用匿名内部类的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CreateThread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;Thread-0&quot;</span>) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>            &#125;<br>        &#125;;<br>        myThread.start();<br>        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此方法缺点：Java不支持多继承，如果继承了Thread类，那么就不能再继承其他类。任务与代码没有分离，当多个线程执行一样的任务时需要多份任务代码</p>
<p>方法二：实现Runnable 接口创建线程</p>
<p>Runnable接口写的是线程里实现的任务，需要重写run方法。Thread的构造方法第一个参数就是Runnable 类型的参数，传到最后就是调用Runnable 的run方法。第二个参数是线程名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>            log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable, <span class="hljs-string">&quot;Thread-0&quot;</span>);<br>    thread.start();<br>    log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">17:54:34.180 [main] <span class="hljs-built_in">DEBUG</span> Code01_CreateThread.RunnableTest - running<br>17:54:34.180 [Thread-0] <span class="hljs-built_in">DEBUG</span> Code01_CreateThread.RunnableDemo - running<span class="hljs-built_in">..</span>.<br></code></pre></td></tr></table></figure>

<p>使用lamda表达式简写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; log.debug(<span class="hljs-string">&quot;running...&quot;</span>); <span class="hljs-comment">//任务有多行语句也可以加上大括号</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br>    thread.start();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>进一步简写，将任务对象也用lambda 形式，写到线程的第一个参数里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; log.debug(<span class="hljs-string">&quot;running...&quot;</span>), <span class="hljs-string">&quot;Thread-0&quot;</span>);<br>    thread.start();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>方法二的优点：把线程和任务分开了，用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</p>
<p>方法三：使用Callable 和FutureTask 创建线程</p>
<ol>
<li>创建Callable接口的实现类CallableDemo ，重写call() 方法。</li>
<li>以类CallableDemo 的实例化对象作为参数创建FutureTask 对象。</li>
<li>以FutureTask 对象作为参数，创建Thread 对象。</li>
<li>调用Thread 对象的start() 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CreateThread3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-comment">// 创建任务对象</span><br>        FutureTask&lt;Integer&gt; futuretask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;);<br>        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br><br>        <span class="hljs-comment">// 创建线程对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futuretask, <span class="hljs-string">&quot;myThread&quot;</span>);<br>        thread.start();<br><br>        <span class="hljs-comment">// 主线程阻塞，同步等待 task 执行完毕的结果</span><br>        log.debug(<span class="hljs-string">&quot;阻塞了&#123;&#125;s&quot;</span>,futuretask.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">18:04:07.643 [main] <span class="hljs-built_in">DEBUG</span> Code01_CreateThread.CreateThread3 - running<span class="hljs-built_in">..</span>.<br>18:04:07.645 [myThread] <span class="hljs-built_in">DEBUG</span> Code01_CreateThread.CreateThread3 - running<span class="hljs-built_in">..</span>.<br>18:04:09.660 [main] <span class="hljs-built_in">DEBUG</span> Code01_CreateThread.CreateThread3 - 阻塞了2s<br></code></pre></td></tr></table></figure>

<p>方法三的优点：可以获得返回值</p>
<p>方法四：使用线程池例如用Executor 框架</p>
<p>使用线程池例如用Executor框架： Executors 可提供四种线程池，分别为：</p>
<ul>
<li><p>newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>
</li>
<li><p>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p>
</li>
<li><p>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p>
</li>
<li><p>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。</p>
</li>
</ul>
<h3 id="runnable-和-callable-有什么区别？"><a href="#runnable-和-callable-有什么区别？" class="headerlink" title="runnable 和 callable 有什么区别？"></a>runnable 和 callable 有什么区别？</h3><p>相同点：</p>
<ul>
<li>两者都是接口</li>
<li>两者都需要调用Thread.start 启动线程</li>
</ul>
<p>不同点：</p>
<ul>
<li>callable的核心是call() 方法，允许返回值， runnable 的核心是run() 方法，没有返回值</li>
<li>call() 方法可以抛出异常，但是run() 方法不行</li>
<li>callable 和runnable 都可以应用于executors ， thread 类只支持runnable</li>
</ul>
<h3 id="线程的run-和start-有什么区别？"><a href="#线程的run-和start-有什么区别？" class="headerlink" title="线程的run()和start()有什么区别？"></a>线程的run()和start()有什么区别？</h3><p>线程是通过Thread 对象所对应的方法run() 来<strong>完成</strong>其操作的，而线程的<strong>启动</strong>是通过start() 方法执行的。</p>
<p>run() 方法可以重复调用， start() 方法只能调用一次</p>
<h3 id="为什么调用start-方法时会执行run-方法，而不直接执行run-方法？"><a href="#为什么调用start-方法时会执行run-方法，而不直接执行run-方法？" class="headerlink" title="为什么调用start()方法时会执行run()方法，而不直接执行run()方法？"></a>为什么调用start()方法时会执行run()方法，而不直接执行run()方法？</h3><p>通过调用Thread类的 start() 方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run() 方法，这里方法run() 称为线程体，它包含了要执行的这个线程的内容， run() 方法运行结束，此线程随即终止。start() 方法启动线程才真正实现了多线程运行</p>
<p>run() 方法只是类的一个普通方法而已，如果直接调用 run 方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run() 方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。</p>
<p>调用start() 方法可以开启一个线程，而run() 方法只是thread类中的一个普通方法，直接调用run() 方法还是在主线程中执行的。</p>
<h3 id="线程的sleep-方法和yield-方法有什么不同？"><a href="#线程的sleep-方法和yield-方法有什么不同？" class="headerlink" title="线程的sleep()方法和yield()方法有什么不同？"></a>线程的sleep()方法和yield()方法有什么不同？</h3><p>sleep() 方法会使得当前线程暂停指定的毫秒数，让当前线程从 <strong>Running 进入 Timed Waiting （阻塞）状态</strong>。调用sleep方法会抛出异常InterruptedException。 处于阻塞状态的线程，CPU不会给其分配时间片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SleepTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;finish...&quot;</span>);<br>        &#125;);<br>        thread.start();<br>        log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">21:22:44.896 [Thread-0] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - running<span class="hljs-built_in">..</span>.<br>21:22:44.896 [main] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - running<span class="hljs-built_in">..</span>.<br>21:22:46.904 [Thread-0] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - finish<span class="hljs-built_in">..</span>.<br></code></pre></td></tr></table></figure>

<p>yield()方法 <strong>提示</strong>调度器当前线程愿意放弃当前的CPU资源，调度器如果接受这个提示会执行其他线程，当前线程从 <strong>Running 进入  Runnable（就绪）状态</strong>。但如果CPU太闲，也会不接受这个提示，依然执行当前线程。</p>
<p>所以sleep() 一定会完成给定的休眠时间， yield() 不一定能完成。</p>
<p>sleep() 需要抛出InterruptedException，而yield() 方法无需抛出异常。</p>
<h3 id="为什么Thread类的sleep-和yield-方法是静态的？"><a href="#为什么Thread类的sleep-和yield-方法是静态的？" class="headerlink" title="为什么Thread类的sleep()和yield()方法是静态的？"></a>为什么Thread类的sleep()和yield()方法是静态的？</h3><p>sleep() 和yield() 都是需要正在执行的线程调用的，那些本来就阻塞或者等待的线程调用这个方法是无意义的，所以这两个方法是静态的。其他Thread的静态方法同理</p>
<h3 id="sleep-方法和wait-方法的区别？"><a href="#sleep-方法和wait-方法的区别？" class="headerlink" title="sleep()方法和wait()方法的区别？"></a>sleep()方法和wait()方法的区别？</h3><p>相同点：</p>
<ul>
<li>wait() 方法和sleep() 方法都可以使得线程进入到阻塞状态。</li>
<li>wait() 和sleep() 方法都是可中断方法，被中断后都会收到中断异常。</li>
</ul>
<p>不同点：</p>
<ul>
<li>wait() 是Object的方法， sleep() 是Thread的方法。</li>
<li>wait() 必须在同步方法中进行（即加了锁的对象），sleep() 方法不需要。</li>
<li>线程在同步方法中执行sleep() 方法，不会释放monitor的锁，而wait() 方法会释放monitor的锁。</li>
<li>sleep() 方法在短暂的休眠之后会主动退出阻塞，而wait() 方法在没有指定wait时间的情况下需要被其他线程中断才可以退出阻塞。</li>
</ul>
<h3 id="为什么wait-、notify-、notifyAll-被定义在Object类中而不是在Thread类中？"><a href="#为什么wait-、notify-、notifyAll-被定义在Object类中而不是在Thread类中？" class="headerlink" title="为什么wait()、notify()、notifyAll()被定义在Object类中而不是在Thread类中？"></a>为什么wait()、notify()、notifyAll()被定义在Object类中而不是在Thread类中？</h3><p>因为这些方法在操作同步线程时，都必须要标识他们操作线程的锁，只有同一个锁上的被等待线程，可以被同一个锁上的notify() 或notifyAll() 唤醒，不可以对不同锁中的线程进行唤醒，也就是说等待和唤醒必须是同一锁。而锁可以是任意对象，所以可以被任意对象调用的方法是定义在Object 类中。</p>
<p>如果把wait() 、notify() 、notifyAll() 定义在Thread类中，则会出现一些难以解决的问题，例如如何让一个线程可以持有多把锁？如何确定线程等待的是哪把锁？既然是当前线程去等待某个对象的锁，则应通过操作对象来实现而不是操作线程，而Object类是所有对象的父类，所以将这三种方法定义在Object类中最合适。</p>
<h3 id="为什么wait-，notify-和notifyAll-必须在同步方法或者同步块中被调用？"><a href="#为什么wait-，notify-和notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="为什么wait()，notify()和notifyAll()必须在同步方法或者同步块中被调用？"></a>为什么wait()，notify()和notifyAll()必须在同步方法或者同步块中被调用？</h3><p>因为wait() 暂停的是持有锁的对象， notify() 或notifyAll() 唤醒的是等待锁的对象。所以wait() 、notify() 、notifyAll() 都需要线程持有锁的对象，进而需要在同步方法或者同步块中被调用。</p>
<h3 id="wait-方法一般在循环块中使用还是if块中使用？"><a href="#wait-方法一般在循环块中使用还是if块中使用？" class="headerlink" title="wait()方法一般在循环块中使用还是if块中使用？"></a>wait()方法一般在循环块中使用还是if块中使用？</h3><p>在JDK官方文档中明确要求了要在循环中使用，否则可能出现虚假唤醒的可能</p>
<h3 id="线程通信的方法有哪些？"><a href="#线程通信的方法有哪些？" class="headerlink" title="线程通信的方法有哪些？"></a>线程通信的方法有哪些？</h3><p>syncrhoized 加锁的线程的Object 类的 wait() &#x2F; notify() &#x2F; notifyAll()</p>
<p>ReentrantLock 类加锁的线程的Condition 类的await() &#x2F; signal() &#x2F; signalAll()</p>
<p>通过管道进行线程间通信：1）字节流；2）字符流 ，就是一个线程发送数据到输出管道，另一个线程从输入管道读数据。</p>
<h3 id="如何停止一个正在运行的线程？"><a href="#如何停止一个正在运行的线程？" class="headerlink" title="如何停止一个正在运行的线程？"></a>如何停止一个正在运行的线程？</h3><ul>
<li><p>interrupt() 用于打断线程，每个线程会有一个标志位<code>isInterrupted()</code>，用于记录打断的状态，默认是false</p>
<ul>
<li>如果是打断正处于sleep，wait，join 的线程（这几个方法都会让线程进入阻塞状态），会清空打断状态，打断状态为false</li>
<li>打断正常运行的线程，不会清空打断标记，打断标记为true，<strong>但打断的线程不会停止</strong>，会继续执行。如果要让线程在被打断后停下来，需要<strong>使用打断标记来判断，break掉循环</strong>，这是一种更优雅的处理方式。<font color=red>模式之两阶段终止</font></li>
</ul>
</li>
<li><p>使用volatile boolean 标志位停止线程：在线程中设置一个 boolean 标志位，同时用volatile修饰保证可见性，在线程里不断地读取这个值，其他地方可以修改这个boolean 值。</p>
</li>
</ul>
<h3 id="如何唤醒一个阻塞的线程？"><a href="#如何唤醒一个阻塞的线程？" class="headerlink" title="如何唤醒一个阻塞的线程？"></a>如何唤醒一个阻塞的线程？</h3><p>如果线程是由于wait() 、sleep() 、join() 、yield() 等方法进入阻塞状态的，是可以进行唤醒的。如果线程是IO阻塞是无法进行唤醒的，因为IO是操作系统层面的，Java代码无法直接接触操作系统。</p>
<ul>
<li><p>join()：与sleep() 方法一样，是一个可中断的方法，在一个线程中调用另一个线程的join()方法，会使得当前的线程挂起，直到执行join() 方法的线程结束。例如在B线程中调用A线程的join() 方法，B线程进入阻塞状态，直到A线程结束或者到达指定的时间（ join(）的参数）</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(...);<br>thread.join();   <span class="hljs-comment">//主线程里调用该方法，即等待thread线程执行结束才执行主线程</span><br><br>thread.join(<span class="hljs-number">1000</span>);<span class="hljs-comment">//最多等待1000ms，就会继续执行主线程，thread没执行完也不管</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>wait() ：可用notify() 或notifyAll() 方法唤醒。</p>
</li>
<li><p>sleep() ：调用该方法使得线程在指定时间内进入阻塞状态，等到指定时间过去，线程再次获取到CPU时间片进而被唤醒。</p>
</li>
<li><p>yield() ：使得当前线程放弃CPU时间片，但随时可能再次得到CPU时间片进而激活。</p>
</li>
<li><p>LockSupport.park()&#x2F;LockSupport.unpark(Thread t1)：暂停和恢复线程的运行</p>
</li>
</ul>
<h3 id="Java中守护线程和用户线程的区别？"><a href="#Java中守护线程和用户线程的区别？" class="headerlink" title="Java中守护线程和用户线程的区别？"></a>Java中守护线程和用户线程的区别？</h3><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守<br>护线程运行结束了，即使守护线程的代码没有执行完，Java 进程（Java虚拟机）也会强制结束。</p>
<p>用户线程：平时使用到的线程均为用户线程。</p>
<p>守护线程：用来服务用户线程的线程，例如垃圾回收线程。</p>
<p>任何线程都可以设置为守护线程和用户线程，通过方法<code>Thread.setDaemon(boolon)</code> 设置， true 则是将该线程设置为守护线程， false 则是将该线程设置为用户线程（默认为false）。同时， <code>Thread.setDaemon()</code> 必须在<code>Thread.start()</code> 之前调用，否则运行时会抛出异常。</p>
<h3 id="其他线程调度相关方法"><a href="#其他线程调度相关方法" class="headerlink" title="其他线程调度相关方法"></a>其他线程调度相关方法</h3><ul>
<li><p>setPriority()：线程优先级设置方法会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它。如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p>
  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">thread1.setPriority(Thread.MAX_PRIORITY); <span class="hljs-regexp">//</span>设置为优先级最高<br></code></pre></td></tr></table></figure>
</li>
<li><p>还有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁</p>
<ul>
<li>stop() –  停止线程运行</li>
<li>suspend() –  挂起（暂停）线程运行</li>
<li>resume() –  恢复线程运行</li>
</ul>
</li>
</ul>
<h3 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h3><table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NEW</td>
<td>初始状态，注意此时还未调用start() 方法</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>调用了 start() 方法之后进入运行状态，包含就绪和运行中两种状态</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞状态</td>
</tr>
<tr>
<td>WAITING</td>
<td>等待状态</td>
</tr>
<tr>
<td>TIME_WAITING</td>
<td>超时等待状态，和等待状态不同的是，它可以在制定的时间自行返回</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态，线程运行结束</td>
</tr>
</tbody></table>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java/JUC/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" srcset="/img/loading.gif" lazyload alt="image-20220517223851983"></p>
<h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><h3 id="什么是synchronized关键字？"><a href="#什么是synchronized关键字？" class="headerlink" title="什么是synchronized关键字？"></a>什么是synchronized关键字？</h3><p>synchronized 实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切<br>换所打断。保证线程同步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>			...<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="同步方法和同步方法块哪个效果更好？"><a href="#同步方法和同步方法块哪个效果更好？" class="headerlink" title="同步方法和同步方法块哪个效果更好？"></a>同步方法和同步方法块哪个效果更好？</h3><p>同步块更好些，因为它锁定的范围更灵活些，只在需要锁住的代码块锁住相应的对象，而同步方法会锁住整个对象。</p>
<h3 id="synchronized关键字的使用方式"><a href="#synchronized关键字的使用方式" class="headerlink" title="synchronized关键字的使用方式"></a>synchronized关键字的使用方式</h3><p>synchronized主要有三种使用方式：修饰普通同步方法、修饰静态同步方法、修饰同步方法块。底层原理都是给一个对象上锁</p>
<p>（1）修饰普通同步方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>	<span class="hljs-comment">//在方法上加上synchronized关键字</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>	<br>	&#125;<br>	<span class="hljs-comment">//等价于给对象加锁</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>		<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 例子</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">newRoom</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span>&#123;<br>        value++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> &#123;<br>        value--;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Room</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Room</span>();  <span class="hljs-comment">// 必须是给同一个对象枷锁</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>            room.increment();<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5000</span>; j++) &#123;<br>            room.decrement();<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>    t1.start();<br>    t2.start();<br>    t1.join();<br>    t2.join();<br>    log.debug(<span class="hljs-string">&quot;counter:&#123;&#125;&quot;</span>,room.get());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用synchronized修饰普通同步方法必须是调用同一个实例化对象</p>
<p>如果是给两个对象加锁，就不能保证线程安全，那这种情况应该如何解决呢？因为每次创建的实例对象都是不同的，而类对象却只有一个，如果synchronized关键字作用于类对象，即用synchronized修饰静态方法</p>
<p>（2）修饰静态同步方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>	<span class="hljs-comment">//在静态方法上加上synchronized关键字</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>	<br>	&#125;<br>	<span class="hljs-comment">//等价于给类对象加锁</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">synchronized</span>(Demo.class) &#123;<br>		<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 例子</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Room2</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span>&#123;<br>        value++;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> &#123;<br>        value--;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Room2</span> <span class="hljs-variable">room1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Room2</span>();<br>        <span class="hljs-type">Room2</span> <span class="hljs-variable">room2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Room2</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                room1.increment();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                room2.decrement();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        log.debug(<span class="hljs-string">&quot;counter:&#123;&#125;&quot;</span>,Room2.get());<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>（3）修饰同步代码块</p>
<p>如果某些情况下，整个方法体比较大，需要同步的代码只是一小部分，如果直接对整个方法体进行同步，会使得代码性能变差，这时只需要对一小部分代码进行同步即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 上面还有其他操作。。。</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            value++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 上面还有其他操作。。。</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            value--;<br>        &#125;<br>    &#125;<br>	...<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="synchronized关键字三大特性是什么？"><a href="#synchronized关键字三大特性是什么？" class="headerlink" title="synchronized关键字三大特性是什么？"></a>synchronized关键字三大特性是什么？</h3><p>原子性：一个或多个操作要么全部执行成功，要么全部执行失败。synchronized关键字可以保证只有一个线程拿到锁，访问共享资源。</p>
<p>可见性：当一个线程对共享变量进行修改后，其他线程可以立刻看到。执行synchronized时，会对应执行 lock 、unlock原子操作，保证可见性。</p>
<p>有序性：程序的执行顺序会按照代码的先后顺序执行。</p>
<h3 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h3><p>（1）对象头</p>
<p>在HotSpot虚拟机中，Java对象在内存中的布局大致可以分为三部分：对象头、实例数据和填充对齐。因为synchronized用的锁是存在对象头里的，这里我们需要重点了解对象头。如果对象头是数组类型，则对象头由Mark Word、Class MetadataAddress和Array length组成，如果对象头非数组类型，对象头则由Mark Word和Class MetadataAddress组成。在32位虚拟机中，数组类型的Java对象头的组成如下表：</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
<th>长度</th>
</tr>
</thead>
<tbody><tr>
<td>Mark Word</td>
<td>存储对象的hashCode、分代年龄和锁标记位</td>
<td>32bit</td>
</tr>
<tr>
<td>Class MetadataAddress</td>
<td>存储到对象类型数据的指针</td>
<td>32bit</td>
</tr>
<tr>
<td>Array length</td>
<td>数组的长度</td>
<td>32bit</td>
</tr>
</tbody></table>
<p>这里我们需要重点掌握的是Mark Word，在运行期间，Mark Word中存储的数据会随着锁标志位的变化而变化，在32位虚拟机中，不同锁状态下的组成如下：</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java/JUC/%E4%B8%8D%E5%90%8C%E9%94%81%E7%8A%B6%E6%80%81%E7%9A%84MarkWord.png" srcset="/img/loading.gif" lazyload alt="image-20220518154904184"></p>
<p>锁的状态由Java对象头的Mark Word最后两位决定，有无锁、偏向锁、轻量级锁、重量级锁等</p>
<p>（2）重量级锁 Monitor</p>
<p>Monitor，又被称为锁&#x2F;管程，这里实际上指的是重量级锁（Monitor是由操作系统提供的），每个 Java 对象都可以关联一个 Monitor 。Monitor里有三个结构：Owner、EntryList、WaitSet</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81%E5%8E%9F%E7%90%86.png" srcset="/img/loading.gif" lazyload alt="image-20220116202736471"></p>
<p>一个对象obj创建时候是无锁的，对象头的mark word里存储着hashcode、分代年龄等信息。</p>
<p>刚开始 Monitor 中 Owner 为 null，当 Thread-2 执行 synchronized(obj) ，会先查询synchronized中所指定的对象(obj)<strong>是否绑定了Monitor</strong>。如果<strong>没有绑定</strong>，则会先去与Monitor绑定（将对象头中的<strong>Mark Word</strong>置为Monitor指针），并且将Owner设为当前线程（Thread-2），Owner里只能有一个线程。在 Thread-2 上锁的过程中，如果 Thread-1，Thread-3 也来执行 synchronized(obj)，就会放入EntryList，进入阻塞状态(blocked)。当Monitor的Owner将临界区中代码执行完毕后，Owner便会被清空，此时EntryList中处于<strong>阻塞</strong>状态的线程会被<strong>叫醒并竞争</strong>，此时的竞争是<strong>非公平的</strong>（既不是先到先得）</p>
<p>每个对象都会绑定一个<strong>唯一的Monitor</strong>，如果synchronized中所指定的对象(obj)<strong>不同</strong>，则会绑定<strong>不同</strong>的Monitor。</p>
<p>（3）锁自旋</p>
<p><strong>重量级锁竞争</strong>的时候，还可以使用自旋来进行优化，即先不加入Monitor的阻塞队列EntryList中，自己循环几次看看，能不能等到owner释放锁。</p>
<p>如果当前线程2自旋成功（即在自旋的时候持锁的线程1释放了锁），那么当前线程2就可以不用进行上下文切换（持锁线程1执行完synchronized同步块后，释放锁，Owner为空，唤醒阻塞队列来竞争，胜出的线程得到cpu执行权的过程）就获得了锁</p>
<p>自旋重试失败的情况，自旋了一定次数还是没有等到持锁的线程1释放锁，线程2就会加入Monitor的阻塞队列(EntryList)</p>
<p>优化的点：<strong>不用将线程加入到阻塞队列，减少cpu切换</strong>，注意<strong>不是优化轻量级锁，而是优化重量级锁</strong>。自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</p>
<p>（4）轻量级锁</p>
<p><strong>轻量级锁使用场景：</strong>当一个对象被<strong>多个线程</strong>所访问，但访问的时间是<strong>错开的（不存在竞争）</strong>，此时就可以使用<strong>轻量级锁</strong>来优化。如果有竞争，还是升级为重量级锁。轻量级锁对使用者是透明的，语法仍然是 Synchronized。</p>
<p>轻量级锁加锁步骤：</p>
<ul>
<li>每个线程的每个栈帧都会包含一个锁记录（Lock Record）对象（这是JVM层面的，不是Java对象），内部可以存储加锁对象的mark word（不再一开始就使用Monitor）</li>
<li>让锁记录中的Object reference指向锁对象（Object），并尝试用cas去替换Object中的mark word，将此mark word放入lock record中保存</li>
<li>如果cas替换成功，则将Object的对象头替换为<strong>锁记录的地址</strong>和<strong>状态 00（轻量级锁状态）</strong>，并由该线程给对象加锁</li>
<li>如果cas替换失败，有两种情况 :<ul>
<li>如果是其它线程已经持有了该Object的轻量级锁（对象头中已经存储了别的线程的锁记录地址 00），那么表示有竞争，将进入<strong>锁膨胀</strong>阶段。（比如Thread-1想加轻量级锁失败，因为Thread-0持有该对象的轻量级锁，这时进入锁膨胀，会为对象申请Monitor锁（重量级锁），让Object指向重量级锁地址 10，然后Thread-1自己进入Monitor 的EntryList 变成BLOCKED状态）</li>
<li>如果是自己的线程前面已经对这个对象加了轻量级锁（同一个线程调用不同的方法，但都是对这个对象加锁），则发生<strong>锁重入</strong>，会再添加一条 Lock Record 作为重入锁的计数。线程中有多少个锁记录，就能表明该线程对这个对象加了几次锁（锁重入计数）</li>
</ul>
</li>
</ul>
<p>（5）偏向锁</p>
<p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然执行CAS替换操作，这样是会使性能降低的。</p>
<p>Java6 引入了<strong>偏向锁</strong>对性能进行优化：在<strong>第一次</strong>cas时会将<strong>线程的ID</strong>写入对象的Mark Word中。此后发现这个线程ID就是自己的，就表示没有竞争，就不需要再次cas，以后只要不发生竞争，这个对象就归该线程所有。即<strong>偏向锁用于优化轻量级锁重入</strong></p>
<p>当有其他线程也使用偏向锁对象时，便会将偏向锁升级为轻量级锁（前提是两个线程没有锁竞争，即一个线程执行完了，另一个线程还没执行，否则就升级为重量级锁）</p>
<h3 id="synchroized关键字的底层原理"><a href="#synchroized关键字的底层原理" class="headerlink" title="synchroized关键字的底层原理"></a>synchroized关键字的底层原理</h3><p>Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，代码块同步使用的是monitorenter 和 monitorexit 指令实现的，而方法同步是通过Access flags后面的标识来确定该方法是否为同步方法。</p>
<h3 id="Jdk1-6为什么要对-synchronized-进行优化？"><a href="#Jdk1-6为什么要对-synchronized-进行优化？" class="headerlink" title="Jdk1.6为什么要对 synchronized 进行优化？"></a>Jdk1.6为什么要对 synchronized 进行优化？</h3><p>因为Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，而Monitor是依靠底层操作系统的Mutex Lock来实现的，操作系统实现线程之间的切换需要从用户态转换到内核态，这个切换成本比较高，对性能影响较大</p>
<h3 id="jDK1-6对-synchronized-做了哪些优化？"><a href="#jDK1-6对-synchronized-做了哪些优化？" class="headerlink" title="jDK1.6对 synchronized 做了哪些优化？"></a>jDK1.6对 synchronized 做了哪些优化？</h3><p>在JDK1.6中，为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁，锁的状态变成了四种，无锁状态，偏向锁状态、轻量级锁状态和重量级锁状态。锁的状态会随着竞争激烈逐渐升级，但通常情况下，锁的状态只能升级不能降级</p>
<p>synchronized锁原来只有重量级锁(Monitor)，但这玩意儿是操作系统层的，比较浪费性能。因此从Jdk1.6开始使用偏向锁和轻量级锁优化性能，在不同场景使用不同的锁。锁只有升级，没有降级</p>
<ul>
<li>只有一个线程进入临界区 –&gt; 偏向锁（对象头的Mark Word记录线程ID进行比对）</li>
<li>多个线程交替（没有竞争）进入临界区 –&gt; 轻量级锁（用CAS将对象头原本的Mark Word拷贝到线程栈帧的Lock Record中，在对象头放锁记录的地址和锁状态）</li>
<li>多个线程同时（有竞争）进入临界区 –&gt; 重量级锁（每个对象绑定唯一的Monitor，其他线程竞争时会有<strong>锁自旋优化</strong>，自旋失败则进入Monitor中的Entrylist放置等待）</li>
</ul>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><h3 id="volatile的作用是什么？"><a href="#volatile的作用是什么？" class="headerlink" title="volatile的作用是什么？"></a>volatile的作用是什么？</h3><p>volatile 是一个轻量级的synchronized ，一般作用于变量，在多处理器开发的过程中保证了内存的可见性。相比于synchronized 关键字， volatile 关键字的执行成本更低，效率更高。</p>
<h3 id="volatile的特性有哪些？"><a href="#volatile的特性有哪些？" class="headerlink" title="volatile的特性有哪些？"></a>volatile的特性有哪些？</h3><p>并发编程的三大特性为可见性、有序性和原子性。volatile 只可以保证可见性和有序性。</p>
<p>可见性： volatile 可以保证不同线程对共享变量进行操作时的可见性。即当一个线程修改了共享变量时，另一个线程可以读取到共享变量被修改后的值。</p>
<p>有序性： volatile 会通过禁止指令重排序进而保证有序性。</p>
<p>原子性：对于单个的volatile 修饰的变量的读写是可以保证原子性的，但对于i++ 这种复合操作并不能保证原子性。这句话的意思基本上就是说volatile 不具备原子性了。</p>
<h3 id="为什么代码会重排序？会引发什么问题？"><a href="#为什么代码会重排序？会引发什么问题？" class="headerlink" title="为什么代码会重排序？会引发什么问题？"></a>为什么代码会重排序？会引发什么问题？</h3><p>指令重排在单线程下可以提高代码的性能，但在多线程下重排序会破坏多线程程序的语义。</p>
<h3 id="as-if-serial规则和happens-before规则的区别？"><a href="#as-if-serial规则和happens-before规则的区别？" class="headerlink" title="as-if-serial规则和happens-before规则的区别？"></a>as-if-serial规则和happens-before规则的区别？</h3><p>区别：</p>
<ul>
<li>as-if-serial定义：无论编译器和处理器如何进行重排序，单线程程序的执行结果不会改变。</li>
<li>happens-before定义：一个操作happens-before另一个操作，表示第一个的操作结果对第二个操作可见，并且第一个操作的执行顺序也在第二个操作之前。但这并不意味着Java虚拟机必须按照这个顺序来执行程序。如果重排序的后的执行结果与按happens-before关系执行的结果一致，Java虚拟机也会允许重排序的发生。</li>
<li>happens-before关系保证了同步的多线程程序的执行结果不被改变，as-if-serial保证了单线程内程序的执行结果不被改变。</li>
</ul>
<p>相同点：happens-before和as-if-serial的作用都是在不改变程序执行结果的前提下，提高程序执行的并行度。</p>
<h3 id="voliatile的实现原理？"><a href="#voliatile的实现原理？" class="headerlink" title="voliatile的实现原理？"></a>voliatile的实现原理？</h3><p>volatile 具备可见性和有序性两大特性，所以volatile 的实现原理也是围绕如何实现可见性和有序性展开的。</p>
<ul>
<li><p>volatile实现内存可见性原理：</p>
<p>  导致内存不可见的主要原因就是Java内存模型中的本地内存和主内存之间的值不一致，volatile 的读&#x2F;写实现了缓存一致性：处理器读数据时，一旦发现自己缓存对应的内存地址被修改，就会将当前处理器的缓存设为无效状态。此时，如果处理器需要获取这个数据需重新从主内存将其读取到本地内存。当处理器写数据时，如果发现操作的是共享变量，会通知其他处理器将该变量的缓存设为无效状态。</p>
</li>
<li><p>volatile实现有序性原理：</p>
<p>  编译器在生成字节码时会通过插入内存屏障来禁止指令重排序，它是一种CPU指令，它的作用是对该指令前和指令后的一些操作产生一定的约束，保证一些操作按顺序执行</p>
</li>
</ul>
<p>但是volatile不能解决指令交错问题 (不能解决原子性)，可以使用<code>synchronized</code>来解决原子性</p>
<h3 id="volatile、synchronized的区别？"><a href="#volatile、synchronized的区别？" class="headerlink" title="volatile、synchronized的区别？"></a>volatile、synchronized的区别？</h3><ul>
<li><p>volatile 主要是保证内存的可见性，即变量在寄存器中的内存是不确定的，需要从主存中读取。以及通过内存屏障保证有序性，但不能保证数据的原子性</p>
</li>
<li><p>synchronized 主要是解决多个线程访问资源的同步性。synchronized 可以保证可见性、有序性、原子性。</p>
</li>
<li><p>volatile 作用于变量， synchronized 作用于代码块或者方法。</p>
</li>
<li><p>volatile 不会造成线程的阻塞， synchronized 会造成线程的阻塞。</p>
</li>
</ul>
<h2 id="CAS-与-Atomic-原子类"><a href="#CAS-与-Atomic-原子类" class="headerlink" title="CAS 与 Atomic 原子类"></a>CAS 与 Atomic 原子类</h2><h3 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS?"></a>什么是CAS?</h3><p>CAS即CompareAndSwap，翻译成中文即比较并替换。Java中可以通过CAS操作来保证原子性，原子性就是不可被中断的一些列操作或者一个操作，简单来说就是一系列操作，要么全部完成，要么失败，不能被中断。</p>
<p>CAS主要包含三个参数（V，A，E）, V 表示要更新的变量（内存值）、E 表示预期值（旧值）、N 表示新值。算法流程是首先比较A和E的值，如果相等，将N值赋值给A，如果不相等说明有其他线程对该变量做了更新。这个参数有的地方也会用（V，A，B）表示，其中A表示预期值，B表示新值。</p>
<p>当多个线程同时操作一个共享变量时，只有一个线程可以对变量进行成功更新，其他线程均会失败，但是失败并不会被挂起，进行再次尝试，也就是自旋。Java中的自旋锁就是利用CAS来实现的。</p>
<p>获取共享变量时，为了<strong>保证该变量的可见性</strong>，需要使用 volatile 修饰。<strong>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</strong></p>
<h3 id="CAS存在的问题"><a href="#CAS存在的问题" class="headerlink" title="CAS存在的问题"></a>CAS存在的问题</h3><ul>
<li><p>ABA问题</p>
<p>  在CAS的算法流程中，首先要先比较V的值和E的值，如果相等则进行更新。ABA问题是指，E表示的这个旧值本来是A，然后变成了B，后来又变成了A，但这时有线程来更新，发现E表示的值是A，则直接进行更新了，这样肯定是不对的，但又该怎么解决呢？</p>
<p>  ABA的问题的解决方式：ABA的解决方法也很简单，就是利用版本号。给变量加上一个版本号，每次变量更新的时候就把版本号加1，这样即使E的值从A—&gt;B—&gt;A，版本号也发生了变化，这样就解决了CAS出现的ABA问题。基于CAS的乐观锁也是这个实现原理。</p>
</li>
<li><p>循环时间过长导致开销太大</p>
<p>  CAS自旋时间过长会给CPU带来非常大的开销</p>
</li>
<li><p>只能保证一个共享变量的原子操作</p>
<p>  在操作一个共享变量时，可以通过CAS的方式保证操作的原子性，但如果对多个共享变量进行操作时，CAS则无法保证操作的原子性，这时候就需要用锁了。</p>
</li>
</ul>
<h3 id="CAS的特点"><a href="#CAS的特点" class="headerlink" title="CAS的特点"></a>CAS的特点</h3><ul>
<li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。<strong>只是基于乐观锁的思想，其实是没有加锁的。</strong></li>
<li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li>
<li>CAS 体现的是<strong>无锁并发、无阻塞并发</strong><ul>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li>
<li>但如果竞争激烈(写操作多)，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
</li>
</ul>
<p>在并发量不是很大时比有锁要提高效率：</p>
<ul>
<li>使用CAS+重试即无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized会让线程在没有获得锁的时候，发生上下文切换，进入阻塞，这部分时间损耗的较多。</li>
<li>无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，因此CAS适合线程数少于CPU核心数的情况，否则没有额外CPU支持，CAS并不能发挥作用（像上面例子中创建1000个线程其实并不能体现CAS的高效）</li>
</ul>
<h3 id="Atomic-原子类"><a href="#Atomic-原子类" class="headerlink" title="Atomic 原子类"></a>Atomic 原子类</h3><p>JUC包中的4种原子类：</p>
<ul>
<li>基本类型：使用原子的方式更新基本类型</li>
<li>数组类型：使用原子的方式更新数组里的某个元素</li>
<li>引用类型：<ul>
<li>AtomicReference ：引用类型原子类，存在ABA问题</li>
<li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的ABA问题。</li>
</ul>
</li>
<li>原子更新字段类</li>
</ul>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="什么是ThreadLocal？有哪些应用场景？"><a href="#什么是ThreadLocal？有哪些应用场景？" class="headerlink" title="什么是ThreadLocal？有哪些应用场景？"></a>什么是ThreadLocal？有哪些应用场景？</h3><p>ThreadLocal 是 JDK java.lang 包下的一个类， ThreadLocal 为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量，并且不会和其他线程的局部变量冲突，实现了线程间的数据隔离。同时实现了线程内的资源共享</p>
<p>ThreadLocal 的应用场景主要有以下几个方面：</p>
<ul>
<li>保存线程上下文信息，在需要的地方可以获取</li>
<li>线程间数据隔离</li>
<li>数据库连接</li>
</ul>
<h3 id="ThreadLocal原理？"><a href="#ThreadLocal原理？" class="headerlink" title="ThreadLocal原理？"></a>ThreadLocal原理？</h3><p>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象，  ThreadLocalMap 中保存着所有的 ThreadLocal ，而ThreadLocal 本身只是一个引用本身并不保存值，值都是保存在ThreadLocalMap中的，其中ThreadLocal 为ThreadLocalMap 中的key 。</p>
<p>ThreadLocalMap 的一些特点</p>
<ul>
<li>key 的 hash 值统一分配</li>
<li>初始容量 16，扩容因子 2&#x2F;3，扩容容量翻倍</li>
<li>key 索引冲突后用开放寻址法解决冲突</li>
</ul>
<p>对于ThreadLocal对象，有几个重要的方法：</p>
<ul>
<li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</li>
<li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</li>
<li>调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li>
</ul>
<p><strong>内存释放时机</strong></p>
<ul>
<li>被动 GC 释放 key<ul>
<li>仅是让 key 的内存释放，关联 value 的内存并不会释放</li>
</ul>
</li>
<li>懒惰被动释放 value<ul>
<li>get key 时，发现是 null key，则释放其 value 内存</li>
<li>set key 时，会使用启发式扫描，清除临近的 null key 的 value 内存，启发次数与元素个数，是否发现 null key 有关</li>
</ul>
</li>
<li>主动 remove 释放 key，value<ul>
<li>会同时释放 key，value 的内存，也会清除临近的 null key 的 value 内存</li>
<li>推荐使用它，因为一般使用 ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收</li>
</ul>
</li>
</ul>
<h3 id="为什么ThreadLocal会发生内存泄漏呢？"><a href="#为什么ThreadLocal会发生内存泄漏呢？" class="headerlink" title="为什么ThreadLocal会发生内存泄漏呢？"></a>为什么ThreadLocal会发生内存泄漏呢？</h3><p>因为ThreadLocal 中的key 是弱引用，而value 是强引用。当ThreadLocal 没有被强引用时，在进行垃圾回收时， key 会被清理掉，而value 不会被清理掉，这时如果不做任何处理， value 将永远不会被回收，产生内存泄漏。</p>
<h3 id="如何解决ThreadLocal的内存泄漏？"><a href="#如何解决ThreadLocal的内存泄漏？" class="headerlink" title="如何解决ThreadLocal的内存泄漏？"></a>如何解决ThreadLocal的内存泄漏？</h3><p>ThreadLocal 在设计的时候已经考虑到了这种情况，在调用set() 、get() 、remove() 等方法时就会清理掉key 为null 的记录，所以在使用完ThreadLocal 后最好手动调用remove() 方法。</p>
<h3 id="为什么要将key设计成ThreadLocal的弱引用？"><a href="#为什么要将key设计成ThreadLocal的弱引用？" class="headerlink" title="为什么要将key设计成ThreadLocal的弱引用？"></a>为什么要将key设计成ThreadLocal的弱引用？</h3><p>Thread 可能需要长时间运行（如线程池中的线程），如果 key 不再使用，需要在内存不足（GC）时释放其占用的内存</p>
<p>如果ThreadLocal 的key 是强引用，同样会发生内存泄漏的。如果ThreadLocal 的key 是强引用，引用的ThreadLocal 的对象被回收了，但是ThreadLocalMap 还持有ThreadLocal 的强引用，如果没有手动删除， ThreadLocal 不会被回收，发生内存泄漏。</p>
<p>如果是弱引用的话，引用的ThreadLocal 的对象被回收了，即使没有手动删除， ThreadLocal 也会被回收。value 也会在ThreadLocalMap 调用 set() 、get() 、remove() 的时候会被清除。所以两种方案比较下来，还是ThreadLoacl 的key 为弱引用好一些。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="什么是线程池？为什么使用线程池？"><a href="#什么是线程池？为什么使用线程池？" class="headerlink" title="什么是线程池？为什么使用线程池？"></a>什么是线程池？为什么使用线程池？</h3><p>线程池是一种多线程处理形式，处理过程中将任务提交到线程池，任务的执行交给线程池来管理。</p>
<p>为什么使用线程池？</p>
<ul>
<li>降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度，当任务到达时，任务可以不需要等到线程创建就立即执行。</li>
<li>提高线程的可管理性，线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以统一分配。</li>
</ul>
<h3 id="创建线程池的几种方法"><a href="#创建线程池的几种方法" class="headerlink" title="创建线程池的几种方法"></a>创建线程池的几种方法</h3><p>线程池的常用创建方式主要有两种，通过new ThreadPoolExecutor方法创建和通过Executors工厂方法创建。</p>
<ul>
<li><p>new ThreadPoolExecutor 方法创建</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure></li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>核心线程数，定义了最小可以同时运行的线程数量</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>最大线程数，线程池里的线程分为两种：核心线程和救急线程，maximumPoolSize - corePoolSize &#x3D; 救急线程数</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>救急线程空闲时的最大生存时间。超过时间会销毁救急线程</td>
</tr>
<tr>
<td>unit</td>
<td>救急线程的时间单位</td>
</tr>
<tr>
<td>workQueue</td>
<td>存放任务的阻塞队列。新来的任务会先判断当前运行的线程数是否到达核心线程数，如果到达的话，任务就会先放到阻塞队列。</td>
</tr>
<tr>
<td>threadFactory</td>
<td>线程工厂：可以给线程取个好名字，取名时要取清晰，区别于非线程池方法创建的线程</td>
</tr>
<tr>
<td>handler</td>
<td>拒绝策略，阻塞队列满了，线程池使用什么样的拒绝策略拒绝新任务</td>
</tr>
</tbody></table>
<ul>
<li><p>Executors工厂方法创建，在工具类 Executors 提供了一些静态的工厂方法（底层其实还是调用ThreadPoolExecutor 方法创建，只不过封装了一些固定参数）</p>
<ul>
<li><p>newSingleThreadExecutor ：创建一个单线程的线程池。</p>
</li>
<li><p>newFixedThreadPool ：创建固定大小的线程池。</p>
</li>
<li><p>newCachedThreadPool ：创建一个可缓存的线程池。</p>
</li>
<li><p>newScheduledThreadPool ：创建一个大小无限的线程池。</p>
</li>
</ul>
</li>
</ul>
<h3 id="线程池的执行流程"><a href="#线程池的执行流程" class="headerlink" title="线程池的执行流程"></a>线程池的执行流程</h3><p>当一个任务传给线程池以后，</p>
<ul>
<li>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新的核心线程来执行任务。</li>
<li>当线程数达到 <code>corePoolSize</code> 并且没有线程空闲，这时再加入任务，新加的任务会被加入<code>workQueue</code> 队列排队，直到有空闲的线程。</li>
<li>如果阻塞队列选择了有界阻塞队列并且阻塞队列满了，使用非核心线程（救急线程）来执行任务。救急线程用完以后，超过生存时间（keepAliveTime）后会被释放。<strong>如果不是有界队列，则不会创建救急线程，都是核心线程</strong></li>
<li>任务总数大于了 最大线程数<code>maximumPoolSize</code>与阻塞队列容量的最大值<code>workQueue.capacity</code>，使用拒接策略</li>
</ul>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F.png" srcset="/img/loading.gif" lazyload alt="image-20220126222039262"></p>
<h3 id="ThreadPoolExecutor的饱和策略（拒绝策略）"><a href="#ThreadPoolExecutor的饱和策略（拒绝策略）" class="headerlink" title="ThreadPoolExecutor的饱和策略（拒绝策略）"></a>ThreadPoolExecutor的饱和策略（拒绝策略）</h3><p>当同时运行的线程数量达到最大线程数量并且阻塞队列也已经放满了任务时， ThreadPoolExecutor 会指定一些饱和策略。主要有以下四种类型：</p>
<ul>
<li>AbortPolicy 策略：该策略会直接抛出异常拒绝新任务</li>
<li>CallerRunsPolicy 策略：当线程池无法处理当前任务时，会将该任务交由提交任务的线程来执行。</li>
<li>DiscardPolicy 策略：直接丢弃新任务。</li>
<li>DiscardOleddestPolicy 策略：丢弃最早的未处理的任务请求。</li>
</ul>
<h3 id="execute-方法和submit-方法的区别"><a href="#execute-方法和submit-方法的区别" class="headerlink" title="execute()方法和submit()方法的区别"></a>execute()方法和submit()方法的区别</h3><p>execute() 和submit() 的区别主要有两点：</p>
<p>execute() 方法只能执行Runnable 类型的任务。submit() 方法可以执行Runnable 和Callable 类型的任务。</p>
<p>submit() 方法可以返回持有计算结果的Future 对象，同时还可以抛出异常，而execute() 方法不可以。</p>
<p>换句话说就是， execute() 方法用于提交不需要返回值的任务， submit() 方法用于需要提交返回值的任务。</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS的全称是 AbstractQueuedSynchronizer ，是一个用来构建锁和同步器的框架，像ReentrantLock，Semaphore，FutureTask都是基于AQS实现的。</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><p>多线程中编程题经常考察</p>
<h3 id="用Java实现死锁，并给出避免死锁的解决方案"><a href="#用Java实现死锁，并给出避免死锁的解决方案" class="headerlink" title="用Java实现死锁，并给出避免死锁的解决方案"></a>用Java实现死锁，并给出避免死锁的解决方案</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j(topic = &quot;info&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLockTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span> (A)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;t1尝试获得锁B&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (B)&#123;<br><br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span> (B)&#123;  <span class="hljs-comment">// 避免死锁：synchronized (A)</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;t2尝试获得锁A&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (A)&#123;   <span class="hljs-comment">// 避免死锁：synchronized (B)</span><br><br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">16:43:02.129 [t2] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - t2尝试获得锁A<br>16:43:03.123 [t1] <span class="hljs-built_in">DEBUG</span> <span class="hljs-built_in">info</span> - t1尝试获得锁B<br></code></pre></td></tr></table></figure>

<p>避免死锁：顺序加锁</p>
<p>t2线程也是先获取锁A再获取锁B，两个线程可以轮流获取锁A和锁B。</p>
<h3 id="三个线程T1、T2、T3，如何让他们按顺序执行？"><a href="#三个线程T1、T2、T3，如何让他们按顺序执行？" class="headerlink" title="三个线程T1、T2、T3，如何让他们按顺序执行？"></a>三个线程T1、T2、T3，如何让他们按顺序执行？</h3><p>这是一道面试中常考的并发编程的代码题，与它相似的问题有：</p>
<ul>
<li>三个线程T1、T2、T3轮流打印ABC，打印n次，如ABCABCABCABC…….</li>
<li>两个线程交替打印1-100的奇偶数</li>
<li>N个线程循环打印1-100</li>
</ul>
<p>其实这类问题本质上都是线程通信问题，思路基本上都是一个线程执行完毕，阻塞该线程，唤醒其他线<br>程，按顺序执行下一个线程</p>
<p>wait&#x2F;notify</p>
<p>三个线程T1、T2、T3轮流打印ABC，打印n次，如ABCABCABCABC…….</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CrossOutputABC_WaitNotify1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">WaitNotify_ABC</span> <span class="hljs-variable">waitNotify_abc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitNotify_ABC</span>();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            waitNotify_abc.print(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>        &#125;, <span class="hljs-string">&quot;A&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            waitNotify_abc.print(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br>        &#125;, <span class="hljs-string">&quot;B&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            waitNotify_abc.print(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>);<br>        &#125;, <span class="hljs-string">&quot;C&quot;</span>).start();<br><br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNotify_ABC</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> num;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String content, <span class="hljs-type">int</span> targetNum, <span class="hljs-type">int</span> loopNumber)</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                <span class="hljs-keyword">while</span> (num%<span class="hljs-number">3</span> != targetNum)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        lock.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                num++;<br>                System.out.print(content);<br>                lock.notifyAll();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>两个线程交替打印1-100的奇偶数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CrossOutputOddEven_WaitNotify</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Wait_Notify_Odd_Even</span> <span class="hljs-variable">oddEven</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Wait_Notify_Odd_Even</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            oddEven.printOddEven(<span class="hljs-number">100</span>);<br>        &#125;,<span class="hljs-string">&quot;Odd&quot;</span>).start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            oddEven.printOddEven(<span class="hljs-number">100</span>);<br>        &#125;,<span class="hljs-string">&quot;Even&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wait_Notify_Odd_Even</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> count;<br>    Wait_Notify_Odd_Even(<span class="hljs-type">int</span> count)&#123;<br>        <span class="hljs-built_in">this</span>.count = count;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printOddEven</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">while</span>(count &lt; num)&#123;<br>            <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.print(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>);<br>                    System.out.println(++count);<br>                    lock.notifyAll();<br>                    lock.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br><span class="hljs-comment">//        lock.notifyAll();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>N个线程循环打印1-100，假设N&#x3D;4</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CrossOutputNThread_WaitNotify</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">WaitNotify_NThread</span> <span class="hljs-variable">nThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitNotify_NThread</span>();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            nThread.print(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>);<br>        &#125;, <span class="hljs-string">&quot;线程1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            nThread.print(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>);<br>        &#125;, <span class="hljs-string">&quot;线程2&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            nThread.print(<span class="hljs-number">2</span>, <span class="hljs-number">100</span>);<br>        &#125;, <span class="hljs-string">&quot;线程3&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            nThread.print(<span class="hljs-number">3</span>, <span class="hljs-number">100</span>);<br>        &#125;, <span class="hljs-string">&quot;线程4&quot;</span>).start();<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNotify_NThread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> num;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> targetNum, <span class="hljs-type">int</span> maxnum)</span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                <span class="hljs-keyword">while</span> (num%<span class="hljs-number">4</span> != targetNum)&#123;<br>                    <span class="hljs-keyword">if</span>(num &gt;= maxnum) <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        lock.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(num &gt;= maxnum) <span class="hljs-keyword">break</span>;<br>                num++;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+num);<br>                lock.notifyAll();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>










              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/" class="category-chain-item">面试准备</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>面试准备：JUC</div>
      <div>http://jswanyu.github.io/2022/03/10/面试准备/JUC/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>万宇</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年3月10日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>






<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
