

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="万宇">
  <meta name="keywords" content="">
  
    <meta name="description" content="1 计算机网络计算机网络的各层协议及作用？计算机网络体系可以大致分为一下三种，OSI七层模型、TCP&#x2F;IP四层模型和五层模型。  OSI七层模型：大而全，但是比较复杂、而且是先有了理论模型，没有实际应用。 TCP&#x2F;IP四层模型：是由实际应用发展总结出来的，从实质上讲，TCP&#x2F;IP只有最上面三层，最下面一层没有什么具体内容，TCP&#x2F;IP参考模型没有真正描述这一">
<meta property="og:type" content="article">
<meta property="og:title" content="面试准备：计算机网络">
<meta property="og:url" content="http://jswanyu.github.io/2022/03/10/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="Wynn&#39;s blog">
<meta property="og:description" content="1 计算机网络计算机网络的各层协议及作用？计算机网络体系可以大致分为一下三种，OSI七层模型、TCP&#x2F;IP四层模型和五层模型。  OSI七层模型：大而全，但是比较复杂、而且是先有了理论模型，没有实际应用。 TCP&#x2F;IP四层模型：是由实际应用发展总结出来的，从实质上讲，TCP&#x2F;IP只有最上面三层，最下面一层没有什么具体内容，TCP&#x2F;IP参考模型没有真正描述这一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/icon/%E9%9D%A2%E8%AF%95-%E9%A6%96%E9%A1%B5%E5%B0%81%E9%9D%A2%E5%9B%BE.jpeg">
<meta property="article:published_time" content="2022-03-10T15:32:04.000Z">
<meta property="article:modified_time" content="2022-06-27T10:15:57.406Z">
<meta property="article:author" content="万宇">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/icon/%E9%9D%A2%E8%AF%95-%E9%A6%96%E9%A1%B5%E5%B0%81%E9%9D%A2%E5%9B%BE.jpeg">
  
  
  
  <title>面试准备：计算机网络 - Wynn&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"jswanyu.github.io","root":"/","version":"1.9.1","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":false},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wynn&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                时间线
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/icon/%E9%9D%A2%E8%AF%95-%E6%96%87%E7%AB%A0%E9%A1%B5%E9%A1%B6%E9%83%A8%E5%9B%BE.jpeg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="面试准备：计算机网络"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-03-10 23:32" pubdate>
          2022年3月10日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          18k 字
        
      </span>
    

    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">面试准备：计算机网络</h1>
            
            <div class="markdown-body">
              
              <p>1</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h3 id="计算机网络的各层协议及作用？"><a href="#计算机网络的各层协议及作用？" class="headerlink" title="计算机网络的各层协议及作用？"></a>计算机网络的各层协议及作用？</h3><p>计算机网络体系可以大致分为一下三种，OSI七层模型、TCP&#x2F;IP四层模型和五层模型。</p>
<ul>
<li>OSI七层模型：大而全，但是比较复杂、而且是先有了理论模型，没有实际应用。</li>
<li>TCP&#x2F;IP四层模型：是由实际应用发展总结出来的，从实质上讲，TCP&#x2F;IP只有最上面三层，最下面一层没有什么具体内容，TCP&#x2F;IP参考模型没有真正描述这一层的实现。</li>
<li>五层模型：五层模型只出现在计算机网络教学过程中，这是对七层模型和四层模型的一个折中，既简洁又能将概念阐述清楚。（面试时候答这个就行）</li>
</ul>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Computer%20Network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E6%A8%A1%E5%9E%8B%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="面经-计算机网络体系模型图"></p>
<p>七层网络体系结构各层的主要功能：</p>
<ul>
<li>应用层：为应用程序提供交互服务。在互联网中的应用层协议很多，如域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议等。</li>
<li>表示层：主要负责数据格式的转换，如加密解密、转换翻译、压缩解压缩等。</li>
<li>会话层：负责在网络中的两节点之间建立、维持和终止通信，如服务器验证用户登录便是由会话层完成的。</li>
<li>运输层：有时也译为传输层，向主机进程提供通用的数据传输服务。该层主要有以下两种协议：<ul>
<li>TCP：提供面向连接的、可靠的数据传输服务；</li>
<li>UDP：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性。</li>
</ul>
</li>
<li>网络层：选择合适的路由和交换结点，确保数据及时传送。主要包括IP协议。</li>
<li>数据链路层：数据链路层通常简称为链路层。将网络层传下来的IP数据包组装成帧，并再相邻节点的链路上传送帧。</li>
<li>物理层：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和通信手段的差异。</li>
</ul>
<h3 id="什么是网络协议，为什么要对网络协议分层"><a href="#什么是网络协议，为什么要对网络协议分层" class="headerlink" title="什么是网络协议，为什么要对网络协议分层"></a>什么是网络协议，为什么要对网络协议分层</h3><p>网络协议是计算机在通信过程中要遵循的一些约定好的规则。</p>
<p>网络分层的原因：易于实现和维护，因为各层之间是独立的，层与层之间不会收到影响。有利于标准化的制定</p>
<h3 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h3><p>URI(Uniform Resource Identifier)：中文全称为统一资源标志符，主要作用是唯一标识一个资源。</p>
<p>URL(Uniform Resource Location)：中文全称为统一资源定位符，主要作用是提供资源的路径。</p>
<p>有个经典的比喻是URI像是身份证，可以唯一标识一个人，而URL更像一个住址，可以通过URL找到这个<br>人。</p>
<h3 id="在浏览器中输⼊url地址到显示主⻚的过程"><a href="#在浏览器中输⼊url地址到显示主⻚的过程" class="headerlink" title="在浏览器中输⼊url地址到显示主⻚的过程"></a>在浏览器中输⼊url地址到显示主⻚的过程</h3><ol>
<li><p>对输入到浏览器的url进行DNS解析，将域名转换为IP地址。</p>
<p> 浏览器搜索自己的DNS缓存（维护一张域名与IP的对应表）；若没有，则搜索操作系统的DNS缓存（维护一张域名与IP的对应表）；若没有，则搜索操作系统的hosts文件（维护一张域名与IP的对应表）。若都没有，则找 tcp&#x2F;ip 参数中设置的首选 dns 服务器，即本地 dns 服务器（递归查询），本地域名服务器查询自己的dns缓存，如果没有，则进行迭代查询。将本地dns服务器将IP返回给操作系统，同时缓存IP。</p>
</li>
<li><p>和目的服务器建立TCP连接</p>
<p> 发起 tcp 的三次握手，建立 tcp 连接。浏览器会以一个随机端口（1024-65535）向服务端的 web 程序 80 端口发起 tcp 的连接。</p>
</li>
<li><p>向目的服务器发送HTTP请求</p>
</li>
<li><p>服务器处理请求并返回HTTP报文，客户端得到 html 代码。</p>
</li>
<li><p>浏览器解析html 代码，并请求 html 中的资源</p>
</li>
<li><p>浏览器对页面进行渲染，并呈现给用户</p>
</li>
</ol>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Computer%20Network/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt="浏览器输入url过程"></p>
<h3 id="DNS的工作流程"><a href="#DNS的工作流程" class="headerlink" title="DNS的工作流程"></a>DNS的工作流程</h3><p>DNS的定义：DNS的全称是domain name system，即域名系统。DNS是因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的去访问互联网而不用去记住能够被机器直接读取的IP地址。比如大家访问百度，更多地肯定是访问<a target="_blank" rel="noopener" href="http://www.baidu.com,而不是访问112.80.248.74,因为这几乎无规则的ip地址实在太难记了.dns要做的就是将www.baidu.com解析成112.80.248.74./">www.baidu.com，而不是访问112.80.248.74，因为这几乎无规则的IP地址实在太难记了。DNS要做的就是将www.baidu.com解析成112.80.248.74。</a></p>
<h3 id="DNS是集群式的工作方式还是单点式的，为什么？"><a href="#DNS是集群式的工作方式还是单点式的，为什么？" class="headerlink" title="DNS是集群式的工作方式还是单点式的，为什么？"></a>DNS是集群式的工作方式还是单点式的，为什么？</h3><p>答案是集群式的，很容易想到的一个方案就是只用一个DNS服务器，包含了所有域名和IP地址的映射。尽管这种设计方式看起来很简单，但是缺点显而易见，如果这个唯一的DNS服务器出了故障，那么就全完了，因特网就几乎崩了。为了避免这种情况出现，DNS系统采用的是分布式的层次数据数据库模式，还有缓存的机制也能解决这种问题。</p>
<h3 id="DNS的工作流程-1"><a href="#DNS的工作流程-1" class="headerlink" title="DNS的工作流程"></a>DNS的工作流程</h3><p>主机向本地域名服务器的查询一般是采用递归查询（自己帮你去查），而本地域名服务器向根域名的查询一般是采用迭代查询（告诉你去哪查，你自己去）。</p>
<p>递归查询主机向本地域名发送查询请求报文，而本地域名服务器不知道该域名对应的IP地址时，本地域名服务器会继续向根域名服务器发送查询请求报文，不是通知主机自己向根域名发送查询请求报文。</p>
<p>迭代查询是，本地域名服务器向根域名发出查询请求报文后，根域名不会继续向顶级域名服务器发送查询请求报文，而是通知本地域名服务器自己去向顶级域名发送查询请求报文。</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/DNS.png" srcset="/img/loading.gif" lazyload alt="DNS"></p>
<ol>
<li>在浏览器中输入<a target="_blank" rel="noopener" href="http://www.baidu.com域名,操作系统会先检查自己本地的hosts文件是否有这个域名的/">www.baidu.com域名，操作系统会先检查自己本地的hosts文件是否有这个域名的</a><br> 映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</li>
<li>如果hosts文件中没有，则查询本地DNS解析器<strong>缓存</strong>，如果有，则完成地址解析。</li>
<li>如果本地DNS解析器缓存中没有，则去查找本地DNS服务器，如果查到，完成解析。</li>
<li>如果没有，则本地服务器会向根域名服务器发起查询请求。根域名服务器会告诉本地域名服务器去<br> 查询哪个顶级域名服务器（TLD DNS）。</li>
<li>本地域名服务器向顶级域名服务器发起查询请求，顶级域名服务器会告诉本地域名服务器去查找哪<br> 个权威域名服务器。</li>
<li>本地域名服务器向权威域名服务器发起查询请求，权威域名服务器告诉本地域名服务器<a target="_blank" rel="noopener" href="http://www.baid/">www.baid</a><br> u.com所对应的IP地址。</li>
<li>本地域名服务器告诉主机<a target="_blank" rel="noopener" href="http://www.baidu.com所对应的ip地址./">www.baidu.com所对应的IP地址。</a></li>
</ol>
<h3 id="TCP和UDP的区别？"><a href="#TCP和UDP的区别？" class="headerlink" title="TCP和UDP的区别？"></a>TCP和UDP的区别？</h3><table>
<thead>
<tr>
<th></th>
<th>UDP</th>
<th>TCP</th>
</tr>
</thead>
<tbody><tr>
<td>是否连接（最大区别）</td>
<td>无连接</td>
<td>面向连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td>不可靠传输，不使用流量控制和拥塞控制</td>
<td>可靠传输，使用流量控制和拥塞控制</td>
</tr>
<tr>
<td>是否有序</td>
<td>无序</td>
<td>有序，消息在传输过程中可能会乱序，TCP 会重新排序</td>
</tr>
<tr>
<td>传输速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>连接对象个数</td>
<td>支持一对一，一对多，多对一和多对多交互通信</td>
<td>只能是一对一通信</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向报文</td>
<td>面向字节流</td>
</tr>
<tr>
<td>首部开销</td>
<td>首部开销小，仅8字节</td>
<td>首部最小20字节，最大60字节</td>
</tr>
<tr>
<td>适用场景</td>
<td>适用于面向无连接，实时应用（IP电话、视频会议、直播等）</td>
<td>适用于面向连接，要求可靠传输的应用，例如文件、邮件传输</td>
</tr>
</tbody></table>
<p>总结：</p>
<p>TCP 用于在传输层有必要实现<strong>可靠</strong>传输的情况，UDP 用于对<strong>高速传输和实时性</strong>有较高要求的通信。TCP和 UDP 应该根据应用目的按需使用。</p>
<h3 id="UDP-和-TCP-对应的应用场景是什么？"><a href="#UDP-和-TCP-对应的应用场景是什么？" class="headerlink" title="UDP 和 TCP 对应的应用场景是什么？"></a>UDP 和 TCP 对应的应用场景是什么？</h3><p>TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：FTP文件传输、HTTP &#x2F; HTTPS超文本传输协议、SMTP电子邮件协议、TELNET远程终端接入</p>
<p>UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：包总量较少的通信，如 DNS域名转换 、SNMP（简单网络管理协议，用于网络设备的管理）等、视频、音频等多媒体通信、广播通信</p>
<h3 id="TCP和UDP的首部都包含什么"><a href="#TCP和UDP的首部都包含什么" class="headerlink" title="TCP和UDP的首部都包含什么"></a>TCP和UDP的首部都包含什么</h3><p>TCP首部：前20个字节是固定的，后面有4n个字节是根据需而增加的选项，所以TCP首部最小长度为20字节，最大60字节</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Computer%20Network/TCP%E9%A6%96%E9%83%A8.png" srcset="/img/loading.gif" lazyload alt="image-20220427175815106"></p>
<p>UDP首部：UDP的首部只有8个字节，源端口号、目的端口号、长度和校验和各两个字节。</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Computer%20Network/UDP%E9%A6%96%E9%83%A8.png" srcset="/img/loading.gif" lazyload alt="image-20220427175944012"></p>
<h3 id="TCP协议如何保证可靠传输"><a href="#TCP协议如何保证可靠传输" class="headerlink" title="TCP协议如何保证可靠传输"></a>TCP协议如何保证可靠传输</h3><p>主要有校验和、序列号、超时重传、流量控制及拥塞避免等几种方法。</p>
<p>校验和：在发送端和接收端分别计算数据的校验和，如果两者不一致，则说明数据在传输过程中出现了差错，TCP将丢弃和不确认此报文段。</p>
<p>序列号&#x2F;确认应答：TCP会对每一个发送的字节进行编号，接收方接到数据后，会对发送方发送确认应答（ACK报文），并且这个ACK报文中带有相应的确认编号，告诉发送方，下一次发送的数据从编号多少开始发。</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Computer%20Network/TCP%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93-%E5%BA%8F%E5%88%97%E5%8F%B7.png" srcset="/img/loading.gif" lazyload alt="image-20220506164148913"></p>
<p>超时重传：超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。最大超时时间是动态计算的。</p>
<p>流量控制：如果主机A 一直向主机B发送数据，不考虑主机B的接受能力，则可能导致主机B的接受缓冲区满了而无法再接受数据，从而会导致大量的数据丢包，引发重传机制。而在重传的过程中，若主机B的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效率。所以引入流量控制机制，主机B通过告诉主机A自己接收缓冲区的大小，来使主机A控制发送的数据量。流量控制与TCP协议报头中的窗口大小有关。窗口的大小就是接收端接收数据缓冲区的剩余大小。接收端会在收到数据包后发送ACK报文时，将自己的窗口大小填入ACK中，发送方会根据ACK报文中的窗口大小进而控制发送速度。如果窗口大小为零，发送方会停止发送数据。</p>
<p>滑动窗口：滑动窗口既提高了报文传输的效率，也避免了发送方发送过多的数据而导致接收方无法正常处理的异常。</p>
<p>拥塞控制：在数据传输过程中，可能由于网络状态的问题，造成网络拥堵，此时引入拥塞控制机制，在保证TCP可靠性的同时，提高性能。</p>
<h3 id="详细讲一下TCP的滑动窗口？"><a href="#详细讲一下TCP的滑动窗口？" class="headerlink" title="详细讲一下TCP的滑动窗口？"></a>详细讲一下TCP的滑动窗口？</h3><h3 id="详细讲一下拥塞控制？"><a href="#详细讲一下拥塞控制？" class="headerlink" title="详细讲一下拥塞控制？"></a>详细讲一下拥塞控制？</h3><h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>如果TCP连接已经建立，在通信过程中，客户端突然故障，那么服务端不会一直等下去，过一段时间就关闭连接了。具体原理是TCP有一个保活机制，主要用在服务器端，用于检测已建立TCP链接的客户端的状态，防止因客户端崩溃或者客户端网络不可达，而服务器端一直保持该TCP链接，占用服务器端的大量资源（因为Linux系统中可以创建的总TCP链接数是有限制的）。</p>
<p>保活机制原理：设置TCP保活机制的保活时间keepIdle，即在TCP链接超过该时间没有任何数据交互时，发送保活探测报文；设置保活探测报文的发送时间间隔keepInterval；设置保活探测报文的总发送次数keepCount。如果在keepCount次的保活探测报文均没有收到客户端的回应，则服务器端即关闭与客户端的TCP链接。</p>
<h3 id="详细介绍一下-TCP-的三次握手机制？"><a href="#详细介绍一下-TCP-的三次握手机制？" class="headerlink" title="详细介绍一下 TCP 的三次握手机制？"></a>详细介绍一下 TCP 的三次握手机制？</h3><p>TCP报文首部由多个部分组成，只列出此处相关的：</p>
<ul>
<li>Sequence number ：序号，seq，TCP连接中传送的字节流中的每个字节都按顺序编号，序号是发送数据包中的第一个字节的序列号。发送方和接收方都有自己的顺序号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；</li>
<li>Acknowledge number：确认号，ack，响应前面的seq，是期望收到对方下一个报文的第一个数据字节的序号，通常期望下次发出的序列号为seq+1。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；</li>
</ul>
<p>然后有一些TCP标志位，TCP标志位的值代表了当前请求的目的。标志位一共有6种，分别是：</p>
<ul>
<li>SYN(synchronous)： 发送&#x2F;同步标志，用来建立连接，和下面的第二个标志位ACK搭配使用。连接开始时，SYN&#x3D;1，ACK&#x3D;0，代表连接开始但是未获得响应。当连接被响应的时候，标志位会发生变化，其中ACK会置为1，代表确认收到连接请求，此时的标志位变成了 SYN&#x3D;1，ACK&#x3D;1。</li>
<li>ACK(acknowledgement)：确认标志，表示确认收到请求。</li>
<li>PSH(push) ：表示推送操作，就是指数据包到达接收端以后，不对其进行队列处理，而是尽可能的将数据交给应用程序处理；</li>
<li>FIN(finish)：结束标志，用于结束一个TCP会话；</li>
<li>RST(reset)：重置复位标志，用于复位对应的TCP连接。</li>
<li>URG(urgent)：紧急标志，用于保证TCP连接不被中断，并且督促中间层设备尽快处理。</li>
</ul>
<p>三次握手的本质就是确定发送端和接收端具备收发信息的能力，在能流畅描述三次握手的流程及其中的字段含义作用的同时还需要记住<strong>每次握手时接收端和发送端的状态</strong>。这个比较容易忽略</p>
<p>TCP三次握手机制：</p>
<ul>
<li>开始时客户端和服务端的状态都是CLOSED；</li>
<li>第一次握手：客户端向服务端发起建立连接请求，客户端会随机生成一个起始序列号x，客户端向服务端发送的字段中包含标志位SYN&#x3D;1，序列号seq&#x3D;x。TCP规定，SYN报文段（SYN&#x3D;1的报文段）不能携带数据，但需要消耗掉一个序号。第一次握手前客户端的状态为CLOSE，第一次握手后客户端的状态为SYN-SENT（同步已发送）。此时服务端的状态为LISTEN</li>
<li>第二次握手：服务端在收到客户端发来的报文后，如果同意建立连接，会随机生成一个服务端的起始序列号y，然后给客户端回复一段报文，其中包括标志位SYN&#x3D;1（表示要和客户端建立一个连接），ACK&#x3D;1（表示确认序号有效），序列号seq&#x3D;y，确认号ack&#x3D;x+1。TCP规定，这个报文（SYN+ACK）也不能携带数据，但是同样要消耗一个序号。第二次握手前服务端的状态为LISTEN，第二次握手后服务端的状态为SYN-RCVD（同步收到），此时客户端的状态为SYN-SENT（同步已发送）。</li>
<li>第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含标志位ACK&#x3D;1，序列号seq&#x3D;x+1（因为第一次握手时SYN消耗了一个序号，所以这次是x+1），确认号ack&#x3D;y+1。第三次握手前客户端的状态为SYN-SENT（同步已发送），第三次握手后客户端和服务端的状态都为ESTABLISHED（已建立连接）。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号（可以认为不占用序号）。</li>
<li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li>
</ul>
<p>理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Computer%20Network/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="TCP三次握手示意图"></p>
<h3 id="为什么需要三次握手，而不是两次？"><a href="#为什么需要三次握手，而不是两次？" class="headerlink" title="为什么需要三次握手，而不是两次？"></a>为什么需要三次握手，而不是两次？</h3><p>不可以，主要从以下两方面考虑（假设客户端是首先发起连接请求）：</p>
<ol>
<li>假设建立TCP连接仅需要两次握手，如果服务端接收到了一个早已失效的来自客户端的连接请求报文，会向客户端发送确认报文同意建立TCP连接。但其实客户端并不想向服务端发送数据，那个只是之前失效的请求报文，所以此次TCP连接没有意义并且浪费了资源。</li>
<li>假设建立TCP连接仅需要两次握手，那么如果第二次握手时，服务端返回给客户端的确认报文丢失了，客户端这边认为服务端没有和他建立连接，而服务端却以为已经和客户端建立了连接，并且可能向服务端已经开始向客户端发送数据，但客户端并不会接收这些数据，浪费了资源。如果是三次握手，不会出现双方连接还未完全建立成功就开始发送数据的情况。</li>
</ol>
<p>总结：</p>
<ul>
<li><p>三次握手才能让双方均确认自己和对方的发送和接收能力都正常。</p>
<ul>
<li>第一次握手：服务端确认 客户端发、服务端收 正常。</li>
<li>第二次握手：客户端确认 客户端发收、服务端发收 正常，客户端认为连接已建立。</li>
<li>第三次握手：服务端确认 客户端发收、服务端发收 正常，此时双方均建立连接，可以正常通信。</li>
</ul>
</li>
<li><p>三次握手是保证可靠数据传输的原因之一，告知对方自己的初始序号值，并确认收到对方的初始序号值</p>
<p>  TCP 报文段中维护了序号字段和确认序号字段，通过这两个字段双方都可以知道在自己发出的数据中，哪些是已经被对方确认接收的。这两个字段的值会在初始序号值得基础递增，如果是两次握手，只有发起方的初始序号可以得到确认，而另一方的初始序号则得不到确认。</p>
</li>
</ul>
<h3 id="为什么要三次握手，而不是四次？"><a href="#为什么要三次握手，而不是四次？" class="headerlink" title="为什么要三次握手，而不是四次？"></a>为什么要三次握手，而不是四次？</h3><p>因为三次握手已经可以确认双方的发送接收能力正常，双方都知道彼此已经准备好，而且也可以完成对双方初始序号值的确认，也就无需再第四次握手了。</p>
<h3 id="什么是-SYN洪泛攻击？如何防范？"><a href="#什么是-SYN洪泛攻击？如何防范？" class="headerlink" title="什么是 SYN洪泛攻击？如何防范？"></a>什么是 SYN洪泛攻击？如何防范？</h3><blockquote>
<p>SYN洪泛攻击属于 DOS 攻击的一种，它利用 TCP 协议缺陷，通过发送大量的半连接请求，耗费 CPU 和内存资源。</p>
<p>在三次握手过程中，服务器发送 [SYN+ACK] 包（第二个包）之后、收到客户端的 [ACK] 包（第三个包）之前的 TCP 连接称为半连接（half-open connect），此时服务器处于 SYN_RECV （等待客户端响应）状态。如果接收到客户端的 [ACK] ，则 TCP 连接成功，如果未接受到，则会不断重发请求直至成功。</p>
</blockquote>
<p>SYN 攻击的攻击者在短时间内伪造大量不存在的 IP 地址，向服务器不断地发送 [SYN] 包，服务器回复 [SYN+ACK] 包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时。</p>
<p>这些伪造的 [SYN] 包将长时间占用未连接队列，影响了正常的 SYN，导致目标系统运行缓慢、网络堵塞甚至系统瘫痪。</p>
<p>检测：当在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次SYN 攻击。</p>
<p>防范:</p>
<ul>
<li>通过防火墙、路由器等过滤网关防护。</li>
<li>通过加固 TCP&#x2F;IP 协议栈防范，如增加最大半连接数，缩短超时时间。</li>
<li>SYN cookies技术。SYN Cookies 是对 TCP 服务器端的三次握手做一些修改，专门用来防范 SYN洪泛攻击的一种手段。</li>
</ul>
<h3 id="三次握手连接阶段，最后一次ACK包丢失，会发生什么？"><a href="#三次握手连接阶段，最后一次ACK包丢失，会发生什么？" class="headerlink" title="三次握手连接阶段，最后一次ACK包丢失，会发生什么？"></a>三次握手连接阶段，最后一次ACK包丢失，会发生什么？</h3><ul>
<li>服务端：<ul>
<li>第三次的ACK在网络中丢失，那么服务端状态为SYN_RECV，并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便客户端重新发送ACK包。</li>
<li>如果重发指定次数之后，仍然未收到 客户端的ACK应答，那么一段时间后，服务端自动关闭这个连接。</li>
</ul>
</li>
<li>客户端：<ul>
<li>客户端认为这个连接已经建立，如果客户端向服务端发送数据，服务端将以RST包（Reset，标示复位，用于异常的关闭连接）响应。此时，客户端知道第三次握手失败。</li>
</ul>
</li>
</ul>
<h3 id="TCP的四次挥手？"><a href="#TCP的四次挥手？" class="headerlink" title="TCP的四次挥手？"></a>TCP的四次挥手？</h3><p>假设客户端首先发起的断开连接请求</p>
<p>第一次挥手：客户端向服务端发送的数据完成后，向服务端发送连接释放报文，报文包含标志位FIN&#x3D;1，序列号seq&#x3D;u。客户端主动关闭连接，同时等待服务端的确认。此时客户端只能接收数据，不能向服务端发送数据。</p>
<p>第二次挥手：服务端收到客户端的释放连接报文后，向客户端发送确认报文，包含标志位ACK&#x3D;1，序列号seq&#x3D;v，确认号ack&#x3D;u+1。这时 客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据。</p>
<p>第三次挥手：服务端发送完剩余数据后向客户端发送连接释放报文，报文包含标志位FIN&#x3D;1，标志位ACK&#x3D;1，序列号seq&#x3D;w，确认号ack&#x3D;u+1（与第二次挥手相同，因为这段时间客户端没有发送数据）。</p>
<p>第四次挥手：客户端收到服务端发送的释放连接请求，向服务端发送确认报文，包含标志位ACK&#x3D;1，序列号seq&#x3D;u+1，确认号ack&#x3D;w+1。此时，客户端就进入了 TIME-WAIT 状态。注意此时客户端的TCP 连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，才进入 CLOSED 状态。而服务端只要收到客户端发出的确认，就立即进入 CLOSED 状态。可以看到，服务端结束 TCP 连接的时间要比客户端早一些。</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Computer%20Network/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="TCP四次挥手"></p>
<h3 id="为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手？</h3><p>因为需要确保通信双方都能通知对方释放连接，假设客户端发送完数据向服务端发送释放连接请求，当客服端并不知道，服务端是否已经发送完数据，所以此次断开的是客户端到服务端的单向连接，服务端返回给客户端确认报文后，服务端还能继续单向给客户端发送数据。当服务端发送完数据后还需要向客户端发送释放连接请求，客户端返回确认报文，TCP连接彻底关闭。所以断开TCP连接需要客户端和服务端分别通知对方并分别收到确认报文，一共需要四次。</p>
<h3 id="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"><a href="#为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？" class="headerlink" title="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"></a>为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</h3><p>MSL的意思是报文的最长寿命，可以从两方面考虑：</p>
<ol>
<li>确保 ACK 报文能够到达服务端，从而使服务端正常关闭连接。</li>
</ol>
<p>  第四次挥手时，客户端第四次挥手的 ACK 报文不一定会到达服务端。服务端会超时重传 FIN&#x2F;ACK报文，此时如果客户端已经断开了连接，那么就无法响应服务端的二次请求，这样服务端迟迟收不到 FIN&#x2F;ACK 报文的确认，就无法正常断开连接。<br>  MSL 是报文段在网络上存活的最长时间。客户端等待 2MSL 时间，即「客户端 ACK 报文 1MSL 超时 + 服务端 FIN 报文 1MSL 传输」，就能够收到服务端重传的 FIN&#x2F;ACK 报文，然后客户端重传一次 ACK 报文，并重新启动 2MSL 计时器。如此保证服务端能够正常关闭。如果服务端重发的 FIN 没有成功地在 2MSL 时间里传给客户端，服务端则会继续超时重试直到断开连接。</p>
<ol start="2">
<li>防止已失效的连接请求报文段出现在之后的连接中。</li>
</ol>
<p>  TCP 要求在 2MSL 内不使用相同的序列号。客户端在发送完最后一个 ACK 报文段后，再经过时间2MSL，就可以保证本连接持续的时间内产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。或者即使收到这些过时的报文，也可以不处理它。</p>
<h3 id="HTTP-与-HTTPS-的区别？"><a href="#HTTP-与-HTTPS-的区别？" class="headerlink" title="HTTP 与 HTTPS 的区别？"></a>HTTP 与 HTTPS 的区别？</h3><p>HTTPS，超文本传输安全协议，简单讲是HTTP的安全版。目前主流的网站基本上开始默认采用HTTPS作为通信方式</p>
<table>
<thead>
<tr>
<th></th>
<th>HTTP</th>
<th>HTTPS</th>
</tr>
</thead>
<tbody><tr>
<td>端口</td>
<td>80</td>
<td>443</td>
</tr>
<tr>
<td>安全性</td>
<td>无加密，安全性较差</td>
<td>有加密机制，安全性较高</td>
</tr>
<tr>
<td>资源消耗</td>
<td>较少</td>
<td>由于加密处理，资源消耗更多</td>
</tr>
<tr>
<td>是否需要证书</td>
<td>不需要</td>
<td>需要</td>
</tr>
<tr>
<td>协议</td>
<td>运行在TCP协议之上</td>
<td>运行在SSL协议之上，SSL运行在TCP协议之上</td>
</tr>
</tbody></table>
<h3 id="HTTPS-的优缺点"><a href="#HTTPS-的优缺点" class="headerlink" title="HTTPS 的优缺点?"></a>HTTPS 的优缺点?</h3><p>优点：</p>
<ul>
<li>安全性：使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li>
<li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li>
<li>SEO方面：谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</li>
</ul>
<p>缺点：</p>
<ul>
<li>在相同网络环境中，HTTPS 相比 HTTP 无论是响应时间还是耗电量都有大幅度上升。</li>
<li>HTTPS 的安全是有范围的，在黑客攻击、服务器劫持等情况下几乎起不到作用。</li>
<li>在现有的证书机制下，中间人攻击依然有可能发生。</li>
<li>HTTPS 需要更多的服务器资源，也会导致成本的升高。</li>
</ul>
<h3 id="什么是对称加密与非对称加密？"><a href="#什么是对称加密与非对称加密？" class="headerlink" title="什么是对称加密与非对称加密？"></a>什么是对称加密与非对称加密？</h3><ul>
<li>对称加密</li>
</ul>
<p>对称加密指加密和解密使用同一密钥，优点是运算速度快，缺点是没办法保证安全将密钥传输给另一方。常见的对称加密算法有DES、AES等等。</p>
<ul>
<li>非对称加密</li>
</ul>
<p>非对称加密指的是加密和解密使用不同的密钥，一把公开的公钥，一把私有的私钥，这两个密钥是成对出现的。公钥加密的信息只有私钥才能解密，私钥加密的信息只有公钥才能解密。<strong>私钥由服务器自己保存，公钥发送给客户端</strong>。客户端拿到公钥后可以对请求进行加密后发送给服务端，这时候就算中间被截获，没有私钥也无法解密发送的内容，这样确保了<strong>客户端发送到服务端数据的安全</strong>。通过一组公钥私钥，已经可以保证单个方向传输的安全性，那用两组公钥私钥，就能保证双向传输都安全。优点是解决了对称加密中存在的问题。缺点是运算速度较慢。常见的非对称加密算法有RSA、DSA、ECC等等。</p>
<p>两组公钥私钥，非对称加密的工作流程：</p>
<ol>
<li>某网站拥有用于非对称加密的公钥A1、私钥A2；浏览器拥有用于非对称加密的公钥B1、私钥B2。</li>
<li>浏览器向网站服务器请求，服务器把公钥A1明文传输给浏览器。</li>
<li>浏览器把公钥B1明文传输给服务器。</li>
<li>之后浏览器向服务器传输的所有东西都用公钥A1加密，服务器收到后用私钥A2解密。由于只有服务器拥有私钥A2进行解密，所以能保证这条数据的安全。</li>
<li>服务器向浏览器传输的所有东西都用公钥B1加密，浏览器收到后用私钥B2解密。同上也可以保证这条数据的安全。</li>
</ol>
<p>可见确实可行。抛开这里面仍有的漏洞不谈（下文会讲），HTTPS的加密却没使用这种方案，为什么？最主要的原因是非对称加密算法非常耗时，特别是加密解密一些较大数据的时候有些力不从心。而对称加密快很多。那我们能不能运用非对称加密的特性解决前面提到的对称加密的问题？</p>
<h3 id="HTTPS的加密过程"><a href="#HTTPS的加密过程" class="headerlink" title="HTTPS的加密过程"></a>HTTPS的加密过程</h3><p>上面提到了对称加密和非对称加密的优缺点，HTTPS加密使用的对称加密和非对称加密的混合加密算法。具体做法就是<strong>使用非对称加密</strong>来<strong>传输对称密钥</strong>来保证安全性，使用对称加密来保证通信的效率。</p>
<p>非对称加密耗时，我们考虑是否可以采用非对称加密+对称加密结合的方式，而且要尽量减少非对称加密的次数。非对称加密、解密各只需一次的方法：</p>
<ol>
<li>某网站拥有用于非对称加密的公钥A1、私钥A2。</li>
<li>浏览器向网站服务器请求，服务器把公钥A1明文给传输浏览器。</li>
<li>浏览器随机生成一个用于对称加密的密钥X，用公钥A1加密后传给服务器。</li>
<li>服务器拿到后用私钥A2解密得到密钥X。</li>
<li>这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都用密钥X加密解密即可。</li>
</ol>
<p>HTTPS基本就是采用了这种方案。但还是有漏洞的。</p>
<p>中间人攻击：浏览器生成的对称密钥X被公钥A1加密，只有服务器才能用私钥A2进行解密。然而中间人却完全不需要拿到私钥A2就能劫持信息。过程为：</p>
<ol>
<li>某网站拥有用于非对称加密的公钥A1、私钥A2。</li>
<li>浏览器向网站服务器请求，服务器把公钥A1明文传输给浏览器。</li>
<li>中间人劫持到公钥A1，保存下来，把数据包中的公钥A1替换成自己伪造的公钥B1（它当然也拥有公钥B1对应的私钥B2）。</li>
<li>浏览器随机生成一个用于对称加密的密钥X，用公钥B1（<strong>浏览器不知道公钥被替换了</strong>）加密后传给服务器。</li>
<li>中间人劫持后用私钥B2解密得到密钥X，再用公钥A1加密后传给服务器。</li>
<li>服务器拿到后用私钥A2解密得到密钥X。</li>
</ol>
<p>这样在双方都不会发现异常的情况下，中间人得到了对称密钥X。根本原因是浏览器无法确认自己收到的公钥是不是网站自己的。那么下一步就是解决这个问题：如何证明浏览器收到的公钥一定是该网站的公钥？</p>
<p>现实生活中，如果想证明某身份证号一定是小明的，怎么办？看身份证。这里政府机构起到了“公信”的作用，身份证是由它颁发的，它本身的权威可以对一个人的身份信息作出证明。互联网中也有这么一个公信机构，CA 机构。网站在使用HTTPS前，需要向“<strong>CA机构</strong>”申请颁发一<strong>数字证书</strong>，数字证书里有<strong>证书持有者、证书持有者的公钥等信息</strong>。<strong>服务器把证书传输给浏览器，浏览器从证书里取公钥</strong>就可以了。</p>
<p>因此HTTPS的加密过程：</p>
<ol>
<li>客户端向服务端发送请求，然后连接到客户端的443端口。</li>
<li>服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。</li>
<li><strong>传送证书</strong><br> 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。</li>
<li><strong>客户端解析证书</strong><br> 这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值（密钥）。然后用证书对该随机值进行加密。</li>
<li><strong>传送加密信息</strong><br> 这部分传送的是用证书加密后的密钥（随机值），目的就是让服务端得到这个密钥（随机值），以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</li>
<li><strong>服务端加密信息</strong><br> 服务端用私钥解密，得到了客户端传过来的密钥（随机值），然后把内容通过该值进行对称加密。</li>
<li><strong>传输加密后的信息</strong><br> 这部分信息是服务端用密钥（随机值）对称加密后的信息，可以在客户端被还原。</li>
<li><strong>客户端解密信息</strong><br> 客户端用之前生成的密钥（随机值）解密服务端传过来的信息，于是获取了解密后的内容。</li>
</ol>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Computer%20Network/HTTPS%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt="image-20220504152610993"></p>
<p>上述流程存在的一个问题是客户端哪里来的数字认证机构的公钥，其实，在很多浏览器开发时，会内置常用数字证书认证机构的公钥。</p>
<h3 id="常见的状态码？"><a href="#常见的状态码？" class="headerlink" title="常见的状态码？"></a>常见的状态码？</h3><ul>
<li><p>1XX：信息性状态码</p>
<ul>
<li>100 Continue：表示正常，客户端可以继续发送请求</li>
<li>101 Switching Protocols：切换协议，服务器根据客户端的请求切换协议。</li>
</ul>
</li>
<li><p>2XX：成功状态码</p>
<ul>
<li>200 OK：请求成功</li>
<li>201 Created：已创建，表示成功请求并创建了新的资源</li>
<li>202 Accepted：已接受，已接受请求，但未处理完成。</li>
<li>204 No Content：无内容，服务器成功处理，但未返回内容。</li>
<li>205 Reset Content：重置内容，服务器处理成功，客户端应重置文档视图。</li>
<li>206 Partial Content：表示客户端进行了范围请求，响应报文应包含Content-Range指定范围的实体内容</li>
</ul>
</li>
<li><p>3XX：重定向状态码</p>
<ul>
<li>301 Moved Permanently：永久性重定向</li>
<li>302 Found：临时重定向</li>
<li>303 See Other：和301功能类似，但要求客户端采用get方法获取资源</li>
<li>304 Not Modified：所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。</li>
<li>305 Use Proxy：所请求的资源必须通过代理访问</li>
<li>307 Temporary Redirect： 临时重定向，与302类似，要求使用get请求重定向。</li>
</ul>
</li>
<li><p>4XX：客户端错误状态码</p>
<ul>
<li>400 Bad Request：客户端请求的语法错误，服务器无法理解。</li>
<li>401 Unauthorized：表示发送的请求需要有认证信息。</li>
<li>403 Forbidden：服务器理解用户的请求，但是拒绝执行该请求</li>
<li>404 Not Found：服务器无法根据客户端的请求找到资源。</li>
<li>405 Method Not Allowed：客户端请求中的方法被禁止</li>
<li>406 Not Acceptable：服务器无法根据客户端请求的内容特性完成请求</li>
<li>408 Request Time-out：服务器等待客户端发送的请求时间过长，超时</li>
</ul>
</li>
<li><p>5XX：服务端错误状态码</p>
<ul>
<li>500 Internal Server Error：服务器内部错误，无法完成请求</li>
<li>501 Not Implemented：服务器不支持请求的功能，无法完成请求</li>
</ul>
</li>
</ul>
<h3 id="状态码301和302的区别是什么？"><a href="#状态码301和302的区别是什么？" class="headerlink" title="状态码301和302的区别是什么？"></a>状态码301和302的区别是什么？</h3><p>共同点：301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）。<br>不同点：301表示旧地址A的资源已经被永久地移除了(这个资源不可访问了)，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO中302好于301。</p>
<h3 id="转发和重定向？"><a href="#转发和重定向？" class="headerlink" title="转发和重定向？"></a>转发和重定向？</h3><p>重定向的原因：</p>
<ol>
<li>网站调整（如改变网页目录结构）；</li>
<li>网页被移到一个新地址；</li>
<li>网页扩展名改变(如应用需要把.php改成.Html或.shtml)。</li>
</ol>
<p>重定向的典型场景，我把一个数据删除了，删除应该返回的东西是什么，肯定不是返回删除的东西，一般来说删除之后返回查询页面，会更加直观，那么这里就是重定向，我明明请求发送的是删除，但是重定向到了查询。具体的过程就是，浏览器发送的请求是删除，服务器返回的是一个建议，状态码是302，返回的建议里带上建议访问的目标，浏览器就会访问这个建议的URL。而且很显然的事情是我们并不能在服务器内部去做这些事情，你不能说把删除的代码里写上和查询有关的内容，删除和查询是独立的功能，要保证低耦合。所以重定向以低耦合的方式完成了页面的跳转，意义重大</p>
<p>再比如注册完了重定向到登陆页面，也是一样的道理。</p>
<h3 id="常见的HTTP方法"><a href="#常见的HTTP方法" class="headerlink" title="常见的HTTP方法"></a>常见的HTTP方法</h3><p>PUT：上传文件，向服务器添加数据，可以看作增</p>
<p>DELETE：删除文件</p>
<p>POST：传输数据，向服务器提交数据，对服务器数据进行更新。</p>
<p>GET：获取资源，查询服务器资源</p>
<p>下面的有空可以背背</p>
<p>HEAD：和GET方法类似，但只返回报文首部，不返回报文实体主体部分</p>
<p>PATCH：对资源进行部分修改</p>
<p>OPTIONS：查询指定的URL支持的方法</p>
<p>CONNECT：要求用隧道协议连接代理</p>
<p>TRACE：服务器会将通信路径返回给客户端</p>
<h3 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h3><ul>
<li><p>作用</p>
<p>  GET用于获取资源，POST用于传输实体主体</p>
</li>
<li><p>参数位置</p>
<p>  GET的参数放在URL中，POST的参数存储在实体主体中，并且GET方法提交请求的URL中的数据最多是2048字节，POST请求没有大小限制。</p>
</li>
<li><p>安全性</p>
<p>  GET方法因为参数放在URL中，安全性相对于POST较差一些</p>
</li>
<li><p>幂等性</p>
<p>  GET方法是具有幂等性的，而POST方法不具有幂等性。这里幂等性指客户端连续发出多次请求，收到的结果都是一样的.</p>
</li>
</ul>
<h3 id="HTTP请求报文和响应报文的格式？"><a href="#HTTP请求报文和响应报文的格式？" class="headerlink" title="HTTP请求报文和响应报文的格式？"></a>HTTP请求报文和响应报文的格式？</h3><p>请求报文格式：</p>
<ol>
<li>请求行（请求方法+URI协议+版本）</li>
<li>请求头部</li>
<li>空行</li>
<li>请求主体</li>
</ol>
<p>响应报文：</p>
<ol>
<li>状态行（版本+状态码+原因短语）</li>
<li>响应首部</li>
<li>空行</li>
<li>响应主体</li>
</ol>
<h3 id="HTTP-1-0、HTTP-1-1及HTTP-2-0的主要区别是什么"><a href="#HTTP-1-0、HTTP-1-1及HTTP-2-0的主要区别是什么" class="headerlink" title="HTTP 1.0、HTTP 1.1及HTTP 2.0的主要区别是什么"></a>HTTP 1.0、HTTP 1.1及HTTP 2.0的主要区别是什么</h3><p>HTTP 1.0和HTTP 1.1的区别：</p>
<ul>
<li><p>长连接</p>
<p>  HTTP 1.1支持长连接和请求的流水线操作。长连接是指不在需要每次请求都重新建立一次连接，HTTP 1.0默认使用短连接，每次请求都要重新建立一次TCP连接，资源消耗较大。</p>
<p>  请求的流水线操作是指客户端在收到HTTP的响应报文之前可以先发送新的请求报文，不支持请求的流水线操作需要等到收到HTTP的响应报文后才能继续发送新的请求报文。</p>
</li>
<li><p>缓存处理</p>
<p>  在HTTP 1.0中主要使用header中的If-Modified-Since,Expires作为缓存判断的标准，HTTP 1.1引入了Entity tag，If-Unmodified-Since, If-Match等更多可供选择的缓存头来控制缓存策略。</p>
</li>
<li><p>错误状态码</p>
<p>  在HTTP 1.1新增了24个错误状态响应码</p>
</li>
<li><p>HOST域<br>  在HTTP 1.0 中认为每台服务器都会绑定唯一的IP地址，所以，请求中的URL并没有传递主机名。但后来一台服务器上可能存在多个虚拟机，它们共享一个IP地址，所以HTTP 1.1中请求消息和响应消息都应该支持Host域。</p>
</li>
<li><p>带宽优化及网络连接的使用</p>
<p>  在HTTP 1.0中会存在浪费带宽的现象，主要是因为不支持断点续传功能，客户端只是需要某个对象的一部分，服务端却将整个对象都传了过来。在HTTP 1.1中请求头引入了range头域，它支持只请求资源的某个部分，返回的状态码为206。</p>
</li>
</ul>
<p>HTTP 2.0的新特性</p>
<ul>
<li>新的二进制格式：HTTP 1.x的解析是基于文本，HTTP 2.0的解析采用二进制，实现方便，健壮性更好。</li>
<li>多路复用：每一个request对应一个id，一个连接上可以有多个request，每个连接的request可以随机混在一起，这样接收方可以根据request的id将request归属到各自不同的服务端请求里。</li>
<li>header压缩：在HTTP 1.x中，header携带大量信息，并且每次都需要重新发送，HTTP 2.0采用编码的方式减小了header的大小，同时通信双方各自缓存一份header fields表，避免了header的重复传输。</li>
<li>服务端推送：客户端在请求一个资源时，会把相关资源一起发给客户端，这样客户端就不需要再次发起请求。</li>
</ul>
<h3 id="Cookie、Session和Token的主要区别"><a href="#Cookie、Session和Token的主要区别" class="headerlink" title="Cookie、Session和Token的主要区别"></a>Cookie、Session和Token的主要区别</h3><p>HTTP协议是无状态的，即服务器无法判断用户身份。Session和Cookie可以用来进行身份辨认。</p>
<ul>
<li><p>Cookie</p>
<p>  Cookie是保存在客户端一个小数据块，其中包含了用户信息。当客户端向服务端发起请求，服务端会像客户端浏览器发送一个Cookie，客户端会把Cookie存起来，当下次客户端再次请求服务端时，会携带上这个Cookie，服务端会通过这个Cookie来确定身份。</p>
</li>
<li><p>Session</p>
<p>  Session是通过Cookie实现的，和Cookie不同的是，Session是存在服务端的。当客户端浏览器第一次访问服务器时，服务器会为浏览器创建一个sessionid，将sessionid放到Cookie中，存在客户端浏览器。比如浏览器访问的是购物网站，将一本《图解HTTP》放到了购物车，当浏览器再次访问服务器时，服务器会取出Cookie中的sessionid，并根据sessionid获取会话中的存储的信息，确认浏览器的身份是上次将《图解HTTP》放入到购物车那个用户。</p>
</li>
<li><p>Token（令牌）</p>
<p>  客户端在浏览器第一次访问服务端时，服务端生成的一串字符串作为Token发给客户端浏览器，下次浏览器在访问服务端时携带token即可无需验证用户名和密码，省下来大量的资源开销。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>存放位置</th>
<th>占用空间</th>
<th>安全性</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Cookie</td>
<td>客户端浏览器</td>
<td>小</td>
<td>较低</td>
<td>一般存放配置信息</td>
</tr>
<tr>
<td>Session</td>
<td>服务端</td>
<td>多</td>
<td>较高</td>
<td>存放较为重要的信息</td>
</tr>
</tbody></table>
<p>存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在Session 中保持一些常用变量信息，比如说 UserId 等。</p>
<p>有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</p>
<p>存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</p>
<h3 id="如何考虑分布式-Session-问题？"><a href="#如何考虑分布式-Session-问题？" class="headerlink" title="如何考虑分布式 Session 问题？"></a>如何考虑分布式 Session 问题？</h3><p>在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。</p>
<p>现有的方案是能用Cookie的用Cookie，不方便用cookie的用Session，单体的用Session肯定没有问题，但是Session放在分布式服务器里容易有问题，现在经常用nginx作为负载均衡的服务器，去分配来自众多用户（浏览器）的访问，</p>
<p>如果按照均衡的策略，将某个浏览器的请求发送给服务器1，建立了Session，结果下次这个浏览器请求经过nginx时，发现服务器1太忙了，分配给了其他服务器，那就得重新建立Session。</p>
<p>解决这个问题也有多种方案：</p>
<ul>
<li>一种是设置粘性Session，固定的ip永远都分给一个固定的服务器，但这并不能保证负载是均衡的，整体分布式性能不一定很好</li>
<li>一种是同步Session，建立了一个Session之后，所有分布式服务器同步复制一份Session，这样无论nginx将请求分配给哪个服务器，都可以有Session，但缺点也很明显，同步肯定损耗服务器性能，另外也让服务器之间耦合性增强，不那么独立</li>
<li>一种是共享Session，专门用一台服务器建立Session，其他分布式服务器都访问这个专门的服务器，不过也有问题，毕竟单体的服务器容易出问题。如果专门用来建立Session的服务器也用分布式的，那跟前面几种也差不多。现在更多的是把Session的数据都存到数据库里，至于是存到MySQL还是Redis看需求</li>
</ul>
<p>建议采用共享 Session的方案。</p>
<h3 id="如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="如果客户端禁止 cookie 能实现 session 还能用吗？"></a>如果客户端禁止 cookie 能实现 session 还能用吗？</h3><p>可以，Session的作用是在服务端来保持状态，通过sessionid来进行确认身份，但sessionid一般是通过Cookie来进行传递的。如果Cooike被禁用了，可以通过在URL中传递sessionid。</p>
<h3 id="Servlet是线程安全的吗"><a href="#Servlet是线程安全的吗" class="headerlink" title="Servlet是线程安全的吗"></a>Servlet是线程安全的吗</h3><p>Servlet不是线程安全的，多线程的读写会导致数据不同步的问题</p>
<h3 id="路由器和交换机的区别？"><a href="#路由器和交换机的区别？" class="headerlink" title="路由器和交换机的区别？"></a>路由器和交换机的区别？</h3><p>路由器，属于网络层，识别IP地址并根据IP地址转发数据包，维护数据表并基于数据表进行最佳路径选择</p>
<p>交换机，属于数据链路层，识别MAC地址并根据MAC地址转发数据帧</p>
<h3 id="说一下ping的过程"><a href="#说一下ping的过程" class="headerlink" title="说一下ping的过程"></a>说一下ping的过程</h3><p>ping是ICMP(网际控制报文协议)中的一个重要应用，ICMP是网络层的协议。ping的作用是测试两个主机的连通性。</p>
<p>ping的工作过程：</p>
<ol>
<li>向目的主机发送多个ICMP回送请求报文</li>
<li>根据目的主机返回的回送报文的时间和成功响应的次数估算出数据包往返时间及丢包率。</li>
</ol>
<h3 id="了解ARP协议吗"><a href="#了解ARP协议吗" class="headerlink" title="了解ARP协议吗?"></a>了解ARP协议吗?</h3><p>ARP协议属于网络层的协议，主要作用是实现从IP地址转换为MAC地址。在每个主机或者路由器中都建有一个ARP缓存表，表中有IP地址及IP地址对应的MAC地址。先来看一下什么时IP地址和MAC地址。</p>
<ul>
<li><p>IP地址：IP地址是指互联网协议地址，IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个<strong>逻辑地址</strong>，以此来<strong>屏蔽物理地址的差异</strong>。</p>
</li>
<li><p>MAC地址：MAC地址又称<strong>物理地址</strong>，由网络设备制造商生产时<strong>写在硬件内部，不可更改</strong>，并且每个以太网设备的MAC地址都是唯一的。</p>
</li>
</ul>
<p>数据在传输过程中，会先从高层传到底层，然后在通信链路上传输。TCP报文是传输层的，它在网络层会被封装成IP数据报，在数据链路层被封装成MAC帧，然后在通信链路中传输。<strong>在网络层及以上使用的是IP地址，在数据据链路层使用的是MAC地址。</strong></p>
<p>MAC帧在传送时的源地址和目的地址使用的都是MAC地址，在通信链路上的主机或路由器也都是根据MAC帧首部的MAC地址接收MAC帧。并且在数据链路层是看不到IP地址的，只有当数据传到网络层时去掉MAC帧的首部和尾部时才能在IP数据报的首部中找到源IP地址和目的地址。</p>
<p>网络层实现的是主机之间的通信，而链路层实现的是链路之间的通信，在数据传输过程中，IP数据报的源地址(IP1)和目的地址(IP2)是一直不变的，而MAC地址(硬件地址)却一直随着链路的改变而改变。</p>
<p>ARP的工作流程（面试时问ARP协议主要说这个就可以了）：</p>
<ol>
<li>在局域网内，主机A要向主机B发送IP数据报时，首先会在主机A的ARP缓存表中查找是否有IP地址及其对应的MAC地址，如果有，则将MAC地址写入到MAC帧的首部，并通过局域网将该MAC帧发送到MAC地址所在的主机B。</li>
<li>如果主机A的ARP缓存表中没有主机B的IP地址及所对应的MAC地址，主机A会在局域网内广播发送一个ARP请求分组。局域网内的所有主机都会收到这个ARP请求分组。</li>
<li>主机B在看到主机A发送的ARP请求分组中有自己的IP地址，会像主机A以单播的方式发送一个带有自己MAC地址的响应分组。</li>
<li>主机A收到主机B的ARP响应分组后，会在ARP缓存表中写入主机B的IP地址及其IP地址对应的MAC地址。</li>
<li>如果主机A和主机B不在同一个局域网内，即使知道主机B的MAC地址也是不能直接通信的，必须通过路由器转发到主机B的局域网才可以通过主机B的MAC地址找到主机B。并且主机A和主机B已经可以通信的情况下，主机A的ARP缓存表中寸的并不是主机B的IP地址及主机B的MAC地址，而是主机B的IP地址及该通信链路上的下一跳路由器的MAC地址。这就是上图中的源IP地址和目的IP地址一直不变，而MAC地址却随着链路的不同而改变。</li>
<li>如果主机A和主机B不在同一个局域网，参考上图中的主机H1和主机H2，这时主机H1需要先广播找到路由器R1的MAC地址，再由R1广播找到路由器R2的MAC地址，最后R2广播找到主机H2的MAC地址，建立起通信链路。</li>
</ol>
<h3 id="有了IP地址，为什么还要用MAC地址？"><a href="#有了IP地址，为什么还要用MAC地址？" class="headerlink" title="有了IP地址，为什么还要用MAC地址？"></a>有了IP地址，为什么还要用MAC地址？</h3><p>简单来说，标识网络中的一台计算机，比较常用的就是IP地址和MAC地址，但计算机的IP地址可由用户自行更改，管理起来相对困难，而MAC地址不可更改，所以一般会把IP地址和MAC地址组合起来使用。具体是如何组合使用的在上面的ARP协议中已经讲的很清楚了。</p>
<p>那只用MAC地址不用IP地址可不可以呢？其实也是不行的，因为在最早就是MAC地址先出现的，并且当时并不用IP地址，只用MAC地址，后来随着网络中的设备越来越多，整个路由过程越来越复杂，便出现了子网的概念。对于目的地址在其他子网的数据包，路由只需要将数据包送到那个子网即可，这个过程就是上面说的ARP协议。</p>
<p>那为什么要用IP地址呢？是因为IP地址是和地域相关的，对于同一个子网上的设备，IP地址的前缀都是一样的，这样路由器通过IP地 址的前缀就知道设备在在哪个子网上了，而只用MAC地址的话，路由器则需要记住每个MAC地址在哪个子网，这需要路由器有极大的存储空间，是无法实现的。</p>
<p>IP地址可以比作为地址，MAC地址为收件人，在一次通信过程中，两者是缺一不可的。</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/" class="category-chain-item">面试准备</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>面试准备：计算机网络</div>
      <div>http://jswanyu.github.io/2022/03/10/面试准备/计算机网络/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>万宇</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年3月10日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/10/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/JavaSE/" title="面试准备：JavaSE和集合">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">面试准备：JavaSE和集合</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/10/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/JUC/" title="面试准备：JUC">
                        <span class="hidden-mobile">面试准备：JUC</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>






<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
