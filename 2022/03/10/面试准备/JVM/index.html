

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="万宇">
  <meta name="keywords" content="">
  
    <meta name="description" content="Java则需要先生成字节码，JVM再将字节码解释成机器码。这么做的好处就是JVM屏蔽了底层平台的差别，可以跨平台运行，比如在Windows编译，也可以在Linux运行，这么做的缺点是JVM会影响性能，这也是Java的性能一般不如C或C++的原因。 部分问题未归类&#x3D;&#x3D;java new一个对象的过程中发生了什么&#x3D;&#x3D;https:&#x2F;&#x2F;zhuanlan.zhihu.c">
<meta property="og:type" content="article">
<meta property="og:title" content="面试准备：JVM">
<meta property="og:url" content="http://jswanyu.github.io/2022/03/10/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/JVM/index.html">
<meta property="og:site_name" content="Wynn&#39;s blog">
<meta property="og:description" content="Java则需要先生成字节码，JVM再将字节码解释成机器码。这么做的好处就是JVM屏蔽了底层平台的差别，可以跨平台运行，比如在Windows编译，也可以在Linux运行，这么做的缺点是JVM会影响性能，这也是Java的性能一般不如C或C++的原因。 部分问题未归类&#x3D;&#x3D;java new一个对象的过程中发生了什么&#x3D;&#x3D;https:&#x2F;&#x2F;zhuanlan.zhihu.c">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/icon/%E9%9D%A2%E8%AF%95-%E9%A6%96%E9%A1%B5%E5%B0%81%E9%9D%A2%E5%9B%BE.jpeg">
<meta property="article:published_time" content="2022-03-10T15:32:04.000Z">
<meta property="article:modified_time" content="2022-08-01T08:46:21.817Z">
<meta property="article:author" content="万宇">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/icon/%E9%9D%A2%E8%AF%95-%E9%A6%96%E9%A1%B5%E5%B0%81%E9%9D%A2%E5%9B%BE.jpeg">
  
  
  
  <title>面试准备：JVM - Wynn&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"jswanyu.github.io","root":"/","version":"1.9.1","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":false},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wynn&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                时间线
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/icon/%E9%9D%A2%E8%AF%95-%E6%96%87%E7%AB%A0%E9%A1%B5%E9%A1%B6%E9%83%A8%E5%9B%BE.jpeg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="面试准备：JVM"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-03-10 23:32" pubdate>
          2022年3月10日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          19k 字
        
      </span>
    

    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">面试准备：JVM</h1>
            
            <div class="markdown-body">
              
              <p>Java则需要先生成字节码，JVM再将字节码解释成机器码。这么做的好处就是JVM屏蔽了底层平台的差别，可以跨平台运行，比如在Windows编译，也可以在Linux运行，这么做的缺点是JVM会影响性能，这也是Java的性能一般不如C或C++的原因。</p>
<h2 id="部分问题未归类"><a href="#部分问题未归类" class="headerlink" title="部分问题未归类"></a>部分问题未归类</h2><h3 id="x3D-x3D-java-new一个对象的过程中发生了什么-x3D-x3D"><a href="#x3D-x3D-java-new一个对象的过程中发生了什么-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;java new一个对象的过程中发生了什么&#x3D;&#x3D;"></a>&#x3D;&#x3D;java new一个对象的过程中发生了什么&#x3D;&#x3D;</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/57515223">https://zhuanlan.zhihu.com/p/57515223</a></p>
<p>一、类加载检查：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。双亲委派式的加载 –&gt; 验证 –&gt; 准备 –&gt; 解析 –&gt; 初始化</p>
<p>二、创建对象：</p>
<ol>
<li>在堆区分配对象需要的内存：分配的内存包括本类和父类的所有实例变量，但不包括任何静态变量</li>
<li>对所有实例变量赋默认值（初始化零值），这也是为什么字段在Java代码中可以不赋值就能直接使用的原因。</li>
<li>设置对象头：初始化零值后，虚拟机需要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息都是存放在对象的对象头中。根据虚拟机当前的运行状态不同，如是否使用偏向锁等，对象头都会有不同的设置方式。</li>
<li>执行实例init方法：上述操作完成后，从虚拟机的角度看，一个新的对象已经产生了。但从Java程序的角度看，对象创建才刚刚开始，<code>init</code> 方法还没有执行，所有的字段都还为零。所以，一般执行完new 指令后还会接着执行<code>init</code> 方法，把对象按照程序员的意愿进行初始化（赋值），这样一个真正可用的对象才算生产出来。初始化顺序是先初始化父类再初始化子类，初始化时先执行实例代码块然后是构造方法</li>
<li>如果有类似于Child c &#x3D; new Child()形式的c引用的话，在栈区定义Child类型引用变量c，然后将堆区对象的地址赋值给它</li>
</ol>
<h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><h3 id="JVM的主要组成部分及作用"><a href="#JVM的主要组成部分及作用" class="headerlink" title="JVM的主要组成部分及作用"></a>JVM的主要组成部分及作用</h3><p>JVM主要由类装载系统、运行时数据区、执行引擎、本地接口等四部分组成，其中运行时数据区是重点掌握内容，如下图</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java/JVM/JVM%E7%BB%84%E6%88%90%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="image-20220505162915636"></p>
<p>类装载子系统（类加载器）：加载字节码到内存</p>
<p>运行时数据区：JVM的内存区域</p>
<p>执行引擎：也成为解释器，将字节码翻译成底层系统指令，交由操作系统执行</p>
<p>本地库接口：与其他语言交互时所使用的</p>
<p>工作原理：首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（ExecutionEngine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p>
<h3 id="Java内存分区（JVM运行时数据区域）？"><a href="#Java内存分区（JVM运行时数据区域）？" class="headerlink" title="Java内存分区（JVM运行时数据区域）？"></a>Java内存分区（JVM运行时数据区域）？</h3><p>方法区和堆是线程共享数据区，虚拟机栈、本地方法栈、程序计数器是线程私有数据区</p>
<p>1、程序计数器：执行字节码的行号指示器，线程私有，<font color=red>唯一 一个不会出现 OutOfMemoryError</font></p>
<p>2、Java虚拟机栈：存局部变量表、栈帧，线程私有  &#x3D;&#x3D;<strong>8种基本类型 + 对象引用 + 实例方法</strong>&#x3D;&#x3D;</p>
<blockquote>
<p>Java每个线程启动后，虚拟机就会为其分配一块栈内存。每个栈由多个栈帧（Frame）组成，对应着每次的方法调用。每个方法在执行的同时都会创建一个<strong>栈帧</strong>用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。方法从调用至完成对应着一个栈帧在虚拟机栈入栈到出栈。会抛出StackOverflowError 和OutOfMemoryError</p>
</blockquote>
<p>3、堆：Java 虚拟机中内存最大的一块，存放对象实例，所有线程共享</p>
<p>4、本地方法栈：作用同虚拟机栈，但本地方法栈是为虚拟机调用 Native 方法服务</p>
<p>5、方法区：用于存储已被虚拟机<strong>加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据，所有线程共享</p>
<h3 id="基本类型的变量存在堆还是栈？"><a href="#基本类型的变量存在堆还是栈？" class="headerlink" title="基本类型的变量存在堆还是栈？"></a>基本类型的变量存在堆还是栈？</h3><p>在Text类中定义的成员变量，基本数据类型的变量a是随对象存储在堆中的；在局部方法中基本数据类型的变量b是存储在栈中的</p>
<p>从更深层次理解为什么基本类型的实例变量在堆上创建，局部变量在栈上创建，这样做有什么好处？</p>
<p>如果你将一个实例变量放在栈内，那么就不存在多个线程访问同一个对象资源了，这显然是不对的，所以实例变量要在堆上创建，但是对于局部变量，是在栈上创建的，调用一次方法创建一个帧，独享一份内存区域，其他的线程是不会访问到该线程的资源，在栈上创建也会减轻GC的压力，随着该方法的结束，帧出栈，相对应的内存消除，这种局部变量占用的内存自然就消失了</p>
<h3 id="java中的常量池"><a href="#java中的常量池" class="headerlink" title="java中的常量池"></a>java中的常量池</h3><p>用final修饰的成员变量表示常量，值一旦给定就无法改变！final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。</p>
<p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。</p>
<p>JVM常量池主要分为Class文件常量池、运行时常量池、全局字符串常量池、以及8种基本类型的包装类和常量池</p>
<ul>
<li><p><strong>Class文件常量池</strong></p>
<p>  在Class文件结构中，最头的4个字节用于存储魔数Magic Number，用于确定一个文件是否能被JVM接受，再接着4个字节用于存储版本号，前2个字节存储次版本号，后2个存储主版本号</p>
<p>  再接着是用于存放常量的常量池，由于常量的数量是不固定的，所以常量池的入口放置一个U2类型的数据(constant_pool_count)存储常量池容量计数值。常量池<strong>主要</strong>用于存放编译期生成的各种<strong>字面量</strong>(Literal)和<strong>符号引用量</strong>(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：类和接口的全限定名、字段名称和描述符、方法名称和描述符</p>
</li>
<li><p><strong>运行时常量池</strong></p>
<p>  运行时常量池是方法区的一部分。上面提到的Class文件常量池中存放了字面量和符号引用，这部分内容将在<strong>类加载后</strong>进入方法区的<strong>运行时常量池</strong>中存放。运行时常量池区别于CLass文件常量池的另外一个重要特征是<strong>具备动态性</strong>，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，<strong>运行期间也可能将新的常量放入池中</strong>，这种特性被开发人员利用比较多的就是**String类的intern()**方法。</p>
</li>
<li><p><strong>全局字符串常量池</strong></p>
<p>  略</p>
</li>
<li><p><strong>8种基本类型的包装类和常量池</strong></p>
<p>  java中基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean。前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象。两种浮点数类型的包装类Float,Double并没有实现常量池技术</p>
</li>
</ul>
<h3 id="Java内存泄漏是什么，如何避免"><a href="#Java内存泄漏是什么，如何避免" class="headerlink" title="Java内存泄漏是什么，如何避免"></a>Java内存泄漏是什么，如何避免</h3><p>内存泄漏：指程序中动态分配给内存一些临时对象，并且这些对象始终没有被回收，一直占用着内存，简单来说就是申请内存使用完了不进行释放</p>
<p>常见的内存泄漏产生原因：</p>
<ul>
<li><strong>数据库连接、网络连接等各种连接没有显示释放导致内存泄漏</strong>，例如在数据库连接后不再使用时，必须调用close方法释放与数据库的连接，否则会造成大量对象无法被回收进而造成内存泄漏</li>
<li><strong>哈希值改变</strong>，例如在一个对象存储到HashSet后，改变了对象中参与计算哈希值的字段，那么会导致对象的哈希值发生变化，和之前存入HashSet的哈希值不同，也就无法通过当前对象的引用在HashSet中找到这个对象，无法从HashSet中删除对象，造成内存泄漏，这也是为什么通常利用String类型的变量当作HashMap的key，因为String类型是不可变的</li>
<li><strong>内部类的对象被长期持有</strong>，那么内部类对象所属的外部类对象也不能被收回</li>
<li><strong>静态集合类引起内存泄漏</strong>，因为静态集合的生命周期和JVM一致，所以静态集合引用的对象不能被释放</li>
<li><strong>单例模式导致内存泄漏</strong>，因为单例模式的静态特性，它的生命周期和JVM的生命周期一致，如果单例对象持有外部对象的引用，这个对象也不会被回收</li>
</ul>
<p>内存泄漏解决方案：写代码时尽量避免上述会造成内存泄漏的情况</p>
<h3 id="Java内存溢出是什么，如何避免"><a href="#Java内存溢出是什么，如何避免" class="headerlink" title="Java内存溢出是什么，如何避免"></a>Java内存溢出是什么，如何避免</h3><p>Java内存溢出指程序运行过程中无法申请到足够的内存导致的错误</p>
<p>常见的造成内存溢出的原因：</p>
<ul>
<li>内存加载的数据量太大，内存不够用了</li>
<li>代码中存在死循环或循环产生大量对象</li>
<li>启动参数内存值设置过小</li>
<li>长期的内存泄漏也会导致内存溢出</li>
</ul>
<p>内存溢出解决方案：</p>
<ul>
<li>修改JVM启动参数，增加内存</li>
<li>使用内存查看工具动态查看内存使用情况</li>
<li>对代码进行排查，重点排查有没有上述提到的造成常见内存溢出情景的代码</li>
</ul>
<h3 id="什么情况下会出现OOM？"><a href="#什么情况下会出现OOM？" class="headerlink" title="什么情况下会出现OOM？"></a>什么情况下会出现OOM？</h3><blockquote>
<p>为什么会OOM？</p>
<p>1）分配的少了：比如虚拟机本身可使用的内存（一般通过启动时的VM参数指定）太少。</p>
<p>2）应用用的太多，并且用完没释放，浪费了。此时就会造成内存泄露或者内存溢出。</p>
<p><strong>内存泄露</strong>：申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了，因为申请者不用了，而又不能被虚拟机分配给别人用。</p>
<p><strong>内存溢出</strong>：申请的内存超出了JVM能提供的内存大小，此时称之为溢出。</p>
</blockquote>
<p><strong>最常见的OOM情况有以下三种</strong>：</p>
<ul>
<li><p><code>java.lang.OutOfMemoryError: Java heap space</code> ：java堆内存溢出，此种情况最常见，一般由于<strong>内存泄露或者堆的大小设置不当</strong>引起。</p>
<p>  解决方法：对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx等修改。</p>
</li>
<li><p><code>java.lang.OutOfMemoryError: PermGen space</code> ：java永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区（一个启动类，加载了大量的第三方jar包；Tomcat部署了太多的应用；大量动态生成的反射类，不断地被加载，直到内存满，就会出现OOM）。</p>
<p>  解决方法：此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize&#x3D;64m，XX:MaxPermSize &#x3D;256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。</p>
</li>
<li><p><code>java.lang.StackOverflowError </code>：栈内存溢出，不属于OOM，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。</p>
<p>  解决方法：可以通过修改代码或者调整虚拟机参数-Xss来设置栈的大小。</p>
</li>
</ul>
<h3 id="JVM永久代、元空间"><a href="#JVM永久代、元空间" class="headerlink" title="JVM永久代、元空间"></a>JVM永久代、元空间</h3><p>为什么在JDK1.8会使用元空间取代永久代？</p>
<p>永久代使用的是设定好的虚拟机内存，无法动态扩展内存空间，当加载的类过多就可能发生OOM，并且永久代的内存大小设置也是难以确定的，所以对永久代调优也是比较困难的。元空间的出现就解决了永久代的问题，因为元空间不再使用虚拟机的内存了，而是使用了本地内存，本地内存可以自动扩展调节，内存不足也不会触发Full GC。</p>
<h3 id="对象的访问方式有哪些-可略"><a href="#对象的访问方式有哪些-可略" class="headerlink" title="对象的访问方式有哪些 可略"></a>对象的访问方式有哪些 可略</h3><p>目前主流的访问方式有使用句柄和直接指针两种。</p>
<p>句柄：Java堆中会划分出一块内存来作为句柄，reference中存储的是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如下图</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java/JVM/%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F-%E5%8F%A5%E6%9F%84.png" srcset="/img/loading.gif" lazyload alt="image-20220510154418481"></p>
<p>直接指针：如果使用直接指针访问，reference中存储的就是对象地址，而Java堆对象的布局需要考虑如何放置访问<br>累类型数据的相关信息，如下图</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Java/JVM/%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png" srcset="/img/loading.gif" lazyload alt="image-20220510154720424"></p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>Java和C++的一个明显区别就是Java具备内存动态分配和垃圾收集技术，而C++则需要程序员自己管理内存，这也使得一些初学者觉得C++比较难</p>
<h3 id="Java中垃圾回收是什么，为什么需要垃圾回收"><a href="#Java中垃圾回收是什么，为什么需要垃圾回收" class="headerlink" title="Java中垃圾回收是什么，为什么需要垃圾回收?"></a>Java中垃圾回收是什么，为什么需要垃圾回收?</h3><p>在Java中垃圾回收的目的是回收释放不再被引用的实例对象，这样做可以减少内存泄漏、内存溢出问题的出现</p>
<h3 id="如何判断对象是否可以回收？（垃圾判断算法）"><a href="#如何判断对象是否可以回收？（垃圾判断算法）" class="headerlink" title="如何判断对象是否可以回收？（垃圾判断算法）"></a>如何判断对象是否可以回收？（垃圾判断算法）</h3><ol>
<li><p>引用计数法</p>
<p> 给对象添加一个引用计数器，每当有一个地方引用它时，计数器就会加1；当引用失效时，计数器就减1，当计数器为0就是没有被使用的对象，但主流的Java虚拟机并没有选择用引用计数法来管理内存，因为<strong>无法解决对象之间相互循环引用的问题</strong>，就是两个对象相互引用，除此之外，两个对象并没有其他引用，这两个对象已经不可能被访问了，但他们的引用计数都不为0，所以无法被垃圾收集器回收。</p>
</li>
<li><p>可达性分析</p>
<p> 可达性分析法也被称之为<strong>根搜索法</strong>，将一系列的根对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，如果一个对象到根对象有引用链相连，该对象就是可达的，就不会被回收，如果是不可达的就会被判定是可以回收的。更准确的说，一个对象只要满足下述两个条件之一，就会被判断为可达的：</p>
<ul>
<li>对象是属于GC Roots中的对象：<ol>
<li>虚拟机栈中引用的对象</li>
<li>方法区中的常量引用的对象</li>
<li>方法区中的类静态属性引用的对象</li>
<li>本地方法栈中本地方法的引用对象</li>
</ol>
</li>
<li>对象被一个可达的对象引用</li>
</ul>
</li>
</ol>
<p>可达性分析的优缺点：</p>
<ol>
<li><strong>优点</strong>：可以解决循环引用的问题，不需要占用额外的空间（这是引用计数法存在的问题）</li>
<li><strong>缺点</strong>：多线程场景下，其他线程可能会更新已经访问过的对象的引用</li>
</ol>
<h3 id="垃圾回收算法有哪些？"><a href="#垃圾回收算法有哪些？" class="headerlink" title="垃圾回收算法有哪些？"></a>垃圾回收算法有哪些？</h3><p>垃圾收集算法主要有标记-清除算法、标记-复制算法、标记-整理算法、分代收集算法</p>
<ul>
<li>标记-清除算法：主要包含标记和清除两个阶段，首先标记出所有需要回收的对象，在标记完成后同一回收所有被标记的对象。效率低、产生大量不连续内存碎片</li>
<li>标记-复制算法：标记完后不直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉其他地方的内存。避免内存碎片产生、性能较低</li>
<li>标记-整理算法：将整个内存分成两个大小相等的区域from 和 to，在找出存活对象后，会将它们从 from 复制到 to 区域，复制的过程中自然完成了碎片整理，复制完成后，交换 from 和 to 的位置。效率高、避免内存碎片产生，但每次可以使用的内存只有原来的一半</li>
<li>分代收集算法：将Java堆分为新生代和老年代，根据每个年代的特点采用合适的收集算法。例如，在新生代每次垃圾回收时会有大量对象死亡，只有少量存活，所以在<strong>新生代选择用标记-复制</strong>算法，在<strong>老年代</strong>每次垃圾回收会有大量对象存活，考虑使用<strong>标记-清除或标记-整理</strong>算法。在商业虚拟机中一般都是采用分代收集算法。</li>
</ul>
<h3 id="minor-GC和Full-GC的过程？"><a href="#minor-GC和Full-GC的过程？" class="headerlink" title="minor GC和Full GC的过程？"></a>minor GC和Full GC的过程？</h3><p>Java堆的基本结构如下，大体上可以分为新生代和老年代：新生代默认占1&#x2F;3，老年代默认占2&#x2F;3，新生代包含Eden区、From Survivor0区和 To Survivor1区，默认比例是8：1：1，老年代就一个Old Memory区。</p>
<p>minor GC：对象先在Eden区分配，当Eden区没有足够的空间去分配时，虚拟机会发起一次Minor GC，将存活的对象放到From Survivor区（对象年龄为1）当再次发生Minor GC，会将Eden区和From区一起清理，存活的对象会被移动到To Survivor区（年龄加1）这时From 区会和To 区进行交换，然后重复第一步，不过这次第一步中的From 区其实是上一轮中的To 区。不管怎样，都会保证交换后名为To区里是空的。每次移动，对象的年龄就会加1，当年龄到达15时（默认是15，可以通过JVM参数设置），会从新生代进入老年代。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p>
<p>还有一种现象是大对象直接晋升老年代，判断了eden里放不下，就去老年代看看能不能放下，能放下就直接放在老年代。</p>
<p>当老年代空间不足时，会先触发 minor gc，如果空间仍然不足，那么就触发 full fc ，停止的时间更长！full GC 之后如果空间还是不足，则触发OOM</p>
<p>Full GC：参考CMS的工作过程。</p>
<h3 id="Minor-GC和Full-GC有什么不同？"><a href="#Minor-GC和Full-GC有什么不同？" class="headerlink" title="Minor GC和Full GC有什么不同？"></a>Minor GC和Full GC有什么不同？</h3><ul>
<li>Minor GC（新生代GC）：指发生在新生代的垃圾收集动作，Java对象大多存活时间不长，所以Minor GC的发生会比较频繁，回收速度也比较快</li>
<li>Full GC&#x2F;Major GC（老年代GC）：指发生在老年代的GC，出现了Full GC，经常会伴随至少一次的Minor GC（不是必然的），Full GC的速度一般会比Minor GC慢10倍以上。</li>
</ul>
<h3 id="什么情况下会触发Minor-GC和Full-GC？"><a href="#什么情况下会触发Minor-GC和Full-GC？" class="headerlink" title="什么情况下会触发Minor GC和Full GC？"></a>什么情况下会触发Minor GC和Full GC？</h3><p>minorGC：</p>
<ul>
<li>Eden区满了</li>
<li>新创建对象的大小大于Eden所剩余空间</li>
</ul>
<p>Full GC（MajorGC）：</p>
<ul>
<li><p>老年代空间不足，创建的大对象的内存大于老年代空间，导致老年代空间不足，则会发生Full GC</p>
</li>
<li><p>通过Minor GC后晋升到老年代的对象平均大小超过了老年代剩余空间，会触发FullGC</p>
</li>
<li><p>System.gc() 方法的调用，此方法会建议JVM进行Full GC，但JVM可能不接受这个建议，所以不一定会执行。</p>
</li>
<li><p>JDK1.7及以前的永久代空间满了，在JDK1.7以前，HotSpot虚拟机的方法区是永久代实现都得，在永久代中会存放一些Class的信息、常量、静态变量等数据，在永久代满了，并且没有配置CMS GC的情况下就会触发Full GC，在JDK1.8开始移除永久代也是为了减少Full GC的频率</p>
</li>
</ul>
<h3 id="为什么要减少Full-GC的发生？"><a href="#为什么要减少Full-GC的发生？" class="headerlink" title="为什么要减少Full GC的发生？"></a>为什么要减少Full GC的发生？</h3><p>Full GC发生过于频繁，会影响性能，因为Full GC会导致STW(Stop-The-World)，STW指的是用户线程在运行至安全点（safe point）或安全区域（safe region）之后，就自行挂起，进入暂停状态，对外的表现就是卡顿。所以应尽量减少Full GC的次数。不过不论是minor gc还是Full gc都会STW，区别只在于STW的时间长短。</p>
<h3 id="垃圾回收器有哪些？"><a href="#垃圾回收器有哪些？" class="headerlink" title="垃圾回收器有哪些？"></a>垃圾回收器有哪些？</h3><p>（JDK 8 默认打开了<code>UseParallelGC</code>参数，因此使用了<code>Parallel GC+ Serial Old GC</code>的收集器组合进行内存回收）</p>
<table>
<thead>
<tr>
<th></th>
<th>新&#x2F;老</th>
<th>清除算法</th>
</tr>
</thead>
<tbody><tr>
<td>Serial GC</td>
<td>新</td>
<td>标记复制</td>
</tr>
<tr>
<td>ParNew GC</td>
<td>新</td>
<td>标记复制</td>
</tr>
<tr>
<td>Parallel GC</td>
<td>新</td>
<td>标记复制</td>
</tr>
<tr>
<td>Serial Old GC</td>
<td>老</td>
<td>标记整理</td>
</tr>
<tr>
<td>Parallel Old GC</td>
<td>老</td>
<td>标记整理</td>
</tr>
<tr>
<td>CMS</td>
<td>老</td>
<td>标记清除</td>
</tr>
<tr>
<td>G1</td>
<td></td>
<td>整体上是标记整理算法，两个区域之间是复制算法</td>
</tr>
</tbody></table>
<p>搭配使用：</p>
<p>Serial GC ~ Serial Old GC    Parallel GC<del>Parallel Old GC     ParNew GC</del>CMS ~Serial Old GC  </p>
<p>（1）Serial收集器</p>
<p>Serial收集器是最基本的收集器，并且是单线程的收集器，这里的单线程不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，在它进行垃圾收集时，必须暂停其他所有的线程工作，直到它收集结束。不难想象，这对很多应用来说都是难以接受的。除了上面写到的缺点，Serial收集器也有着优于其他收集器的地方，简单而高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾回收自然可以获得最高的单线程的收集效率。</p>
<p>（2）ParNew收集器</p>
<p>ParNew收集器是Serial收集器的多线程版本，除了使用多条线程进行垃圾回收外，其他地方与Serial一样</p>
<p>（3）Parallel 收集器</p>
<p>Parallel Scavenge 是一个使用标记-复制算法的多线程收集器，看起来和ParNew很像，ParallelScavenge收集器的关注点和与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间（用户体验），而Parallel Scavenge收集器的关注点是达到一个可控制的吞吐量（提高CPU的效率），这里的吞吐量指的是CPU用于运行代码的时间和CPU总消耗时间的比值。</p>
<p>那更短的停顿时间和更高的吞吐量有什么好处呢？</p>
<p>停顿时间越短越适合需要与用户交互的程序，良好的响应速度可以提升用户体验。更高的吞吐量适合在后台运算而不需要太多交互的程序，高吞吐量可以提高CPU的利用率，尽快地完成程序的运算任务。</p>
<p>（4）Serial Old收集器</p>
<p>Serial Old是Serial收集器的老年代版本，同样是单线程收集器，采用标记-整理算法，主要有两大用途：一是在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使用，二是作为CMS收集器的后备预案。</p>
<p>（5）Parallel Old收集器</p>
<p>Parallel Old是Parallel Scavenge收集器的老年代版本，采用多线程和标记-整理算法。该收集器是在JDK1.6才开始提供的，因为当新生代选择了Parallel Scavenge收集器，老年代只能选择Serial Old（Parallel Scavenge无法与CMS搭配使用），这时Serial Old收集器会影响整体的吞吐量，所以提供了Parallel Old收集器和Parallel Scavenge搭配使用</p>
<p>（6）CMS收集器</p>
<p>（7）G1收集器</p>
<h3 id="CMS收集器是怎样的"><a href="#CMS收集器是怎样的" class="headerlink" title="CMS收集器是怎样的"></a>CMS收集器是怎样的</h3><p>CMS（Concurrent Mark Sweep）收集器是一种<strong>获取响应时间优先的收集器（最短回收停顿时间）</strong>，基于<strong>标记-清除</strong>算法实现，是一款<strong>老年代</strong>收集器，它非常符合那些集中在互联网站或者B&#x2F;S系统的服务端上的Java应用，这些应用都非常重视服务的响应速度。整个工作流程包括四个步骤：</p>
<ol>
<li><strong>初始标记</strong>：暂停用户线程（STW），标记GC Roots能直接关联的对象，速度很快</li>
<li><strong>并发标记</strong>：同时开启GC线程和用户线程，从GC Roots的直接关联对象开始遍历所有对象的过程，耗时较长</li>
<li><strong>重新标记</strong>：暂停用户线程（STW），修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</li>
<li><strong>并发清除</strong>：同时开启GC线程和用户线程，清理删除标记阶段判断的已经死亡的对象，不需要移动存活对象。此时的用户线程还是可能会产生新垃圾，这些垃圾就叫<strong>浮动垃圾</strong>，只能由下一次GC来处理，因此堆内存也需要预留一些空间给这些浮动垃圾，不能等整个堆内存都满了才GC。浮动垃圾如果也非常多，内存不够放，就会并发失败</li>
</ol>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/JVM-GC-%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88GC.png" srcset="/img/loading.gif" lazyload alt="image-20220303162716397"></p>
<p>由于整个过程中耗时最长的并发标记和并发清除过程，收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<blockquote>
<p>并行：指多条垃圾收集器线程并行工作，此时用户线程仍处于等待状态</p>
<p>并发：指用户线程与垃圾收集线程同时执行（也可以交替执行）</p>
</blockquote>
<p>优点：并发收集、停顿低</p>
<p>缺点：</p>
<ul>
<li>对CPU资源敏感，总吞吐量会降低</li>
<li>无法处理浮动垃圾</li>
<li>标记-清除算法导致内存碎片</li>
<li>浮动垃圾、内存碎片过多会导致并发失败，此时老年代就会退化为serialOld回收器，进行标记整理，很耗费时间</li>
</ul>
<h3 id="G1收集器是怎样的？"><a href="#G1收集器是怎样的？" class="headerlink" title="G1收集器是怎样的？"></a>G1收集器是怎样的？</h3><p><strong>G1（Garbage First）</strong>，打破了原有的分代模型，将堆划分为一个个区域。</p>
<p>这么做的目的是在进行回收时不必在全堆范围内进行，可以根据<strong>暂停时间目标</strong>优先回收价值高的区域，实现了接近实时的回收特性</p>
<p>整个流程包括四个步骤：</p>
<ul>
<li>初始标记（会STW）：仅仅只是标记一下 GC Roots 能直接关联到的对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</li>
<li>并发标记：从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。</li>
<li>最终标记（会STW）：对用户线程做短暂的暂停，处理并发阶段结束后仍有引用变动的对象。</li>
<li>筛选回收（会STW）：更新每个内存块的统计数据，对各个内存块的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划（<strong>不会对所有老年代区域进行回收</strong>），即根据<strong>暂停时间目标</strong>优先回收价值高（这几个地方垃圾多，回收了能释放的空间多）的区域，可以自由选择任意多个内存块构成回收集，然后把决定回收的那一部分内存块的存活对象复制到空的内存块中，再清理掉整个旧内存块的全部空间。这里的操作涉及存活对象的移动，必须暂停用户线程，由多条回收器线程并行完成的。</li>
</ul>
<p>也有人将G1分为三个大步骤：</p>
<ul>
<li>新生代回收：Minor GC回收新生代垃圾，同时完成上面提到的初始标记</li>
<li>并发标记：Minor GC时完成了初始标记，当老年代占用内存超过阈值后，进行并发标记，这时无需暂停用户线程</li>
<li>混合回收：上面的最终标记+筛选回收</li>
</ul>
<p>G1 具备如下特点：</p>
<ol>
<li><strong>并行与并发</strong>：G1 能充分利用多 CPU、多核环境下的硬件优势，<strong>使用多个 CPU 来缩短 Stop-the-world 停顿的时间</strong>，部分其他收集器原来需要停顿 Java 线程执行的 GC 操作，G1 收集器仍然可以通过并发的方式让 Java 程序继续运行。</li>
<li><strong>分代收集</strong>：打破了原有的分代模型，将堆划分为一个个区域，G1可以不需要其他收集器配合就能独自管理整个GC堆</li>
<li><strong>空间整合</strong>：G1 整体使用“标记-整理”算法，两个区域之间是复制算法。<strong>不会产生内存空间碎片</strong>，有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC</li>
<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的一个优势，降低停顿时间是 G1 和 CMS 共同的关注点。</li>
</ol>
<h3 id="CMS和G1的区别？"><a href="#CMS和G1的区别？" class="headerlink" title="CMS和G1的区别？"></a>CMS和G1的区别？</h3><p>区别一：使用范围不一样</p>
<ul>
<li>CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用</li>
<li>G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用</li>
</ul>
<p>区别二：STW的时间</p>
<ul>
<li>CMS收集器以相应时间优先为目标</li>
<li>G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型）</li>
</ul>
<p>区别三：垃圾碎片</p>
<ul>
<li>CMS收集器是使用“<strong>标记-清除</strong>“算法进行的垃圾回收，容易产生内存碎片</li>
<li>G1收集器使用的是“<strong>标记-整理</strong>”算法，进行了空间整合，降低了内存空间碎片。</li>
</ul>
<p>区别四：垃圾回收的过程不一样</p>
<ul>
<li>CMS收集器：初始标记、并发标记、重新标记、并发清除</li>
<li>G1收集器：初始标记、并发标记、最终标记、筛选回收</li>
</ul>
<h3 id="GC中Stop-the-world（STW）"><a href="#GC中Stop-the-world（STW）" class="headerlink" title="GC中Stop the world（STW）"></a>GC中Stop the world（STW）</h3><p>垃圾回收首先是要经过标记的，对象被标记后就会根据不同的区域采用不同的收集方法。垃圾回收并不会阻塞我们程序的线程，他是与当前程序并发执行的。所以问题就出在这里，当GC线程标记好了一个对象的时候，此时我们程序的线程又将该对象重新加入了“关系网”中，当执行二次标记的时候，该对象也没有重写finalize()方法，因此回收的时候就会回收这个不该回收的对象。 虚拟机的解决方法就是<strong>在一些特定指令位置设置一些“安全点”，当程序运行到这些“安全点”的时候就会暂停所有当前运行的线程（Stop The World 所以叫STW）</strong>，暂停后再找到“GC Roots”进行关系的组建，进而执行标记和清除。 </p>
<p>这些特定的指令（安全点）位置主要在：</p>
<ul>
<li>循环的末尾</li>
<li>方法临返回前 &#x2F; 调用方法的call指令后</li>
<li>可能抛异常的位置</li>
</ul>
<p>停顿类型就是STW，至于<strong>有GC和Full GC之分，主要是Full GC时STW的时间相对GC来说时间很长</strong>，因为Full GC针对整个堆以及永久代的，因此整个GC的范围大大增加；还有就是他的回收算法就是“标记–清除–整理”，这里也会损耗一定的时间。所以我们在优化JVM的时候，减少Full GC的次数也是经常用到的办法。</p>
<h3 id="x3D-x3D-强引用弱引用软引用虚引用？-x3D-x3D"><a href="#x3D-x3D-强引用弱引用软引用虚引用？-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;强引用弱引用软引用虚引用？&#x3D;&#x3D;"></a>&#x3D;&#x3D;强引用弱引用软引用虚引用？&#x3D;&#x3D;</h3><ol>
<li>强引用：强引用是在程序代码之中普遍存在的引用赋值，类似<code>Object o = new Object()</code>这种引用关系。无论任何情况下，只要强引用关系还在，垃圾收集器就<strong>永远不会回收</strong>掉被引用的对象。</li>
<li>软引用：用来描述一些还<strong>有用但非必须</strong>的对象。只被软引用关联的对象，<strong>首次垃圾回收不会回收该对象，如果内存仍不足，再次回收时才会释放对象</strong>。 软引用自身想释放时需要配合<strong>引用队列</strong>来释放<br> 应用场景：做缓存（浏览器的后退按钮）</li>
<li>弱引用：也是用来描述那些<strong>有用但非必须</strong>对象，但它的强度比软引用更弱一些，当垃圾收集器开始工作时，<strong>无论当前内存是否足够，都会回收掉只被弱引用关联的对象</strong>。</li>
<li>虚引用：最弱的一种引用关系，无法通过虚引用来获取一个对象，虚引用的唯一目的就是能在这个对象被回收时收到一个系统通知</li>
</ol>
<h3 id="有什么办法主动通知虚拟机进行垃圾回收？"><a href="#有什么办法主动通知虚拟机进行垃圾回收？" class="headerlink" title="有什么办法主动通知虚拟机进行垃圾回收？"></a>有什么办法主动通知虚拟机进行垃圾回收？</h3><p>可以通过调用system.gc() 方法通知虚拟机进行垃圾回收，但Java虚拟机规范并不能保证一定会执行。</p>
<h3 id="JVM中的永久代中会发生垃圾回收吗？元空间会发生垃圾回收吗？"><a href="#JVM中的永久代中会发生垃圾回收吗？元空间会发生垃圾回收吗？" class="headerlink" title="JVM中的永久代中会发生垃圾回收吗？元空间会发生垃圾回收吗？"></a>JVM中的永久代中会发生垃圾回收吗？元空间会发生垃圾回收吗？</h3><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h3 id="什么是类加载"><a href="#什么是类加载" class="headerlink" title="什么是类加载"></a>什么是类加载</h3><p>当需要某个类的时候，jvm会加载.class文件，并创建对应的class对象，将class文件加载到虚拟机的内存，这个过程被称为类的加载</p>
<p>类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。简言之：把类(class)装载进内存</p>
<h3 id="Java类加载的时机"><a href="#Java类加载的时机" class="headerlink" title="Java类加载的时机"></a>Java类加载的时机</h3><p>1、隐式加载：new创建类的实例</p>
<p>2、显示加载：loaderClass、forName</p>
<blockquote>
<p>forName和loaderClass区别？</p>
<ul>
<li>Class.forName()得到的class是已经初始化完成的</li>
<li>ClassLoader.loadClass()得到的class是还没有链接的</li>
</ul>
</blockquote>
<p>3、访问类的静态变量，或者为静态变量赋值</p>
<p>4、调用类的静态方法</p>
<p>5、使用反射创建某个类或者接口的Class对象</p>
<p>6、初始化某个类的子类</p>
<p>7、直接使用java.exe命令来运行某个类</p>
<h3 id="简述类的生命周期"><a href="#简述类的生命周期" class="headerlink" title="简述类的生命周期"></a>简述类的生命周期</h3><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，生命周期包括：</p>
<ul>
<li>加载</li>
<li>链接<ul>
<li>验证、准备、解析</li>
</ul>
</li>
<li>初始化</li>
<li>使用</li>
<li>卸载</li>
</ul>
<h3 id="Java类加载的过程"><a href="#Java类加载的过程" class="headerlink" title="Java类加载的过程"></a>Java类加载的过程</h3><p>当需要某个类的时候，jvm会将class文件加载到虚拟机的内存，并创建对应的class对象，这个过程被称为类的加载。</p>
<ul>
<li>加载：ClassLoader将类的字节码载入方法区，并在堆中创建一个class对象。如果此类的父类没有加载，先加载父类</li>
<li>链接<ul>
<li>验证：验证类是否符合 Class 规范，合法性、安全性检查</li>
<li>准备：为 static 变量分配空间，设置默认值<ul>
<li>static int i &#x3D; 5这里只是将i赋值为0，初始化的阶段再把i赋值为5</li>
<li>不包含final修饰的static，因为final在编译的时候就已经分配了（不管是基本类型还是引用类型）</li>
</ul>
</li>
<li>解析：将常量池的符号引用解析为直接引用（类A里用了类B，符号引用就是只知道有类B这样一个符号，直接引用知道B的地址）</li>
</ul>
</li>
<li>初始化：为 static 变量赋值，如果该类有父类就对父类进行初始化</li>
</ul>
<h3 id="类加载器有哪些"><a href="#类加载器有哪些" class="headerlink" title="类加载器有哪些"></a>类加载器有哪些</h3><ul>
<li>启动类加载器（Bootstrap ClassLoader）：由C++语言实现，是虚拟机自身的一部分，主要加载<code>JAVA_HOME/jre/lib</code>目录下的类，都是些核心类，也可通过在控制台输入指令，使得类被启动类加器加载</li>
<li>扩展类加载器（Extension ClassLoader）：由Java语言实现，独立于虚拟机外部，负责加载<code>JAVA_HOME/jre/lib/ext</code>目录下的类库。</li>
<li>应用程序类加载器（Application ClassLoader）：由Java语言实现，独立于虚拟机外部，负责加载用户路径上所指定的类库，如果程序中没有自己定义过的类加载器，一般情况这个是程序中的默认类加载器</li>
<li>自定义类加载器：加载自定义类</li>
</ul>
<h3 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h3><p>如果一个类收到了类加载的请求，它并不会自己先去加载，而是把这个请求委托给上级加载器去执行，如果上级加载器还有上级加载器，则进一步向上委托，依次递归，请求最后到达顶层的启动类加载器，如果上级能够完成类的加载任务，就会成功返回，如果上级加载器无法完成任务，下级加载器才会尝试自己去加载。</p>
<p>通俗理解：每个下级都很懒，遇到类加载的活都给上级干，直到上级说我也做不来的时候，下级才会想办法自己去加载。</p>
<p>其源码实现方式就是：自底向上检查类是否被加载，然后再自顶向下尝试加载类</p>
<p><img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.png" srcset="/img/loading.gif" lazyload alt="image-20220304125301954"></p>
<h3 id="双亲委派模式的优点-x2F-目的"><a href="#双亲委派模式的优点-x2F-目的" class="headerlink" title="双亲委派模式的优点&#x2F;目的"></a>双亲委派模式的优点&#x2F;目的</h3><ul>
<li>让类的加载有优先次序，保证核心类优先加载，避免类的重复加载</li>
<li>让上级类加载器中的类对下级共享，反之不行，保证核心类不会被篡改</li>
</ul>
<p>例如，你自己编写了一个java.lang.Object类，也不会被加载，因为根据双亲委派机制，会由启动类加载器进行加载，会先加载位于rt.jar中的java.lang.Object类，并且其他子类加载器不会再去加载ava.lang.Object类。</p>
<h3 id="类加载器中的父类加载器和子类加载器是继承关系吗？"><a href="#类加载器中的父类加载器和子类加载器是继承关系吗？" class="headerlink" title="类加载器中的父类加载器和子类加载器是继承关系吗？"></a>类加载器中的父类加载器和子类加载器是继承关系吗？</h3><p>在双亲委派模型中，类加载器之间的父子关系一般不是以继承关系实现的，而是组合的关系来复用父加载器的代码的</p>
<blockquote>
<p>注意:</p>
<p>这里的双亲，翻译为上级似乎更为合适，因为它们并没有继承关系，只是级别不一样</p>
<p>我们一般理解的双亲都是父母，这里的双亲更多地表达的是“父母这一辈”的人而已，并不是说真的有一个 Mother ClassLoader 和一个 Father ClassLoader 。另外，类加载器之间的“父子”关系也不是通过继承来体现的，是由“优先级”来决定。</p>
<p>官方 API 文档的描述: The Java platform uses a delegation model for loading classes. The basic idea is that every class loader has a “parent” class loader. When loading a class, a class loader first “delegates” the search for the class to its parent class loader before attempting to find the class itself.</p>
</blockquote>
<h3 id="双亲委派机制的弊端是什么呢？"><a href="#双亲委派机制的弊端是什么呢？" class="headerlink" title="双亲委派机制的弊端是什么呢？"></a>双亲委派机制的弊端是什么呢？</h3><p>父类加载器的优先级是大于子类加载器的，只有父类加载器无法加载，子类加载器才会去尝试加载，这在大多数情况是没有问题的，因为越上层加载的类通常是基础类（像Object类），一般情况这些基础类都是被用户代码所调用的API</p>
<p>但基础类要是想调用用户的代码，那就会出问题了，因为第三方的类不能被启动类加载器加载。</p>
<h3 id="如何破坏双亲委派机制？"><a href="#如何破坏双亲委派机制？" class="headerlink" title="如何破坏双亲委派机制？"></a>如何破坏双亲委派机制？</h3><p>这个需要先去了解双亲委派是怎么实现的，看下java.lang.ClassLoader的loadClass()源码就知道了，这里就不展开写了</p>
<p>想破环双亲委派就自定义一个类加载器，重写其中的loadClass()方法即可。如果不想破坏双亲委派，那么重写findClass()方法。</p>
<h3 id="有哪些打破双亲委派机制的例子"><a href="#有哪些打破双亲委派机制的例子" class="headerlink" title="有哪些打破双亲委派机制的例子"></a>有哪些打破双亲委派机制的例子</h3><ul>
<li>在双亲委派出现之前，双亲委派模型是在JDK1.2引入的，在此之前就有自定义类加载器了，这些自然是没遵循双亲委派机制的</li>
<li>JIDI服务及前面提到的JDBC服务，如何解决这个问题呢？Java设计团队引入了上下文类加载器，<strong>通过上下文类加载器可以使得父类加载器请求子类加载器去完成类的加载动作</strong>。</li>
<li>tomcat等web服务器，因为一个web容器可以部署多个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，但不同版本的类库中的全限定名很可能是一样的，如果采取双亲委派机制，这里就无法加载多个相同的类，解决方法就是，破坏双亲委派原则，提供隔离的机制，为每个web容器提供一个单独的类加载器</li>
<li>用户对程序动态性的追求导致的，比如代码热替换、模块热部署等，已经成为Java模块化标准的OSGi，实现模块化热部署的关键是它自定义的类加载，每个程序模块都有自己的类加载器，当需要更换一个程序模块时，会把程序模块和类加载器一起替换掉实现代码的热替换</li>
</ul>
<h3 id="NoClassDefFoundError-和-ClassNotFoundException-有什么区别？略"><a href="#NoClassDefFoundError-和-ClassNotFoundException-有什么区别？略" class="headerlink" title="NoClassDefFoundError 和 ClassNotFoundException 有什么区别？略"></a>NoClassDefFoundError 和 ClassNotFoundException 有什么区别？<font color=red>略</font></h3><p>1、ClassNotFoundException：当应用程序运行的过程中尝试使用<strong>类加载器去加载Class文件的时候，如果没有在classpath中查找到指定的类</strong>，就会抛出ClassNotFoundException。一般情况下，当我们使用Class.forName()或者ClassLoader.loadClass()以及使用ClassLoader.findSystemClass()在运行时加载类的时候，如果类没有被找到，那么就会导致JVM抛出ClassNotFoundException。</p>
<p>2、NoClassDefFoundError：当JVM在加载一个类的时候，如果这个<strong>类在编译时是可用的，但是在运行时找不到这个类的定义</strong>的时候，JVM就会抛出一个NoClassDefFoundError错误。比如当我们在new一个类的实例的时候，如果在运行时类找不到，则会抛出一个NoClassDefFoundError的错误。</p>
<h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><p>虚拟机性能监控的一些命令</p>
<ul>
<li>jsp：JVM Process Status Tool，显示指定系统内所有的HotSpot虚拟机进程</li>
<li>jstat：JVM Statistics Monitoring Tool，用于收集HopSpot虚拟机各方面的运行数据，例如虚拟机进程中的类装载、内存、垃圾收集等数据</li>
<li>jinfo：Configuration Info for Java，显示虚拟机配置信息</li>
<li>jmap：Memory Map for Java，生成虚拟机的内存转储快照（headdump），还可以查询Java堆、永久代的详细信息等</li>
<li>jhat：JVM Heap Dump Browser，用于分析heapdump文件，它会建立一个HTTP&#x2F;HTML服务器，让用户在浏览器上查看分析结果</li>
<li>jstack：Stack Trace for Java，显示虚拟机的线程快照，查看各个线程的调用堆栈，可以定位线程出现长时间停顿的原因</li>
</ul>
<h3 id="JVM如何调优"><a href="#JVM如何调优" class="headerlink" title="JVM如何调优"></a>JVM如何调优</h3><p>本来这个地方只是想列几个常用的JVM参数就完了，毕竟大多数项目并不需要JVM调优，千万别项目中出了问题就想JVM调优，这绝对是本末倒置的做法。不过虽然项目中大概率用不到，但是面试会问啊，所以还是简单介绍下。</p>
<p>正常的情况下项目出问题或者系统优化应该先从应用层面开始，然后往底层过度，首先查查是不是代码写的太垃圾了，逻辑上有没有可优化的地方等等，然后再看看数据库有没有可优化的地方，在然后可以考虑JVM层面的优化，最后，可以考虑底层操作系统层面的优化。前两者基本就解决了大部分问题。</p>
<h3 id="JVM调优的目标"><a href="#JVM调优的目标" class="headerlink" title="JVM调优的目标"></a>JVM调优的目标</h3><p>大多数时候，JVM的调优最主要的目标是<strong>停顿时间和吞吐量</strong>，停顿时间一般是由垃圾收集引起的，可以简单理解为系统对请求的响应速度，吞吐量是指用户程序运行时间占用户程序运行时间和垃圾收集总时间的比值，可以简单理解为系统在特定时间内的最大工作量。还有一个指标是<strong>内存占用</strong>，程序正常运行所需要的内存，自然是越小越好。</p>
<p>JVM优化得目标就是系统以较小的内存资源获得较低的停顿时间和较高的吞吐量，这当然不现实了，又想马儿跑，还想马儿不吃草，所以还是要根据具体场景具体分析。</p>
<h3 id="JVM调优策略"><a href="#JVM调优策略" class="headerlink" title="JVM调优策略"></a>JVM调优策略</h3><p>JVM调优的具体策略基本都是围绕着两部分展开的：内存和垃圾回收器</p>
<ul>
<li>调整内存大小，如果内存太小，那么GC会非常频繁的，停顿时间自然就长了</li>
<li>调整新生代和老年代的比重等，比如IO密集型的，就可以把新生代加大些，因为大多数对象在新生代就会消亡</li>
<li>调整晋升老年代的年龄，比如老年代频繁GC，可以考虑增大老年代的比重，也可以提高晋升老年代的年龄</li>
<li>大对象分配的标准，因为大对象是直接进入老年代的，如果大对象的标准不合适，也会出现问题</li>
<li>选择合适的垃圾回收器及垃圾回收器的各种参数，比如如果是CPU是单核的，就选Serial就可以了等等</li>
<li>上面这只是简单举例，类似的情况还有很多，简单来说就是围绕着内存和垃圾回收器具体情况具体分析</li>
</ul>
<h3 id="JVM调优参数"><a href="#JVM调优参数" class="headerlink" title="JVM调优参数"></a>JVM调优参数</h3><p>前面说了调优策略主要是围绕着内存和垃圾回收器，那么可调的参数大多也是围绕这两个。</p>
<p>内存部分参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-Xms</td>
<td>初始堆大小</td>
</tr>
<tr>
<td>-Xmx</td>
<td>最大堆大小</td>
</tr>
<tr>
<td>-Xmn</td>
<td>新生代大小</td>
</tr>
<tr>
<td>-Xss</td>
<td>设置每个线程的堆栈大小</td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>设置新生代与年老代的比值</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>设置新生代中Eden区与Survivor区的大小比值</td>
</tr>
<tr>
<td>-XX:PermSize&#x2F;-XX:MetaspaceSize</td>
<td>初始化持久代&#x2F;元空间大小</td>
</tr>
<tr>
<td>-XX:MaxPermSize&#x2F;-XX:MaxMetaspaceSize</td>
<td>设置持久代&#x2F;元空间最大值</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold</td>
<td>设置进入老年代的年龄</td>
</tr>
</tbody></table>
<p>垃圾回收器相关参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:+UseG1GC</td>
<td>使用G1垃圾回收器</td>
</tr>
<tr>
<td>-XX:ParallelGCThreads</td>
<td>并行收集器的线程数</td>
</tr>
<tr>
<td>-XX:GCTimeRatio</td>
<td>设置垃圾回收时间占程序运行时间的百分比</td>
</tr>
<tr>
<td>-XX:MaxGCPauseMillis</td>
<td>设置目标停顿时间</td>
</tr>
</tbody></table>
<h3 id="JVM的调优步骤"><a href="#JVM的调优步骤" class="headerlink" title="JVM的调优步骤"></a>JVM的调优步骤</h3><p>JVM调优肯定不是乱调的，也应先确定瓶颈及调优目标，如下：</p>
<ul>
<li>分析GC日志及通过虚拟机监控的命令查看系统运行情况，找出哪里出了问题</li>
<li>确定调优的目标</li>
<li>确定调优策略及调整相关参数，这是个不断对比分析和调整的过程，很难一步到位的</li>
</ul>
<h3 id="JVM调优案例"><a href="#JVM调优案例" class="headerlink" title="JVM调优案例"></a>JVM调优案例</h3><p>前面简单介绍了JVM调优的方法和策略，下面从网上找了一些调优的案例，大家可以参考一下</p>
<ol>
<li>数据分析平台系统频繁 Full GC</li>
</ol>
<p>平台主要对用户在 App 中行为进行定时分析统计，并支持报表导出，使用 CMS GC 算法。数据分析师在使用中发现系统页面打开经常卡顿，通过 jstat 命令发现系统每次 Young GC 后大约有10% 的存活对象进入老年代。原来是因为 Survivor 区空间设置过小，每次 Young GC 后存活对象在 Survivor 区域放不下，提前进入老年代。</p>
<p>通过调大 Survivor 区，使得 Survivor 区可以容纳 Young GC 后存活对象，对象在 Survivor 区经历多次Young GC 达到年龄阈值才进入老年代。调整之后每次 Young GC 后进入老年代的存活对象稳定运行时仅几百 Kb，Full GC 频率大大降低。</p>
<ol start="2">
<li>业务对接网关 OOM</li>
</ol>
<p>网关主要消费 Kafka 数据，进行数据处理计算然后转发到另外的 Kafka 队列，系统运行几个小时候出现OOM，重启系统几个小时之后又 OOM。</p>
<p>通过 jmap 导出堆内存，在 eclipse MAT 工具分析才找出原因：代码中将某个业务 Kafka 的 topic 数据进行日志异步打印，该业务数据量较大，大量对象堆积在内存中等待被打印，导致 OOM。</p>
<ol start="3">
<li>鉴权系统频繁长时间 Full GC</li>
</ol>
<p>系统对外提供各种账号鉴权服务，使用时发现系统经常服务不可用，通过 Zabbix 的监控平台监控发现系统频繁发生长时间 Full GC，且触发时老年代的堆内存通常并没有占满，发现原来是业务代码中调用了System.gc()。</p>
<ol start="4">
<li>网站流量浏览量暴增后，网站反应页面响很慢。</li>
</ol>
<p>（1）问题推测：在测试环境测速度比较快，但是一到生产就变慢，所以推测可能是因为垃圾收集导致的业务线程停顿。</p>
<p>（2）定位：为了确认推测的正确性，在线上通过jstat -gc 指令 看到JVM进行GC 次数频率非常高，GC所占用的时间非常长，所以基本推断就是因为GC频率非常高，所以导致业务线程经常停顿，从而造成网页反应很慢。</p>
<p>（3）解决方案：因为网页访问量很高，所以对象创建速度非常快，导致堆内存容易填满从而频繁GC，所以这里问题在于新生代内存太小，所以这里可以增加JVM内存就行了，所以初步从原来的2G内存增加到16G内存。</p>
<p>（4）第二个问题：增加内存后的确平常的请求比较快了，但是又出现了另外一个问题，就是不定期的会间断性的卡顿，而且单次卡顿的时间要比之前要长很多。</p>
<p>（5）问题推测：联想到是之前的优化加大了内存，所以推测可能是因为内存加大了，从而导致单次GC的时间变长从而导致间接性的卡顿。</p>
<p>（6）定位：还是通过jstat -gc 指令 查看到 的确FGC（FULL GC）次数并不是很高，但是花费在FGC上的时间是非常高的,根据GC日志 查看到单次FGC的时间有达到几十秒的。</p>
<p>（7）解决方案： 因为JVM默认使用的是PS+PO的组合，PS+PO垃圾标记和收集阶段都是STW，所以内存加大了之后，需要进行垃圾回收的时间就变长了，所以这里要想避免单次GC时间过长，所以需要更换并发类的收集器，因为当前的JDK版本为1.7，所以最后选择G1垃圾收集器，根据之前垃圾收集情况设置了一个预期的停顿的时间，上线后网站再也没有了卡顿问题。</p>
<ol start="5">
<li>后台导出数据引发的OOM</li>
</ol>
<p>问题描述：公司的后台系统，偶发性的引发OOM异常，堆内存溢出。</p>
<p>（1）因为是偶发性的，所以第一次简单的认为就是堆内存不足导致，所以单方面的加大了堆内存从4G调整到8G。</p>
<p>（2）但是问题依然没有解决，只能从堆内存信息下手，通过开启了-XX:+HeapDumpOnOutOfMemoryError参数获得堆内存的dump文件。</p>
<p>（3）VisualVM 对 堆dump文件进行分析，通过VisualVM查看到占用内存最大的对象是String对象，本来想跟踪着String对象找到其引用的地方，但dump文件太大，跟踪进去的时候总是卡死，而String对象占用比较多也比较正常，最开始也没有认定就是这里的问题，于是就从线程信息里面找突破点。</p>
<p>（4）通过线程进行分析，先找到了几个正在运行的业务线程，然后逐一跟进业务线程看了下代码，发现有个引起我注意的方法，导出订单信息。</p>
<p>（5）因为订单信息导出这个方法可能会有几万的数据量，首先要从数据库里面查询出来订单信息，然后把订单信息生成excel，这个过程会产生大量的String对象。</p>
<p>（6）为了验证自己的猜想，于是准备登录后台去测试下，结果在测试的过程中发现到处订单的按钮前端居然没有做点击后按钮置灰交互事件，结果按钮可以一直点，因为导出订单数据本来就非常慢，使用的人员可能发现点击后很久后页面都没反应，结果就一直点，结果就大量的请求进入到后台，堆内存产生了大量的订单对象和EXCEL对象，而且方法执行非常慢，导致这一段时间内这些对象都无法被回收，所以最终导致内存溢出。</p>
<p>（7）知道了问题就容易解决了，最终没有调整任何JVM参数，只是在前端的导出订单按钮上加上了置灰状态，等后端响应之后按钮才可以进行点击，然后减少了查询订单信息的非必要字段来减少生成对象的体积，然后问题就解决了。</p>
<ol start="6">
<li>CPU经常100% 问题定位思路。</li>
</ol>
<p>问题分析：CPU高一定是某个程序长期占用了CPU资源。</p>
<p>（1）所以先需要找出那个进行占用CPU高。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">top</span> 列出系统各个进程的资源占用情况。<br></code></pre></td></tr></table></figure>

<p>（2）然后根据找到对应进行里哪个线程占用CPU高。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">top</span> -Hp 进程ID 列出对应进程里面的线程占用资源情况<br></code></pre></td></tr></table></figure>

<p>（3）找到对应线程ID后，再打印出对应线程的堆栈信息</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">printf</span> <span class="hljs-string">&quot;%x\n&quot;</span> PID 把线程ID转换为<span class="hljs-number">16</span>进制。<br><span class="hljs-attribute">jstack</span> PID 打印出进程的所有线程信息，从打印出来的线程信息中找到上一步转换为<span class="hljs-number">16</span>进制的线程ID对应的线程信息。<br></code></pre></td></tr></table></figure>

<p>（4）最后根据线程的堆栈信息定位到具体业务方法,从代码逻辑中找到问题所在。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">查看是否有线程长时间的watting 或blocked如果线程长期处于watting状态下， 关注watting <span class="hljs-keyword">on</span> xxxxxx，说明线程在等待这把锁，然后根据锁的地址找到持有锁的线程。<br></code></pre></td></tr></table></figure>



<ol start="7">
<li>内存飚高问题定位思路。</li>
</ol>
<p>分析： 内存飚高如果是发生在java进程上，一般是因为创建了大量对象所导致，持续飚高说明垃圾回收跟不上对象创建的速度，或者内存泄露导致对象无法回收。</p>
<p>（1）先观察垃圾回收的情况</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">jstat</span> -gc PID <span class="hljs-number">1000</span> 查看GC次数，时间等信息，每隔一秒打印一次。<br><span class="hljs-attribute">jmap</span> -histo PID | head -<span class="hljs-number">20</span> 查看堆内存占用空间最大的前<span class="hljs-number">20</span>个对象类型,可初步查看是哪个对象占用了内存。<br></code></pre></td></tr></table></figure>

<p>如果每次GC次数频繁，而且每次回收的内存空间也正常，那说明是因为对象创建速度快导致内存一直占用很高；如果每次回收的内存非常少，那么很可能是因为内存泄露导致内存一直无法被回收。</p>
<p>（2）导出堆内存文件快照</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">jmap -<span class="hljs-keyword">dump</span>:live,format=b,<span class="hljs-keyword">file</span>=<span class="hljs-regexp">/home/my</span>heapdump.hprof PID        <span class="hljs-keyword">dump</span>堆内存信息到文件。<br></code></pre></td></tr></table></figure>

<p>（3）使用visualVM对dump文件进行离线分析，找到占用内存高的对象，再找到创建该对象的业务代码位置，从代码和业务场景中定位具体问题。</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>面试准备：JVM</div>
      <div>http://jswanyu.github.io/2022/03/10/面试准备/JVM/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>万宇</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年3月10日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>






<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
